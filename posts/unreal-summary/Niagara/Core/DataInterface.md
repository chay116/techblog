---
title: "DataInterface - Niagara ë°ì´í„° ì¸í„°í˜ì´ìŠ¤ (Niagara Data Interface)"
date: "2026-02-18"
status: "stable"
project: "UnrealEngine"
lang: "ko"
category: "unreal-summary"
track: "Niagara"
tags: ["unreal", "Niagara", "Core"]
---
# DataInterface - Niagara ë°ì´í„° ì¸í„°í˜ì´ìŠ¤ (Niagara Data Interface)

> Updated: 2026-02-18 ? merged duplicate content from related documents.
## ğŸ§­ ê°œìš” (Overview)

**DataInterface (DI)**ëŠ” **Niagara ì‹œë®¬ë ˆì´ì…˜ê³¼ ì™¸ë¶€ ë°ì´í„°ë¥¼ ì—°ê²°í•˜ëŠ” ì¤‘ê°œ ì‹œìŠ¤í…œ**ì…ë‹ˆë‹¤. Texture, Mesh, Collision, Audio, Curve ë“± ë‹¤ì–‘í•œ ì™¸ë¶€ ë°ì´í„° ì†ŒìŠ¤ë¥¼ íŒŒí‹°í´ ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ì½ê³  ì“¸ ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤.

**í•µì‹¬ ì—­í• :**
- **ì™¸ë¶€ ë°ì´í„° ì ‘ê·¼**: Texture, SkeletalMesh, StaticMesh, Spline ë“±
- **ê²Œì„ ì›”ë“œ ì¿¼ë¦¬**: Collision, Scene Depth, Occlusion Query
- **ì˜¤ë””ì˜¤ ì—°ë™**: Audio Spectrum, Oscilloscope, Player
- **Curve/DataTable**: ë£©ì—… í…Œì´ë¸”, ì»¤ë¸Œ ìƒ˜í”Œë§
- **Grid ì‹œìŠ¤í…œ**: 2D/3D Gridë¡œ íŒŒí‹°í´ ê°„ ë°ì´í„° ê³µìœ 
- **RenderTarget ì¶œë ¥**: íŒŒí‹°í´ ë°ì´í„°ë¥¼ Textureë¡œ ì¶œë ¥
- **Blueprint/C++ ì—°ë™**: ê²Œì„ ë¡œì§ê³¼ íŒŒí‹°í´ í†µì‹ 

**52+ ë‚´ì¥ DataInterface íƒ€ì…** ì œê³µ

**ğŸ“‚ ìœ„ì¹˜:**
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterface.h` (ê¸°ë³¸ í´ë˜ìŠ¤)
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterface*.h` (52+ íƒ€ì…)

---

## ğŸ¯ ì„¤ê³„ ì² í•™: ì™œ DataInterfaceì¸ê°€?

### ë¬¸ì œ: ì™¸ë¶€ ë°ì´í„° ì ‘ê·¼ì˜ ì–´ë ¤ì›€

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DataInterface ì—†ì´ ì™¸ë¶€ ë°ì´í„° ì‚¬ìš© ì‹œ ë¬¸ì œ            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  âŒ ë¬¸ì œ 1: í•˜ë“œì½”ë”©ëœ ë°ì´í„° ì ‘ê·¼                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  - Texture ìƒ˜í”Œë§í•˜ë ¤ë©´ C++ ì½”ë“œ ìˆ˜ì • í•„ìš”                â”‚          â”‚
â”‚  â”‚  - SkeletalMesh ë³¸ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸° â†’ C++ í•¨ìˆ˜ ì‘ì„±         â”‚          â”‚
â”‚  â”‚  - Collision ì²´í¬ â†’ ë³„ë„ ì‹œìŠ¤í…œ êµ¬í˜„                     â”‚          â”‚
â”‚  â”‚  â†’ í™•ì¥ ë¶ˆê°€ëŠ¥, ì¬ì»´íŒŒì¼ í•„ìš”, ì•„í‹°ìŠ¤íŠ¸ê°€ ì‚¬ìš© ë¶ˆê°€       â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  âŒ ë¬¸ì œ 2: CPU/GPU ë¶„ê¸° ì²˜ë¦¬                                            â”‚
â”‚  - CPU ì‹œë®¬ë ˆì´ì…˜: ì§ì ‘ ë©”ëª¨ë¦¬ ì ‘ê·¼ ê°€ëŠ¥                                 â”‚
â”‚  - GPU ì‹œë®¬ë ˆì´ì…˜: HLSL Shaderì—ì„œ ì ‘ê·¼ ë°©ë²• ë‹¤ë¦„                        â”‚
â”‚  â†’ ë™ì¼ ê¸°ëŠ¥ì„ ë‘ ë²ˆ êµ¬í˜„í•´ì•¼ í•¨                                         â”‚
â”‚                                                                         â”‚
â”‚  âŒ ë¬¸ì œ 3: íƒ€ì… ì•ˆì „ì„± ë¶€ì¡±                                             â”‚
â”‚  - ì˜ëª»ëœ ë°ì´í„° íƒ€ì… ì „ë‹¬ ì‹œ ëŸ°íƒ€ì„ í¬ë˜ì‹œ                              â”‚
â”‚  - ì—ë””í„°ì—ì„œ ì˜¤ë¥˜ ê°ì§€ ë¶ˆê°€ëŠ¥                                           â”‚
â”‚  - ë””ë²„ê¹… ì–´ë ¤ì›€                                                         â”‚
â”‚                                                                         â”‚
â”‚  âŒ ë¬¸ì œ 4: ì¬ì‚¬ìš©ì„± ë¶€ì¡±                                                â”‚
â”‚  - ë™ì¼í•œ Texture ìƒ˜í”Œë§ ë¡œì§ì„ ì—¬ëŸ¬ ì—ë¯¸í„°ì—ì„œ ì¤‘ë³µ ì‘ì„±                â”‚
â”‚  - í‘œì¤€í™” ë¶ˆê°€ëŠ¥                                                         â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
                   DataInterface ì†”ë£¨ì…˜:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                         â”‚
â”‚  âœ… í•´ê²° 1: í†µí•© ì¸í„°í˜ì´ìŠ¤ (Unified Interface)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  UNiagaraDataInterface (ê¸°ë³¸ í´ë˜ìŠ¤)                      â”‚          â”‚
â”‚  â”‚  â”œâ”€ GetFunctions(): ì‚¬ìš© ê°€ëŠ¥í•œ í•¨ìˆ˜ ëª©ë¡ ë°˜í™˜           â”‚          â”‚
â”‚  â”‚  â”œâ”€ GetVMExternalFunction(): CPU êµ¬í˜„ ì œê³µ              â”‚          â”‚
â”‚  â”‚  â””â”€ GetGPUComputeCode(): GPU HLSL ì½”ë“œ ìƒì„±             â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ì•„í‹°ìŠ¤íŠ¸ ì‚¬ìš©:                                           â”‚          â”‚
â”‚  â”‚  â””â”€ Niagara ì—ë””í„°ì—ì„œ ë“œë˜ê·¸ ì•¤ ë“œë¡­                    â”‚          â”‚
â”‚  â”‚      â””â”€ "Sample Texture" ë…¸ë“œ ì¶”ê°€                      â”‚          â”‚
â”‚  â”‚          â””â”€ CPU/GPU ìë™ ëŒ€ì‘                           â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  âœ… í•´ê²° 2: CPU/GPU ìë™ ë¶„ê¸°                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  CPU ì‹œë®¬ë ˆì´ì…˜:                                          â”‚          â”‚
â”‚  â”‚  â””â”€ GetVMExternalFunction()                             â”‚          â”‚
â”‚  â”‚      â””â”€ C++ í•¨ìˆ˜ í¬ì¸í„° ë°˜í™˜                             â”‚          â”‚
â”‚  â”‚          â””â”€ VectorVMì—ì„œ ì‹¤í–‰                            â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  GPU ì‹œë®¬ë ˆì´ì…˜:                                          â”‚          â”‚
â”‚  â”‚  â””â”€ GetGPUComputeCode()                                 â”‚          â”‚
â”‚  â”‚      â””â”€ HLSL ì½”ë“œ ë¬¸ìì—´ ë°˜í™˜                            â”‚          â”‚
â”‚  â”‚          â””â”€ Compute Shaderì— í¬í•¨ë˜ì–´ ì»´íŒŒì¼            â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  âœ… í•´ê²° 3: íƒ€ì… ì•ˆì „ì„± ë³´ì¥                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  FNiagaraFunctionSignature                               â”‚          â”‚
â”‚  â”‚  â”œâ”€ Name: "SampleTexture"                               â”‚          â”‚
â”‚  â”‚  â”œâ”€ Inputs: [UV (Vector2), MipLevel (Float)]           â”‚          â”‚
â”‚  â”‚  â””â”€ Outputs: [Color (Vector4)]                         â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ì»´íŒŒì¼ ì‹œ íƒ€ì… ì²´í¬:                                     â”‚          â”‚
â”‚  â”‚  â””â”€ ì˜ëª»ëœ íƒ€ì… ì—°ê²° ì‹œ ì»´íŒŒì¼ ì—ëŸ¬                      â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  âœ… í•´ê²° 4: 52+ ë‚´ì¥ íƒ€ì… + ì»¤ìŠ¤í…€ ì œì‘ ê°€ëŠ¥                             â”‚
â”‚  - Texture, Mesh, Collision, Audio, Curve, Grid ë“±                     â”‚
â”‚  - í”„ë¡œì íŠ¸ë³„ ì»¤ìŠ¤í…€ DataInterface ì œì‘ ê°€ëŠ¥                             â”‚
â”‚  - ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬ì¶•                                         â”‚
â”‚                                                                         â”‚
â”‚  âœ… í•´ê²° 5: Blueprint/C++ ì—°ë™                                           â”‚
â”‚  - UNiagaraDataInterfaceArrayFloat: Blueprintì—ì„œ ë°°ì—´ ì „ë‹¬              â”‚
â”‚  - ê²Œì„ ë¡œì§ â†’ íŒŒí‹°í´ ì‹œë®¬ë ˆì´ì…˜ ì‹¤ì‹œê°„ í†µì‹                              â”‚
â”‚  - ì–‘ë°©í–¥ ë°ì´í„° íë¦„ ì§€ì›                                               â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ì„¤ê³„ ê²°ì •

| ê²°ì • ì‚¬í•­ | ì´ìœ  | íŠ¸ë ˆì´ë“œì˜¤í”„ |
|----------|------|-------------|
| **ê°€ìƒ í•¨ìˆ˜ ê¸°ë°˜** | í™•ì¥ ê°€ëŠ¥ì„±, í”ŒëŸ¬ê·¸ì¸ ì§€ì› | ê°€ìƒ í•¨ìˆ˜ í˜¸ì¶œ ì˜¤ë²„í—¤ë“œ |
| **CPU/GPU ë¶„ë¦¬ êµ¬í˜„** | í”Œë«í¼ë³„ ìµœì í™”, ëª…í™•í•œ ì œì•½ | ì´ì¤‘ êµ¬í˜„ ë¶€ë‹´ |
| **íƒ€ì… ì‹œê·¸ë‹ˆì²˜** | ì»´íŒŒì¼ ì‹œ íƒ€ì… ì²´í¬, ì•ˆì „ì„± | ìœ ì—°ì„± ì œì•½ |
| **Proxy íŒ¨í„´** | Render Thread ë¶„ë¦¬, ìŠ¤ë ˆë“œ ì•ˆì „ | ê°„ì ‘ ì ‘ê·¼ ì˜¤ë²„í—¤ë“œ |
| **HLSL ì½”ë“œ ìƒì„±** | GPU ì„±ëŠ¥ ìµœì í™”, ì¸ë¼ì¸ ê°€ëŠ¥ | ì½”ë“œ ìƒì„± ë³µì¡ë„ |

---

## ğŸ—ï¸ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ (System Architecture)

### ê¸°ë³¸ í´ë˜ìŠ¤ êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       UNiagaraDataInterface                             â”‚
â”‚  (ëª¨ë“  DataInterfaceì˜ ê¸°ë³¸ í´ë˜ìŠ¤)                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ìƒì†: UObject â†’ UNiagaraDataInterfaceBase â†’ UNiagaraDataInterface     â”‚
â”‚                                                                         â”‚
â”‚  ì£¼ìš” ê°€ìƒ í•¨ìˆ˜:                                                          â”‚
â”‚    + GetFunctions(TArray<FNiagaraFunctionSignature>&) : void           â”‚
â”‚      // ì´ DIê°€ ì œê³µí•˜ëŠ” í•¨ìˆ˜ ëª©ë¡ ë°˜í™˜                                  â”‚
â”‚      // ì˜ˆ: "SampleTexture", "GetTextureSize" ë“±                       â”‚
â”‚                                                                         â”‚
â”‚    + GetVMExternalFunction(...) : bool                                 â”‚
â”‚      // CPU ì‹œë®¬ë ˆì´ì…˜ìš© í•¨ìˆ˜ í¬ì¸í„° ë°˜í™˜                                â”‚
â”‚      // VectorVMì—ì„œ í˜¸ì¶œë  C++ í•¨ìˆ˜                                    â”‚
â”‚                                                                         â”‚
â”‚    + GetGPUComputeCode(...) : bool                                     â”‚
â”‚      // GPU ì‹œë®¬ë ˆì´ì…˜ìš© HLSL ì½”ë“œ ìƒì„±                                 â”‚
â”‚      // Compute Shaderì— í¬í•¨ë  ì½”ë“œ                                    â”‚
â”‚                                                                         â”‚
â”‚    + Equals(const UNiagaraDataInterface*) : bool                       â”‚
â”‚      // DI ë¹„êµ (ë™ì¼í•œ ì„¤ì •ì¸ì§€ í™•ì¸)                                  â”‚
â”‚                                                                         â”‚
â”‚    + CopyTo(UNiagaraDataInterface*) : bool                             â”‚
â”‚      // DI ë³µì‚¬ (íŒŒë¼ë¯¸í„° ì˜¤ë²„ë¼ì´ë“œ ì‹œ ì‚¬ìš©)                            â”‚
â”‚                                                                         â”‚
â”‚    + InitPerInstanceData(...) : bool                                   â”‚
â”‚      // ì¸ìŠ¤í„´ìŠ¤ë³„ ë°ì´í„° ì´ˆê¸°í™”                                         â”‚
â”‚                                                                         â”‚
â”‚    + DestroyPerInstanceData(...) : void                                â”‚
â”‚      // ì¸ìŠ¤í„´ìŠ¤ë³„ ë°ì´í„° ì •ë¦¬                                           â”‚
â”‚                                                                         â”‚
â”‚    + PerInstanceTick(...) : bool                                       â”‚
â”‚      // ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸ (í•„ìš” ì‹œ)                                     â”‚
â”‚                                                                         â”‚
â”‚  Render Thread (GPU):                                                   â”‚
â”‚    + GetProxyAs<T>() : T*                                              â”‚
â”‚      // Render Threadìš© Proxy ê°ì²´ ë°˜í™˜                                 â”‚
â”‚                                                                         â”‚
â”‚  Editor Only:                                                           â”‚
â”‚    + GetFeedback(...) : void                                           â”‚
â”‚      // ì—ë””í„°ì—ì„œ ì˜¤ë¥˜/ê²½ê³  í‘œì‹œ                                        â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ“‚ ì†ŒìŠ¤ ê²€ì¦:**
- `NiagaraDataInterface.h:1-300` - ê¸°ë³¸ í´ë˜ìŠ¤ ë° ë°”ì¸ë”© ì‹œìŠ¤í…œ

### FNiagaraFunctionSignature êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FNiagaraFunctionSignature                            â”‚
â”‚  (DataInterface í•¨ìˆ˜ì˜ ì‹œê·¸ë‹ˆì²˜ ì •ì˜)                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ì—­í• : í•¨ìˆ˜ ì´ë¦„, ì…ë ¥, ì¶œë ¥ íƒ€ì… ì •ì˜                                    â”‚
â”‚                                                                         â”‚
â”‚  êµ¬ì¡°:                                                                   â”‚
â”‚    - Name : FName                                                      â”‚
â”‚      // í•¨ìˆ˜ ì´ë¦„ (ì˜ˆ: "SampleTexture")                                 â”‚
â”‚                                                                         â”‚
â”‚    - Inputs : TArray<FNiagaraVariable>                                 â”‚
â”‚      // ì…ë ¥ íŒŒë¼ë¯¸í„° ëª©ë¡                                               â”‚
â”‚      // ì˜ˆ: [UV (Vector2), MipLevel (Float)]                           â”‚
â”‚                                                                         â”‚
â”‚    - Outputs : TArray<FNiagaraVariable>                                â”‚
â”‚      // ì¶œë ¥ íŒŒë¼ë¯¸í„° ëª©ë¡                                               â”‚
â”‚      // ì˜ˆ: [Color (Vector4)]                                          â”‚
â”‚                                                                         â”‚
â”‚    - FunctionSpecifiers : TMap<FName, FName>                           â”‚
â”‚      // í•¨ìˆ˜ ì†ì„± (GPU ì§€ì› ì—¬ë¶€ ë“±)                                     â”‚
â”‚                                                                         â”‚
â”‚    - Description : FText                                               â”‚
â”‚      // í•¨ìˆ˜ ì„¤ëª… (ì—ë””í„° íˆ´íŒ)                                          â”‚
â”‚                                                                         â”‚
â”‚  ì˜ˆì‹œ:                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  Function: "Sample Texture 2D"                           â”‚          â”‚
â”‚  â”‚  â”œâ”€ Inputs:                                              â”‚          â”‚
â”‚  â”‚  â”‚   â”œâ”€ Texture (Texture2D)                             â”‚          â”‚
â”‚  â”‚  â”‚   â”œâ”€ UV (Vector2)                                    â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ MipLevel (Float)                                â”‚          â”‚
â”‚  â”‚  â”œâ”€ Outputs:                                             â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ Color (Vector4)                                 â”‚          â”‚
â”‚  â”‚  â””â”€ Specifiers:                                          â”‚          â”‚
â”‚  â”‚      â””â”€ SupportedGPU = true                             â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### CPU vs GPU ì‹¤í–‰ ê²½ë¡œ

```
DataInterface ì‹¤í–‰ íë¦„:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                         â”‚
â”‚  [CPU ì‹œë®¬ë ˆì´ì…˜ ê²½ë¡œ]                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  1. ParticleUpdateScript ì‹¤í–‰                            â”‚          â”‚
â”‚  â”‚     â””â”€ "Sample Texture" ë…¸ë“œ í˜¸ì¶œ                        â”‚          â”‚
â”‚  â”‚         â””â”€ VectorVM::Exec()                             â”‚          â”‚
â”‚  â”‚             â””â”€ FVMExternalFunction í˜¸ì¶œ                 â”‚          â”‚
â”‚  â”‚                 â””â”€ GetVMExternalFunction()ì—ì„œ ë°˜í™˜ëœ í•¨ìˆ˜â”‚         â”‚
â”‚  â”‚                     â””â”€ C++ êµ¬í˜„ ì‹¤í–‰                     â”‚          â”‚
â”‚  â”‚                         â””â”€ Texture->Sample(UV, MipLevel)â”‚          â”‚
â”‚  â”‚                             â””â”€ ê²°ê³¼ ë°˜í™˜ â†’ íŒŒí‹°í´ ì†ì„±   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  [GPU ì‹œë®¬ë ˆì´ì…˜ ê²½ë¡œ]                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  1. ì»´íŒŒì¼ ì‹œ:                                            â”‚          â”‚
â”‚  â”‚     â””â”€ GetGPUComputeCode() í˜¸ì¶œ                          â”‚          â”‚
â”‚  â”‚         â””â”€ HLSL ì½”ë“œ ìƒì„±:                               â”‚          â”‚
â”‚  â”‚             "float4 SampleTexture2D(                     â”‚          â”‚
â”‚  â”‚                Texture2D Tex,                            â”‚          â”‚
â”‚  â”‚                SamplerState Sampler,                     â”‚          â”‚
â”‚  â”‚                float2 UV,                                â”‚          â”‚
â”‚  â”‚                float MipLevel) {                         â”‚          â”‚
â”‚  â”‚                return Tex.SampleLevel(Sampler, UV, MipLevel);â”‚      â”‚
â”‚  â”‚              }"                                          â”‚          â”‚
â”‚  â”‚         â””â”€ Compute Shaderì— í¬í•¨                         â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  2. ëŸ°íƒ€ì„:                                               â”‚          â”‚
â”‚  â”‚     â””â”€ Compute Shader ì‹¤í–‰ (GPU)                         â”‚          â”‚
â”‚  â”‚         â””â”€ SampleTexture2D(...) í˜¸ì¶œ                     â”‚          â”‚
â”‚  â”‚             â””â”€ GPU Texture Sampler ì§ì ‘ ì ‘ê·¼             â”‚          â”‚
â”‚  â”‚                 â””â”€ ì´ˆê³ ì† ë³‘ë ¬ ì²˜ë¦¬                       â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§± DataInterface ì¹´í…Œê³ ë¦¬ (Categories)

### 1. Texture ê´€ë ¨ (7ê°œ)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Texture Sampling DataInterfaces                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceTexture                                           â”‚
â”‚  â”œâ”€ ì—­í• : 2D Texture ìƒ˜í”Œë§                                             â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â”œâ”€ SampleTexture2D(UV, MipLevel) â†’ Color                          â”‚
â”‚  â”‚   â””â”€ GetTextureDimensions() â†’ (Width, Height)                       â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ìƒ‰ìƒ ë§µ, ë…¸ë©€ ë§µ, Height Map                               â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterface2DArrayTexture                                    â”‚
â”‚  â”œâ”€ ì—­í• : 2D Texture Array ìƒ˜í”Œë§                                       â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ë‹¤ìˆ˜ì˜ Textureë¥¼ Indexë¡œ ì„ íƒ                              â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceCubeTexture                                       â”‚
â”‚  â”œâ”€ ì—­í• : Cube Map ìƒ˜í”Œë§                                               â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: Environment Map, Reflection                                â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceVolumeTexture                                     â”‚
â”‚  â”œâ”€ ì—­í• : 3D Volume Texture ìƒ˜í”Œë§                                      â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: 3D Noise, Volumetric Data                                 â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceSparseVolumeTexture                               â”‚
â”‚  â”œâ”€ ì—­í• : Sparse Volume Texture (UE5.3+)                               â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: OpenVDB, ëŒ€ê·œëª¨ Volume Data                                â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceVirtualTextureSample                              â”‚
â”‚  â”œâ”€ ì—­í• : Virtual Texture ìƒ˜í”Œë§                                        â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ê±°ëŒ€í•œ Texture, ìŠ¤íŠ¸ë¦¬ë°                                   â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceVolumeCache                                       â”‚
â”‚  â”œâ”€ ì—­í• : Volume Cache (Alembic, OpenVDB)                              â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âš ï¸ Partial                                               â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ì‹œë®¬ë ˆì´ì…˜ ìºì‹œ ì¬ìƒ                                       â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. Mesh ê´€ë ¨ (5ê°œ)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Mesh Sampling DataInterfaces                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceSkeletalMesh                                      â”‚
â”‚  â”œâ”€ ì—­í• : SkeletalMesh ìƒ˜í”Œë§ (ê°€ì¥ ë§ì´ ì‚¬ìš©ë¨!)                       â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âš ï¸ Partial (ì¼ë¶€ ê¸°ëŠ¥ë§Œ)                                 â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â”œâ”€ GetSkinnedVertexPosition(VertexID) â†’ Position                  â”‚
â”‚  â”‚   â”œâ”€ GetSkinnedTrianglePosition(TriangleID, BaryCoord) â†’ Position   â”‚
â”‚  â”‚   â”œâ”€ GetSocketTransform(SocketName) â†’ Transform                     â”‚
â”‚  â”‚   â”œâ”€ GetBoneTransform(BoneName) â†’ Transform                         â”‚
â”‚  â”‚   â”œâ”€ RandomTriCoord() â†’ (TriangleID, BaryCoord)                     â”‚
â”‚  â”‚   â””â”€ GetVertexColor(VertexID) â†’ Color                               â”‚
â”‚  â”œâ”€ ê¸°ëŠ¥:                                                                â”‚
â”‚  â”‚   â”œâ”€ Whole Mesh Sampling                                            â”‚
â”‚  â”‚   â”œâ”€ Region Sampling (Filtered Bones/Sockets)                       â”‚
â”‚  â”‚   â”œâ”€ Vertex Color ìƒ˜í”Œë§                                             â”‚
â”‚  â”‚   â””â”€ UV ìƒ˜í”Œë§                                                        â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ìºë¦­í„°ì—ì„œ íŒŒí‹°í´ ìŠ¤í°, ë³¸ ì¶”ì , Ragdoll ì´í™íŠ¸             â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceStaticMesh (MeshCommon ê¸°ë°˜)                      â”‚
â”‚  â”œâ”€ ì—­í• : StaticMesh ìƒ˜í”Œë§                                             â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â”œâ”€ GetTrianglePosition(TriangleID, BaryCoord) â†’ Position          â”‚
â”‚  â”‚   â”œâ”€ GetVertexPosition(VertexID) â†’ Position                         â”‚
â”‚  â”‚   â”œâ”€ RandomTriCoord() â†’ (TriangleID, BaryCoord)                     â”‚
â”‚  â”‚   â””â”€ GetSectionTriangleCount(SectionID) â†’ Count                     â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ì •ì  ë©”ì‹œ í‘œë©´ì— íŒŒí‹°í´ ë°°ì¹˜                               â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceMeshRendererInfo                                  â”‚
â”‚  â”œâ”€ ì—­í• : Mesh Renderer ì •ë³´ ì½ê¸°                                       â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: íŒŒí‹°í´ì˜ Mesh Transform ì •ë³´ ì½ê¸°                          â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceSpriteRendererInfo                                â”‚
â”‚  â”œâ”€ ì—­í• : Sprite Renderer ì •ë³´ ì½ê¸°                                     â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: íŒŒí‹°í´ì˜ Sprite ì •ë³´ ì½ê¸°                                  â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceSpline                                            â”‚
â”‚  â”œâ”€ ì—­í• : Spline Component ìƒ˜í”Œë§                                       â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â”œâ”€ GetSplinePositionAtDistanceAlongSpline(Distance) â†’ Position    â”‚
â”‚  â”‚   â”œâ”€ GetSplineDirectionAtDistanceAlongSpline(Distance) â†’ Direction  â”‚
â”‚  â”‚   â””â”€ GetSplineLength() â†’ Length                                     â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ê²½ë¡œ ë”°ë¼ íŒŒí‹°í´ ë°°ì¹˜, ì¼€ì´ë¸” ì´í™íŠ¸                       â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. Collision & Scene Query (4ê°œ)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Collision & Scene Query DataInterfaces                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceCollisionQuery                                    â”‚
â”‚  â”œâ”€ ì—­í• : Physics Collision ì¿¼ë¦¬ (ê°€ì¥ ê°•ë ¥!)                           â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âŒ No (CPU ì „ìš©)                                          â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â”œâ”€ PerformCollisionQueryLine(Start, End) â†’ (Hit, Location, Normal)â”‚
â”‚  â”‚   â”œâ”€ PerformCollisionQuerySweep(Start, End, Size) â†’ (Hit, ...)      â”‚
â”‚  â”‚   â””â”€ PerformOverlapQuery(Position, Size) â†’ IsOverlapping            â”‚
â”‚  â”œâ”€ ê¸°ëŠ¥:                                                                â”‚
â”‚  â”‚   â”œâ”€ Line Trace                                                     â”‚
â”‚  â”‚   â”œâ”€ Sphere/Box/Capsule Sweep                                       â”‚
â”‚  â”‚   â”œâ”€ Overlap Test                                                   â”‚
â”‚  â”‚   â””â”€ Collision Channel í•„í„°ë§                                        â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: íŒŒí‹°í´ ì¶©ëŒ, ë°”ìš´ìŠ¤, í‘œë©´ ì •ë ¬                             â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceAsyncGpuTrace                                     â”‚
â”‚  â”œâ”€ ì—­í• : GPU Ray Tracing (ë¹„ë™ê¸°)                                      â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes (GPU ì „ìš©)                                         â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â”œâ”€ IssueAsyncRayTrace(Origin, Direction, MaxDistance)             â”‚
â”‚  â”‚   â””â”€ ReadAsyncRayTraceResult() â†’ (Hit, Location, Normal)            â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: GPU íŒŒí‹°í´ ì¶©ëŒ (HWRT ì‚¬ìš©)                                â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceOcclusion                                         â”‚
â”‚  â”œâ”€ ì—­í• : Occlusion Query (ê°€ì‹œì„± ì²´í¬)                                 â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â”œâ”€ GetCameraOcclusionRectangle(Position, Size) â†’ Visibility       â”‚
â”‚  â”‚   â””â”€ QueryOcclusionFactor(Position) â†’ OcclusionFactor               â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: íŒŒí‹°í´ LOD, ê°€ë ¤ì§„ íŒŒí‹°í´ ì œê±°                             â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceLandscape                                         â”‚
â”‚  â”œâ”€ ì—­í• : Landscape Height Query                                       â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âš ï¸ Partial                                               â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â”œâ”€ GetLandscapeHeight(WorldPosition) â†’ Height                     â”‚
â”‚  â”‚   â””â”€ GetLandscapeNormal(WorldPosition) â†’ Normal                     â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ì§€í˜• ìœ„ì— íŒŒí‹°í´ ë°°ì¹˜, ë°œìêµ­                              â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4. Curve & DataTable (5ê°œ)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Curve & Lookup Table DataInterfaces                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceCurve (Float Curve)                               â”‚
â”‚  â”œâ”€ ì—­í• : Float Curve ìƒ˜í”Œë§                                            â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â””â”€ SampleCurve(Time) â†’ Value                                      â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: Size Over Life, Alpha Over Life                            â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceVector2DCurve                                     â”‚
â”‚  â”œâ”€ ì—­í• : Vector2 Curve ìƒ˜í”Œë§                                          â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: UV Animation                                               â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceVectorCurve (Vector3)                             â”‚
â”‚  â”œâ”€ ì—­í• : Vector3 Curve ìƒ˜í”Œë§                                          â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: Position/Velocity Over Life                                â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceVector4Curve                                      â”‚
â”‚  â”œâ”€ ì—­í• : Vector4 Curve ìƒ˜í”Œë§                                          â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: Custom Data Animation                                      â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceColorCurve                                        â”‚
â”‚  â”œâ”€ ì—­í• : LinearColor Curve ìƒ˜í”Œë§                                      â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: Color Over Life                                            â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5. Audio (4ê°œ)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Audio DataInterfaces                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceAudioSpectrum                                     â”‚
â”‚  â”œâ”€ ì—­í• : ì˜¤ë””ì˜¤ Spectrum ë¶„ì„ (FFT)                                    â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âŒ No (CPU ì „ìš©)                                          â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â”œâ”€ GetAudioSpectrum(Frequency) â†’ Magnitude                        â”‚
â”‚  â”‚   â””â”€ GetAverageAudioSpectrum(MinFreq, MaxFreq) â†’ AvgMagnitude       â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ìŒì•… ë¹„ì£¼ì–¼ë¼ì´ì €, ì˜¤ë””ì˜¤ ë°˜ì‘ ì´í™íŠ¸                      â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceAudioOscilloscope                                 â”‚
â”‚  â”œâ”€ ì—­í• : ì˜¤ë””ì˜¤ íŒŒí˜• (Waveform)                                        â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âŒ No (CPU ì „ìš©)                                          â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â””â”€ GetAudioOscilloscopeSample(Index) â†’ Amplitude                  â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: íŒŒí˜• ì‹œê°í™”                                                 â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceAudioPlayer                                       â”‚
â”‚  â”œâ”€ ì—­í• : íŒŒí‹°í´ì—ì„œ ì˜¤ë””ì˜¤ ì¬ìƒ                                         â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âŒ No (CPU ì „ìš©)                                          â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â”œâ”€ PlayAudio(Position, Volume, Pitch)                             â”‚
â”‚  â”‚   â””â”€ StopAudio()                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: íŒŒí‹°í´ ì¶©ëŒ ì‹œ ì‚¬ìš´ë“œ                                       â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceAudio (ê¸°ë³¸ í´ë˜ìŠ¤)                                â”‚
â”‚  â””â”€ ì˜¤ë””ì˜¤ ê´€ë ¨ ê³µí†µ ê¸°ëŠ¥                                                â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6. Grid ì‹œìŠ¤í…œ (7ê°œ)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Grid DataInterfaces (íŒŒí‹°í´ ê°„ ë°ì´í„° ê³µìœ )                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceGrid2DCollection                                  â”‚
â”‚  â”œâ”€ ì—­í• : 2D Grid (Read/Write)                                          â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â”œâ”€ SetFloatValue(X, Y, Value)                                     â”‚
â”‚  â”‚   â”œâ”€ GetFloatValue(X, Y) â†’ Value                                    â”‚
â”‚  â”‚   â””â”€ GetGridDimensions() â†’ (Width, Height)                          â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: Height Map, Fluid Simulation, Cellular Automata            â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceGrid2DCollectionReader                            â”‚
â”‚  â”œâ”€ ì—­í• : ë‹¤ë¥¸ Emitterì˜ 2D Grid ì½ê¸°                                   â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ì—ë¯¸í„° ê°„ ë°ì´í„° ê³µìœ                                        â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceGrid3DCollection                                  â”‚
â”‚  â”œâ”€ ì—­í• : 3D Grid (Read/Write)                                          â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: Volumetric Simulation, 3D Fluid                            â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceGrid3DCollectionReader                            â”‚
â”‚  â”œâ”€ ì—­í• : ë‹¤ë¥¸ Emitterì˜ 3D Grid ì½ê¸°                                   â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ì—ë¯¸í„° ê°„ 3D ë°ì´í„° ê³µìœ                                     â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceNeighborGrid3D                                    â”‚
â”‚  â”œâ”€ ì—­í• : 3D Grid + ì´ì›ƒ ê²€ìƒ‰                                           â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â”œâ”€ GetNeighborCount(X, Y, Z) â†’ Count                              â”‚
â”‚  â”‚   â””â”€ ForEachNeighbor(X, Y, Z, Callback)                             â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: SPH Fluid, Particle Neighbor Queries                       â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceRasterizationGrid3D                               â”‚
â”‚  â”œâ”€ ì—­í• : íŒŒí‹°í´ì„ 3D Gridë¡œ Rasterize                                  â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: Particle Density Field                                     â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceParticleRead                                      â”‚
â”‚  â”œâ”€ ì—­í• : ë‹¤ë¥¸ Emitterì˜ íŒŒí‹°í´ ë°ì´í„° ì§ì ‘ ì½ê¸°                         â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âš ï¸ Partial                                               â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ì—ë¯¸í„° ê°„ íŒŒí‹°í´ ë°ì´í„° ê³µìœ                                 â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 7. RenderTarget ì¶œë ¥ (5ê°œ)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  RenderTarget DataInterfaces (íŒŒí‹°í´ â†’ Texture ì¶œë ¥)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceRenderTarget2D                                    â”‚
â”‚  â”œâ”€ ì—­í• : 2D RenderTargetì— ì“°ê¸°                                        â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes (GPU ì „ìš©)                                         â”‚
â”‚  â”œâ”€ ì£¼ìš” í•¨ìˆ˜:                                                           â”‚
â”‚  â”‚   â”œâ”€ SetRenderTargetValue(X, Y, Color)                              â”‚
â”‚  â”‚   â”œâ”€ GetRenderTargetSize() â†’ (Width, Height)                        â”‚
â”‚  â”‚   â””â”€ LinearToIndex(X, Y) â†’ Index                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: íŒŒí‹°í´ â†’ Texture, ë™ì  Decal, UI ì´í™íŠ¸                    â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceRenderTarget2DArray                               â”‚
â”‚  â”œâ”€ ì—­í• : 2D RenderTarget Arrayì— ì“°ê¸°                                  â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes (GPU ì „ìš©)                                         â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ë‹¤ìˆ˜ ë ˆì´ì–´ ì¶œë ¥                                            â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceRenderTargetCube                                  â”‚
â”‚  â”œâ”€ ì—­í• : Cube RenderTargetì— ì“°ê¸°                                      â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes (GPU ì „ìš©)                                         â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: Environment Map ìƒì„±                                       â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceRenderTargetVolume                                â”‚
â”‚  â”œâ”€ ì—­í• : Volume RenderTargetì— ì“°ê¸°                                    â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes (GPU ì „ìš©)                                         â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: Volumetric ë°ì´í„° ìƒì„±                                      â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceIntRenderTarget2D                                 â”‚
â”‚  â”œâ”€ ì—­í• : Integer RenderTarget (R32_UINT)                              â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes (GPU ì „ìš©)                                         â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ID Map, Counter Texture                                    â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 8. ê¸°íƒ€ ìœ í‹¸ë¦¬í‹° (13ê°œ)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Utility DataInterfaces                                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceCamera                                            â”‚
â”‚  â”œâ”€ ì—­í• : ì¹´ë©”ë¼ ì •ë³´ (ìœ„ì¹˜, ë°©í–¥, FOV ë“±)                              â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: Billboard, Camera-Facing íŒŒí‹°í´                            â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceCurlNoise                                         â”‚
â”‚  â”œâ”€ ì—­í• : Curl Noise (Divergence-Free Noise)                           â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: ìì—°ìŠ¤ëŸ¬ìš´ Turbulence, ì†Œìš©ëŒì´                             â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceVectorField                                       â”‚
â”‚  â”œâ”€ ì—­í• : Vector Field ìƒ˜í”Œë§                                           â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: Force Field, Wind                                          â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceArrayFloat                                        â”‚
â”‚  â”œâ”€ ì—­í• : Float Array (Blueprintì—ì„œ ì „ë‹¬)                              â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â”œâ”€ ë³€í˜•: ArrayInt32, ArrayBool, ArrayVector, ArrayColor ë“± (9ê°€ì§€)    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: Blueprint â†’ íŒŒí‹°í´ ë°ì´í„° ì „ë‹¬                              â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfacePlatformSet                                       â”‚
â”‚  â”œâ”€ ì—­í• : í˜„ì¬ í”Œë«í¼ ì •ë³´ ì¿¼ë¦¬                                          â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âœ… Yes                                                    â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: í”Œë«í¼ë³„ ë™ì‘ ë¶„ê¸°                                          â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraDataInterfaceExport                                            â”‚
â”‚  â”œâ”€ ì—­í• : íŒŒí‹°í´ ë°ì´í„°ë¥¼ CPUë¡œ Export                                  â”‚
â”‚  â”œâ”€ GPU ì§€ì›: âš ï¸ Partial                                               â”‚
â”‚  â””â”€ ì‚¬ìš© ì˜ˆ: íŒŒí‹°í´ ìœ„ì¹˜ë¥¼ C++/Blueprintë¡œ ì „ë‹¬                          â”‚
â”‚                                                                         â”‚
â”‚  ê¸°íƒ€: SceneCapture, DataChannel, SimpleCounter ë“±                      â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’¡ ì‹¤ì „ ì˜ˆì‹œ (Practical Examples)

### âœ… ì¢‹ì€ ì˜ˆ: SkeletalMesh ìƒ˜í”Œë§

```cpp
// âœ… SkeletalMeshì—ì„œ íŒŒí‹°í´ ìŠ¤í°
// Niagara ì—ë””í„°ì—ì„œ:
// 1. User Parametersì— SkeletalMeshComponent ì¶”ê°€
// 2. Particle Spawn ì„¹ì…˜ì— "Sample Skeletal Mesh" ëª¨ë“ˆ ì¶”ê°€

// C++/Blueprintì—ì„œ:
UNiagaraComponent* NiagaraComp = ...;
USkeletalMeshComponent* CharacterMesh = Character->GetMesh();

// âœ… SkeletalMesh DataInterface ì„¤ì •
UNiagaraFunctionLibrary::OverrideSystemUserVariableSkeletalMeshComponent(
    NiagaraComp,
    "User.SkeletalMesh",  // íŒŒë¼ë¯¸í„° ì´ë¦„
    CharacterMesh
);

// âœ… íŠ¹ì • ë³¸/ì†Œì¼“ë§Œ ìƒ˜í”Œë§ (Filtering)
UNiagaraDataInterfaceSkeletalMesh* SkeletalMeshDI =
    UNiagaraFunctionLibrary::GetSkeletalMeshDataInterface(
        NiagaraComp,
        "User.SkeletalMesh"
    );

if (SkeletalMeshDI)
{
    // âœ… íŠ¹ì • ë³¸ë§Œ ìƒ˜í”Œë§
    TArray<FName> FilteredBones = {
        FName("spine_01"),
        FName("spine_02"),
        FName("spine_03")
    };
    UNiagaraFunctionLibrary::SetSkeletalMeshDataInterfaceFilteredBones(
        NiagaraComp,
        "User.SkeletalMesh",
        FilteredBones
    );

    // âœ… Sampling Region ì„¤ì •
    TArray<FName> SamplingRegions = { FName("UpperBody") };
    UNiagaraFunctionLibrary::SetSkeletalMeshDataInterfaceSamplingRegions(
        NiagaraComp,
        "User.SkeletalMesh",
        SamplingRegions
    );
}
```

### âœ… ì¢‹ì€ ì˜ˆ: Collision Query

```cpp
// âœ… íŒŒí‹°í´ ì¶©ëŒ ê°ì§€
// Niagara ì—ë””í„°ì—ì„œ:
// Particle Update ì„¹ì…˜
// â””â”€ Collision Query ëª¨ë“ˆ ì¶”ê°€
//     â”œâ”€ Query Type: Line Trace
//     â”œâ”€ Collision Channel: ECC_WorldStatic
//     â””â”€ Response: Bounce

// ë‚´ë¶€ ë™ì‘ (ParticleUpdateScript):
/*
// Collision Query DataInterface ì‚¬ìš©
bool bHit;
FVector HitLocation;
FVector HitNormal;

bHit = CollisionQuery.PerformCollisionQueryLine(
    Particles.Position,
    Particles.Position + Particles.Velocity * DeltaTime,
    HitLocation,
    HitNormal
);

if (bHit)
{
    // ì¶©ëŒ ë°˜ì‘
    Particles.Position = HitLocation + HitNormal * 0.1;  // í‘œë©´ì—ì„œ ì•½ê°„ ë„ìš°ê¸°
    Particles.Velocity = reflect(Particles.Velocity, HitNormal) * Bounciness;

    // ì´ë²¤íŠ¸ ìƒì„± (ì¶©ëŒ íŒŒí‹°í´ ìŠ¤í°)
    GenerateCollisionEvent(HitLocation, HitNormal);
}
*/
```

### âœ… ì¢‹ì€ ì˜ˆ: Texture ìƒ˜í”Œë§

```cpp
// âœ… Textureì—ì„œ ìƒ‰ìƒ ê°€ì ¸ì˜¤ê¸°
// Niagara ì—ë””í„°ì—ì„œ:
// User Parameters:
//   â””â”€ User.ColorTexture (Texture2D)

// Particle Spawn:
//   â””â”€ Sample Texture ëª¨ë“ˆ
//       â”œâ”€ Texture: User.ColorTexture
//       â”œâ”€ UV: Particles.UV (ë˜ëŠ” ì»¤ìŠ¤í…€ ê³„ì‚°)
//       â””â”€ Output: Particles.Color

// C++/Blueprintì—ì„œ:
UTexture2D* ColorMap = ...;
UNiagaraFunctionLibrary::SetTextureObject(
    NiagaraComp,
    "User.ColorTexture",
    ColorMap
);

// ê³ ê¸‰: ë™ì  UV ê³„ì‚°
// Particle Spawnì—ì„œ:
/*
// íŒŒí‹°í´ ìƒëª…ì— ë”°ë¼ UV ìŠ¤í¬ë¡¤
float U = Particles.NormalizedAge;
float V = Particles.UniqueID * 0.1;  // íŒŒí‹°í´ë³„ ì˜¤í”„ì…‹
FVector2D UV = FVector2D(U, V);

// Texture ìƒ˜í”Œë§
Particles.Color = SampleTexture2D(User.ColorTexture, UV, 0.0);
*/
```

### âœ… ì¢‹ì€ ì˜ˆ: Array DataInterface (Blueprint ì—°ë™)

```cpp
// âœ… Blueprintì—ì„œ ë°°ì—´ ë°ì´í„° ì „ë‹¬
// Blueprint:
UFUNCTION(BlueprintCallable, Category = "Niagara")
void UpdateParticlePositions(UNiagaraComponent* NiagaraComp)
{
    // âœ… Float ë°°ì—´ ìƒì„±
    TArray<float> Positions;
    for (int32 i = 0; i < 100; ++i)
    {
        Positions.Add(FMath::Sin(i * 0.1f) * 100.0f);
    }

    // âœ… DataInterfaceì— ì „ë‹¬
    UNiagaraDataInterfaceArrayFloat* ArrayDI =
        UNiagaraFunctionLibrary::GetDataInterface<UNiagaraDataInterfaceArrayFloat>(
            NiagaraComp,
            FName("User.PositionArray")
        );

    if (ArrayDI)
    {
        // Blueprint Function Library ì‚¬ìš©
        UNiagaraDataInterfaceArrayFunctionLibrary::SetNiagaraArrayFloat(
            NiagaraComp,
            FName("User.PositionArray"),
            Positions
        );
    }
}

// Niagaraì—ì„œ ì‚¬ìš©:
// Particle Spawn:
/*
int32 Index = Particles.UniqueID % User.PositionArray.Length;
float XPos = User.PositionArray.Get(Index);
Particles.Position.X = XPos;
*/
```

### âœ… ì¢‹ì€ ì˜ˆ: Grid2D (Fluid Simulation)

```cpp
// âœ… 2D Fluid Simulation
// Niagara System:
// Emitter 1: "FluidSimulation" (GPU)
//   â”œâ”€ Grid2DCollection DataInterface
//   â”œâ”€ Grid Size: 512x512
//   â””â”€ Simulation Stage:
//       â””â”€ Fluid Solver (Navier-Stokes)

// Emitter 2: "FluidParticles" (GPU)
//   â”œâ”€ Grid2DCollectionReader DataInterface
//   â””â”€ Particle Update:
//       â””â”€ Sample Grid â†’ Velocity

// Emitter 1 - Fluid Solver (Simulation Stage):
/*
// Grid2DCollectionì— ì†ë„ ì €ì¥
float2 GridUV = ThreadID.xy / GridDimensions;
float2 CurrentVelocity = Grid2D.GetVector2D(ThreadID.xy);

// Advection, Diffusion, Pressure ê³„ì‚°...
float2 NewVelocity = SolveFluid(GridUV, CurrentVelocity, DeltaTime);

// Gridì— ì“°ê¸°
Grid2D.SetVector2D(ThreadID.xy, NewVelocity);
*/

// Emitter 2 - Particles (Particle Update):
/*
// Gridì—ì„œ ì†ë„ ì½ê¸°
int2 GridCoord = WorldPositionToGridCoord(Particles.Position);
float2 GridVelocity = Grid2DReader.GetVector2D(GridCoord);

// íŒŒí‹°í´ì— ì ìš©
Particles.Velocity += GridVelocity * DeltaTime * Strength;
Particles.Position += Particles.Velocity * DeltaTime;
*/
```

### âœ… ì¢‹ì€ ì˜ˆ: RenderTarget ì¶œë ¥

```cpp
// âœ… íŒŒí‹°í´ì„ RenderTargetì— ê·¸ë¦¬ê¸°
// Niagara Emitter (GPU):
//   â””â”€ RenderTarget2D DataInterface

// Particle Update:
/*
// íŒŒí‹°í´ ìœ„ì¹˜ë¥¼ UVë¡œ ë³€í™˜
float2 UV = WorldPositionToUV(Particles.Position);
int2 PixelCoord = UV * RenderTargetSize;

// RenderTargetì— ìƒ‰ìƒ ì“°ê¸°
RenderTarget2D.SetRenderTargetValue(
    PixelCoord.x,
    PixelCoord.y,
    Particles.Color
);
*/

// C++ì—ì„œ RenderTarget ì½ê¸°:
UTextureRenderTarget2D* RenderTarget = ...;
FTextureRenderTargetResource* RTResource = RenderTarget->GameThread_GetRenderTargetResource();

// GPU â†’ CPU ì½ê¸° (ë¹„ë™ê¸°)
TArray<FColor> Pixels;
RTResource->ReadPixels(Pixels);

// ì‚¬ìš© ì˜ˆ: íŒŒí‹°í´ ë°€ë„ ë§µ, ë™ì  Height Map
```

### âŒ ë‚˜ìœ ì˜ˆ: GPU ì—ë¯¸í„°ì—ì„œ CPU ì „ìš© DI ì‚¬ìš©

```cpp
// âŒ ì˜ëª»ëœ ë°©ë²•: GPU ì‹œë®¬ë ˆì´ì…˜ + CollisionQuery
// Emitter:
//   Sim Target: GPU Compute Sim  â† GPU ëª¨ë“œ
//   Particle Update:
//     â””â”€ Collision Query  â† CPU ì „ìš©!

// ëŸ°íƒ€ì„ ì—ëŸ¬:
// "DataInterface CollisionQuery is not supported on GPU simulation"
```

**ì˜¬ë°”ë¥¸ ë°©ë²•:**

```cpp
// âœ… ì˜¬ë°”ë¥¸ ë°©ë²• 1: CPU ì‹œë®¬ë ˆì´ì…˜ ì‚¬ìš©
// Emitter:
//   Sim Target: CPU Sim  â† CPUë¡œ ë³€ê²½
//   Particle Update:
//     â””â”€ Collision Query  â† ì‘ë™í•¨

// âœ… ì˜¬ë°”ë¥¸ ë°©ë²• 2: GPU ì§€ì› ëŒ€ì²´ ì‚¬ìš©
// Emitter:
//   Sim Target: GPU Compute Sim
//   Particle Update:
//     â””â”€ Async GPU Trace  â† GPU ì§€ì› Collision
//         (ë˜ëŠ” Scene Depth Collision)
```

---

## ğŸ”§ ì»¤ìŠ¤í…€ DataInterface ì œì‘ (Custom DataInterface)

### ê¸°ë³¸ êµ¬ì¡°

```cpp
// âœ… ì»¤ìŠ¤í…€ DataInterface ì˜ˆì‹œ: Random Number Generator
UCLASS(EditInlineNew, Category = "DataInterface")
class UMyNiagaraDataInterfaceRandom : public UNiagaraDataInterface
{
    GENERATED_BODY()

public:
    // âœ… 1. ì œê³µí•  í•¨ìˆ˜ ì •ì˜
    virtual void GetFunctions(TArray<FNiagaraFunctionSignature>& OutFunctions) override
    {
        FNiagaraFunctionSignature Sig;
        Sig.Name = FName("GetRandomFloat");
        Sig.Inputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetIntDef(), TEXT("Seed")));
        Sig.Outputs.Add(FNiagaraVariable(FNiagaraTypeDefinition::GetFloatDef(), TEXT("Value")));
        Sig.bSupportsGPU = true;
        Sig.bMemberFunction = true;
        OutFunctions.Add(Sig);
    }

    // âœ… 2. CPU êµ¬í˜„
    virtual void GetVMExternalFunction(
        const FVMExternalFunctionBindingInfo& BindingInfo,
        void* InstanceData,
        FVMExternalFunction& OutFunc) override
    {
        if (BindingInfo.Name == FName("GetRandomFloat"))
        {
            OutFunc = FVMExternalFunction::CreateLambda(
                [](FVectorVMExternalFunctionContext& Context)
                {
                    VectorVM::FExternalFuncInputHandler<int32> SeedParam(Context);
                    VectorVM::FExternalFuncRegisterHandler<float> OutValue(Context);

                    for (int32 i = 0; i < Context.GetNumInstances(); ++i)
                    {
                        int32 Seed = SeedParam.GetAndAdvance();
                        FRandomStream RandomStream(Seed);
                        *OutValue.GetDestAndAdvance() = RandomStream.FRand();
                    }
                });
        }
    }

    // âœ… 3. GPU êµ¬í˜„ (HLSL ìƒì„±)
    virtual bool GetFunctionHLSL(
        const FNiagaraDataInterfaceGPUParamInfo& ParamInfo,
        const FNiagaraDataInterfaceGeneratedFunction& FunctionInfo,
        int FunctionInstanceIndex,
        FString& OutHLSL) override
    {
        if (FunctionInfo.DefinitionName == FName("GetRandomFloat"))
        {
            OutHLSL += TEXT("void GetRandomFloat(int Seed, out float Value)\n");
            OutHLSL += TEXT("{\n");
            OutHLSL += TEXT("    // Wang Hash ì•Œê³ ë¦¬ì¦˜\n");
            OutHLSL += TEXT("    uint Hash = Seed;\n");
            OutHLSL += TEXT("    Hash = (Hash ^ 61) ^ (Hash >> 16);\n");
            OutHLSL += TEXT("    Hash = Hash + (Hash << 3);\n");
            OutHLSL += TEXT("    Hash = Hash ^ (Hash >> 4);\n");
            OutHLSL += TEXT("    Hash = Hash * 0x27d4eb2d;\n");
            OutHLSL += TEXT("    Hash = Hash ^ (Hash >> 15);\n");
            OutHLSL += TEXT("    Value = float(Hash) / 4294967296.0;\n");
            OutHLSL += TEXT("}\n");
            return true;
        }
        return false;
    }

    // âœ… 4. ë™ë“±ì„± ì²´í¬
    virtual bool Equals(const UNiagaraDataInterface* Other) const override
    {
        return Cast<UMyNiagaraDataInterfaceRandom>(Other) != nullptr;
    }

    // âœ… 5. ë³µì‚¬
    virtual bool CopyTo(UNiagaraDataInterface* Destination) const override
    {
        UMyNiagaraDataInterfaceRandom* DestRandom = Cast<UMyNiagaraDataInterfaceRandom>(Destination);
        return DestRandom != nullptr;
    }
};
```

### ê³ ê¸‰: Per-Instance Data

```cpp
// âœ… ì¸ìŠ¤í„´ìŠ¤ë³„ ë°ì´í„°ê°€ í•„ìš”í•œ ê²½ìš°
struct FMyDIInstanceData
{
    FRandomStream RandomStream;
    TArray<float> CachedValues;
};

class UMyAdvancedDataInterface : public UNiagaraDataInterface
{
    // âœ… ì¸ìŠ¤í„´ìŠ¤ ë°ì´í„° í¬ê¸° ë°˜í™˜
    virtual int32 PerInstanceDataSize() const override
    {
        return sizeof(FMyDIInstanceData);
    }

    // âœ… ì´ˆê¸°í™”
    virtual bool InitPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance) override
    {
        FMyDIInstanceData* InstData = new (PerInstanceData) FMyDIInstanceData();
        InstData->RandomStream.Initialize(FMath::Rand());
        InstData->CachedValues.Reserve(1000);
        return true;
    }

    // âœ… ì •ë¦¬
    virtual void DestroyPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance) override
    {
        FMyDIInstanceData* InstData = (FMyDIInstanceData*)PerInstanceData;
        InstData->~FMyDIInstanceData();
    }

    // âœ… ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸ (í•„ìš” ì‹œ)
    virtual bool PerInstanceTick(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance, float DeltaSeconds) override
    {
        FMyDIInstanceData* InstData = (FMyDIInstanceData*)PerInstanceData;
        // ë§¤ í”„ë ˆì„ ì²˜ë¦¬...
        return false;  // true ë°˜í™˜ ì‹œ Instance ë¦¬ì…‹
    }
};
```

---

## ğŸ“Š ì„±ëŠ¥ ìµœì í™” (Performance Optimization)

### CPU vs GPU ì§€ì› ì—¬ë¶€

```
DataInterface GPU ì§€ì› ìš”ì•½:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âœ… GPU ì™„ì „ ì§€ì›:                                                       â”‚
â”‚  - Texture (ëª¨ë“  íƒ€ì…)                                                   â”‚
â”‚  - StaticMesh                                                           â”‚
â”‚  - Curve (ëª¨ë“  íƒ€ì…)                                                     â”‚
â”‚  - Grid2D/3D Collection                                                 â”‚
â”‚  - RenderTarget (ëª¨ë“  íƒ€ì…)                                              â”‚
â”‚  - Camera                                                               â”‚
â”‚  - CurlNoise, VectorField                                               â”‚
â”‚  - Array (ëª¨ë“  íƒ€ì…)                                                     â”‚
â”‚  - Spline                                                               â”‚
â”‚                                                                         â”‚
â”‚  âš ï¸ GPU ë¶€ë¶„ ì§€ì›:                                                      â”‚
â”‚  - SkeletalMesh (ì¼ë¶€ ê¸°ëŠ¥ë§Œ)                                            â”‚
â”‚  - AsyncGpuTrace (ë¹„ë™ê¸°)                                                â”‚
â”‚  - Landscape                                                            â”‚
â”‚  - VolumeCache                                                          â”‚
â”‚                                                                         â”‚
â”‚  âŒ CPU ì „ìš©:                                                            â”‚
â”‚  - CollisionQuery (Physics)                                             â”‚
â”‚  - Audio (ëª¨ë“  íƒ€ì…)                                                     â”‚
â”‚  - Export                                                               â”‚
â”‚  - AudioPlayer                                                          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ìµœì í™” íŒ

**1. DataInterface ì¬ì‚¬ìš©:**

```cpp
// âœ… ë™ì¼í•œ DIë¥¼ ì—¬ëŸ¬ ì—ë¯¸í„°ì—ì„œ ê³µìœ 
// System ë ˆë²¨ User Parameterë¡œ ì„¤ì •
// â†’ ë©”ëª¨ë¦¬ ì ˆì•½, ì¼ê´€ì„± ìœ ì§€

// âŒ ê° ì—ë¯¸í„°ë§ˆë‹¤ ë³„ë„ DI ìƒì„±
// â†’ ë©”ëª¨ë¦¬ ë‚­ë¹„, ë™ê¸°í™” ì–´ë ¤ì›€
```

**2. Grid í•´ìƒë„ ìµœì í™”:**

```cpp
// âœ… ì ì ˆí•œ Grid í¬ê¸° ì„ íƒ
Grid2D: 256x256  // ì¼ë°˜ì ì¸ ê²½ìš°
Grid2D: 512x512  // ê³ í’ˆì§ˆ
Grid3D: 64x64x64  // 3DëŠ” ë©”ëª¨ë¦¬ íë¸Œ ì¦ê°€!

// âŒ ê³¼ë„í•œ í•´ìƒë„
Grid2D: 2048x2048  // 16MB (Float4 ê¸°ì¤€)
Grid3D: 256x256x256  // 256MB! (ë„ˆë¬´ í¼)
```

---

## ğŸ—ï¸ 3ê³„ì¸µ ì•„í‚¤í…ì²˜ ìƒì„¸ (Three-Layer Architecture Detail)

> ğŸ”„ Updated: 2026-02-18 â€” DataInterface_System.mdì—ì„œ í†µí•©

**í•µì‹¬ ì² í•™:**
> **Game Thread**ì—ì„œëŠ” `UNiagaraDataInterface`ê°€ ë°ì´í„°ë¥¼ ê´€ë¦¬í•˜ê³ ,
> **Render Thread**ì—ì„œëŠ” `FNiagaraDataInterfaceProxy`ê°€ GPU ë¦¬ì†ŒìŠ¤ë¥¼ ì²˜ë¦¬í•œë‹¤.
> CPU/GPU ì–‘ìª½ì—ì„œ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆìœ¼ë©°, ê°ê° **VM Function**ê³¼ **HLSL ì½”ë“œ**ë¡œ ë°”ì¸ë”©ëœë‹¤.

### ì „ì²´ êµ¬ì¡°ë„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          Game Thread ê³„ì¸µ                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  UNiagaraDataInterfaceBase (ì¶”ìƒ ë² ì´ìŠ¤)                                 â”‚
â”‚  - BuildShaderParameters()      // GPU íŒŒë¼ë¯¸í„° ì •ì˜                     â”‚
â”‚  - CreateShaderStorage()        // ì…°ì´ë”ë³„ ìŠ¤í† ë¦¬ì§€                     â”‚
â”‚                                                                          â”‚
â”‚          â–²                                                               â”‚
â”‚          â”‚ ìƒì†                                                          â”‚
â”‚          â”‚                                                               â”‚
â”‚  UNiagaraDataInterface (ì£¼ìš” ë² ì´ìŠ¤)                                     â”‚
â”‚  - InitPerInstanceData()        // ì¸ìŠ¤í„´ìŠ¤ ë°ì´í„° ì´ˆê¸°í™”                â”‚
â”‚  - PerInstanceTick()            // Game Thread í‹±                        â”‚
â”‚  - GetVMExternalFunction()      // CPU í•¨ìˆ˜ ë°”ì¸ë”©                       â”‚
â”‚  - ProvidePerInstanceDataForRenderThread() // GTâ†’RT ë°ì´í„° ì „ì†¡          â”‚
â”‚                                                                          â”‚
â”‚          â–²                                                               â”‚
â”‚          â”‚ ìƒì†                                                          â”‚
â”‚          â”‚                                                               â”‚
â”‚  [êµ¬ì²´ì ì¸ DataInterface êµ¬í˜„]                                           â”‚
â”‚  - UNiagaraDataInterfaceStaticMesh                                      â”‚
â”‚  - UNiagaraDataInterfaceGrid3DCollection                                â”‚
â”‚  - UNiagaraDataInterfaceCurve                                           â”‚
â”‚  - UNiagaraDataInterfaceTexture                                         â”‚
â”‚  - ... 50ê°œ ì´ìƒì˜ êµ¬í˜„ì²´                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â”‚ ProvidePerInstanceDataForRenderThread()
                                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          Render Thread ê³„ì¸µ                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  FNiagaraDataInterfaceProxy (RT ë² ì´ìŠ¤)                                 â”‚
â”‚  - ConsumePerInstanceDataFromGameThread() // GT ë°ì´í„° ì†Œë¹„              â”‚
â”‚  - PreStage() / PostStage()     // Sim Stage ì „í›„ ì²˜ë¦¬                  â”‚
â”‚  - ResetData()                  // ì‹œë®¬ë ˆì´ì…˜ ë¦¬ì…‹                       â”‚
â”‚  - PostSimulate()               // ì‹œë®¬ë ˆì´ì…˜ í›„ì²˜ë¦¬                     â”‚
â”‚                                                                          â”‚
â”‚          â–²                                                               â”‚
â”‚          â”‚ ìƒì†                                                          â”‚
â”‚          â”‚                                                               â”‚
â”‚  [êµ¬ì²´ì ì¸ Proxy êµ¬í˜„]                                                   â”‚
â”‚  - FNiagaraDataInterfaceProxyGrid3DCollectionProxy                      â”‚
â”‚  - FNiagaraDataInterfaceProxyStaticMesh                                 â”‚
â”‚  - ... (ê° DIë§ˆë‹¤ ëŒ€ì‘í•˜ëŠ” Proxy)                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â”‚ SetShaderParameters()
                                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          GPU Shader ê³„ì¸µ                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  FNiagaraDataInterfaceParametersCS (ì…°ì´ë” íŒŒë¼ë¯¸í„°)                     â”‚
â”‚  - GPUì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•œ íŒŒë¼ë¯¸í„° ì €ì¥ì†Œ                                   â”‚
â”‚                                                                          â”‚
â”‚  HLSL Functions (ì…°ì´ë” í•¨ìˆ˜)                                            â”‚
â”‚  - GetFunctionHLSL()ë¡œ ìƒì„±ëœ HLSL ì½”ë“œ                                  â”‚
â”‚  - íŒŒí‹°í´ ì…°ì´ë”ì—ì„œ í˜¸ì¶œ ê°€ëŠ¥                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ“‚ ì£¼ìš” íŒŒì¼ ìœ„ì¹˜:**
- Base: `Engine/Plugins/FX/Niagara/Source/NiagaraCore/Public/NiagaraDataInterfaceBase.h`
- Main: `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterface.h`

### ë°ì´í„° íë¦„

```
  ê²Œì„ ë¡œì§                  Niagara System          DataInterface
      â”‚                          â”‚                        â”‚
      â”‚ SetUserParameter()       â”‚                        â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                        â”‚
      â”‚                          â”‚ InitPerInstanceData()  â”‚
      â”‚                          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
      â”‚                          â”‚                        â”‚ PerInstanceData í• ë‹¹
      â”‚                          â”‚                        â”‚ ë¦¬ì†ŒìŠ¤ ì´ˆê¸°í™”
      â”‚                          â”‚                        â”‚
      â”‚                          â”‚ PerInstanceTick()      â”‚
      â”‚                          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚ (ë§¤ í”„ë ˆì„)
      â”‚                          â”‚                        â”‚ ë°ì´í„° ì—…ë°ì´íŠ¸
      â”‚                          â”‚                        â”‚
      â”‚                          â”‚ VM ì‹¤í–‰ (CPU)          â”‚
      â”‚                          â”œâ”€ GetVMExternalFunction()â”€>â”‚
      â”‚                          â”‚                        â”‚ CPU í•¨ìˆ˜ í˜¸ì¶œ
      â”‚                          â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ ê²°ê³¼ ë°˜í™˜
      â”‚                          â”‚                        â”‚
      â”‚                          â”‚ GPU Dispatch           â”‚
      â”‚                          â”œâ”€ ProvidePerInstanceDataForRenderThread()â”€>â”‚
      â”‚                          â”‚                        â”‚
      â”‚                          â”‚                        â”‚ (Render Thread)
      â”‚                          â”‚                        â”‚ Proxy->PreStage()
      â”‚                          â”‚                        â”‚ SetShaderParameters()
      â”‚                          â”‚                        â”‚ [GPU ì‹¤í–‰]
      â”‚                          â”‚                        â”‚ Proxy->PostStage()
      â”‚                          â”‚                        â”‚
      â”‚                          â”‚ DestroyPerInstanceData()â”‚
      â”‚                          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
      â”‚                          â”‚                        â”‚ ë¦¬ì†ŒìŠ¤ í•´ì œ
```

### GPU ì…°ì´ë” íŒŒë¼ë¯¸í„° ì‹œìŠ¤í…œ

**Shader Parameters ì •ì˜ ë°©ë²•:**

```cpp
// ì˜ˆì‹œ: UNiagaraDataInterfaceTexture
BEGIN_SHADER_PARAMETER_STRUCT(FShaderParameters, )
    SHADER_PARAMETER(FIntPoint, TextureSize)
    SHADER_PARAMETER(int32, MipLevels)
    SHADER_PARAMETER_RDG_TEXTURE(Texture2D, Texture)
    SHADER_PARAMETER_SAMPLER(SamplerState, TextureSampler)
END_SHADER_PARAMETER_STRUCT()
```

**ì„¤ì • íë¦„:**

```
BuildShaderParameters()    SetShaderParameters()           GPU Shader
       â”‚                           â”‚                             â”‚
       â”‚ êµ¬ì¡° ì •ì˜                  â”‚ ì‹¤ì œ ê°’ ì„¤ì •                â”‚ ì ‘ê·¼
       â†“                           â†“                             â†“
  [ì»´íŒŒì¼ íƒ€ì„]               [Dispatch ì‹œì ]              [ì‹¤í–‰ ì‹œì ]
    - íƒ€ì… ì§€ì •                - SRV/UAV ë°”ì¸ë”©              - DI_Grid.NumCells
    - ì˜¤í”„ì…‹ ê³„ì‚°              - ìƒìˆ˜ ê°’ ì±„ì›€                - DI_Grid.Grid[idx]
```

**í•µì‹¬ íŒŒë¼ë¯¸í„° íƒ€ì…:**
- `SHADER_PARAMETER`: ê¸°ë³¸ íƒ€ì… (int32, float, FVector ë“±)
- `SHADER_PARAMETER_RDG_TEXTURE`: RenderGraph Texture
- `SHADER_PARAMETER_RDG_BUFFER`: RenderGraph Buffer
- `SHADER_PARAMETER_SRV`: Shader Resource View (ì½ê¸° ì „ìš©)
- `SHADER_PARAMETER_UAV`: Unordered Access View (ì½ê¸°/ì“°ê¸°)
- `SHADER_PARAMETER_SAMPLER`: Texture Sampler

### PerInstanceData ê°œë…

**ì™œ PerInstanceDataê°€ í•„ìš”í•œê°€?**

DataInterfaceëŠ” ì—ì…‹ì— ì €ì¥ë˜ëŠ” CDO (Class Default Object)ë¡œ ì—¬ëŸ¬ NiagaraComponentì—ì„œ ê³µìœ ë©ë‹ˆë‹¤. ê° ì»´í¬ë„ŒíŠ¸ê°€ ë‹¤ë¥¸ ì™¸ë¶€ ë¦¬ì†ŒìŠ¤(ì˜ˆ: ë‹¤ë¥¸ SkeletalMeshComponent)ë¥¼ ì°¸ì¡°í•´ì•¼ í•˜ë¯€ë¡œ, SystemInstanceë§ˆë‹¤ ë³„ë„ì˜ PerInstanceDataë¥¼ í• ë‹¹í•©ë‹ˆë‹¤.

```
UNiagaraDataInterfaceSkeletalMesh (CDO)
â””â”€ ê³µí†µ ì„¤ì •ë§Œ ì €ì¥ (DefaultMesh, FilteredBones ë“±)

FNDISkeletalMesh_InstanceData A
â”œâ”€ SceneComponent: CharacterA->GetMesh()
â”œâ”€ SkinningData: CharacterAì˜ Skinning ìºì‹œ
â””â”€ Transform: CharacterAì˜ ì›”ë“œ ë³€í™˜

FNDISkeletalMesh_InstanceData B
â”œâ”€ SceneComponent: CharacterB->GetMesh()
â”œâ”€ SkinningData: CharacterBì˜ Skinning ìºì‹œ
â””â”€ Transform: CharacterBì˜ ì›”ë“œ ë³€í™˜
```

**í•µì‹¬ íŒ¨í„´:**
- **GT ë²„ì „**: Game Threadì—ì„œ ê´€ë¦¬ (ë©”ì‹œ í¬ì¸í„°, ì„¤ì • ê°’ ë“±)
- **RT ë²„ì „**: Render Threadì—ì„œ ê´€ë¦¬ (RHI ë¦¬ì†ŒìŠ¤, GPU ë²„í¼ ë“±)
- `ProvidePerInstanceDataForRenderThread()`ë¡œ GT â†’ RT ì „ì†¡
- **Placement New ì‚¬ìš©**: UObjectê°€ ì•„ë‹ˆë¯€ë¡œ ì§ì ‘ ë©”ëª¨ë¦¬ ê´€ë¦¬
- **ì—°ì† ë©”ëª¨ë¦¬ í• ë‹¹**: ëª¨ë“  DIì˜ PerInstanceDataë¥¼ í•˜ë‚˜ì˜ TArrayì— ì €ì¥
- **ëª…ì‹œì  ì†Œë©¸ì í˜¸ì¶œ**: `DestroyPerInstanceData()`ì—ì„œ `~InstanceData()` í˜¸ì¶œ í•„ìš”

### DataInterface ê°„ ë°ì´í„° ê³µìœ 

```cpp
// Grid3D Writerì™€ Reader ì—°ê²°
UNiagaraDataInterfaceGrid3DCollection* GridWriter = ...;  // Emitter A
UNiagaraDataInterfaceGrid3DCollectionReader* GridReader = ...;  // Emitter B

// Readerê°€ Writerë¥¼ ì°¸ì¡°
GridReader->SetSource(GridWriter);

// Emitter A (Writer) - Sim Stageì—ì„œ Gridì— Velocity ì“°ê¸°
GridDI.SetValue(x, y, z, 0, VelocityX);

// Emitter B (Reader) - ê°™ì€ Gridì—ì„œ Velocity ì½ê¸°
float VelocityX = GridReaderDI.GetValue(x, y, z, 0);
Particles.Velocity = float3(VelocityX, VelocityY, VelocityZ);
```

---

## ğŸ› ë””ë²„ê¹… ë° íŠ¸ëŸ¬ë¸”ìŠˆíŒ… (Debugging & Troubleshooting)

> ğŸ”„ Updated: 2026-02-18 â€” DataInterface_System.mdì—ì„œ í†µí•©

### ì¼ë°˜ì ì¸ í•¨ì •

**1. Per-Instance Data í¬ê¸° ë¶ˆì¼ì¹˜:**
```cpp
// âŒ í¬ë˜ì‹œ ë°œìƒ!
virtual int32 PerInstanceDataSize() const override { return sizeof(FMyData); }
struct FMyData { int32 Value; float OtherValue; };  // ì¶”ê°€í–ˆì§€ë§Œ PerInstanceDataSize ì•ˆ ë°”ê¿ˆ!
```

**2. VM Functionì—ì„œ Loop ëˆ„ë½:**
```cpp
// âŒ ì²« íŒŒí‹°í´ë§Œ ì„¤ì •ë¨!
void GetValueVM(FVectorVMExternalFunctionContext& Context)
{
    VectorVM::FExternalFuncRegisterHandler<float> OutValue(Context);
    *OutValue.GetDest() = 123.0f;
}

// âœ… ëª¨ë“  íŒŒí‹°í´ ì„¤ì •
void GetValueVM(FVectorVMExternalFunctionContext& Context)
{
    VectorVM::FExternalFuncRegisterHandler<float> OutValue(Context);
    for (int32 i = 0; i < Context.GetNumInstances(); ++i)
    {
        *OutValue.GetDestAndAdvance() = 123.0f;
    }
}
```

**3. HLSL íŒŒë¼ë¯¸í„° ì´ë¦„ ë¶ˆì¼ì¹˜:**
```cpp
BEGIN_SHADER_PARAMETER_STRUCT(FShaderParameters, )
    SHADER_PARAMETER(float, MyValue)
END_SHADER_PARAMETER_STRUCT()

// âŒ ì˜ëª»ëœ ì´ë¦„
OutHLSL += TEXT("OutValue = %s_MyParameter;");  // MyParameter != MyValue

// âœ… ì˜¬ë°”ë¥¸ ì´ë¦„
OutHLSL += TEXT("OutValue = %s_MyValue;");
```

**4. RenderThread ë°ì´í„° ì •ë ¬:**
```cpp
// âŒ ë©”ëª¨ë¦¬ ì†ìƒ!
struct FMyRTData { float Value; };  // 4ë°”ì´íŠ¸ â†’ 16ë°”ì´íŠ¸ ì •ë ¬ ìœ„ë°˜!

// âœ… 16ë°”ì´íŠ¸ ì •ë ¬ ë³´ì¥
virtual int32 PerInstanceDataPassedToRenderThreadSize() const override
{
    return Align(sizeof(FMyRTData), 16);
}
```

### ë””ë²„ê¹… íŒ

```cpp
// VM í•¨ìˆ˜ ë””ë²„ê¹…
void MyDataInterface::DebugVM(FVectorVMExternalFunctionContext& Context)
{
    UE_LOG(LogNiagara, Warning, TEXT("VM Function Called: NumInstances=%d"),
        Context.GetNumInstances());
}

// HLSL ì»´íŒŒì¼ ì—ëŸ¬ í™•ì¸
#if WITH_EDITORONLY_DATA
bool GetFunctionHLSL(...)
{
    FString HLSL = GenerateHLSL(...);
#if !UE_BUILD_SHIPPING
    UE_LOG(LogNiagara, Log, TEXT("Generated HLSL:\n%s"), *HLSL);
#endif
    OutHLSL = HLSL;
    return true;
}
#endif
```

### ì„±ëŠ¥ ì¸¡ì • ê²°ê³¼

| ë°©ë²• | CPU ì‹œê°„ | GPU ì‹œê°„ | ë©”ëª¨ë¦¬ |
|------|----------|----------|--------|
| Curve ì§ì ‘ í‰ê°€ | ~5ms | N/A | 1KB |
| Curve LUT | ~0.5ms | ~0.1ms | 4KB |
| Grid ë‹¨ì¼ ë²„í¼ | N/A | ~2ms | 64MB |
| Grid ë”ë¸” ë²„í¼ | N/A | ~1.2ms | 128MB |
| StaticMesh CPU ìƒ˜í”Œë§ | ~10ms | N/A | 0 |
| StaticMesh GPU ìƒ˜í”Œë§ | ~0.1ms | ~0.3ms | 16MB |

---

## ğŸ”— ê´€ë ¨ ë¬¸ì„œ (Related Documents)

- **[Overview.md](../Overview.md)** - Niagara ì‹œìŠ¤í…œ ì „ì²´ ê°œìš”
- **[NiagaraSystem.md](NiagaraSystem.md)** - ì‹œìŠ¤í…œ ì—ì…‹
- **[NiagaraEmitter.md](NiagaraEmitter.md)** - ì—ë¯¸í„°
- **[NiagaraComponent.md](NiagaraComponent.md)** - ëŸ°íƒ€ì„ ì»´í¬ë„ŒíŠ¸
- **[Advanced/DataInterface_Advanced.md](../Advanced/DataInterface_Advanced.md)** - DataInterface ì‹¬í™” êµ¬í˜„ (VM ë°”ì¸ë”©, GPU Shader Parameter, Proxy íŒ¨í„´, ì»¤ìŠ¤í…€ DI ì œì‘ ìƒì„¸ ê°€ì´ë“œ)

---

## ğŸ“š ì°¸ê³  ìë£Œ (References)

### ì†ŒìŠ¤ íŒŒì¼

- `Engine/Plugins/FX/Niagara/Source/NiagaraCore/Public/NiagaraDataInterfaceBase.h` - ë² ì´ìŠ¤ í´ë˜ìŠ¤
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterface.h` - ì£¼ìš” ì¸í„°í˜ì´ìŠ¤
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterface*.h` (52+ íŒŒì¼)
- `Engine/Plugins/FX/ExampleCustomDataInterface/` - ì»¤ìŠ¤í…€ DI ì˜ˆì œ

### ê³µì‹ ë¬¸ì„œ

- [Niagara Data Interfaces](https://docs.unrealengine.com/5.7/en-US/niagara-data-interfaces-in-unreal-engine/)
- [Custom Data Interfaces](https://docs.unrealengine.com/5.7/en-US/creating-custom-niagara-data-interfaces/)

### ì£¼ìš” API

```cpp
// UNiagaraDataInterface (ê¸°ë³¸ í´ë˜ìŠ¤)
virtual void GetFunctions(TArray<FNiagaraFunctionSignature>& OutFunctions);
virtual void GetVMExternalFunction(..., FVMExternalFunction& OutFunc);
virtual bool GetFunctionHLSL(..., FString& OutHLSL);
virtual bool Equals(const UNiagaraDataInterface* Other) const;
virtual bool CopyTo(UNiagaraDataInterface* Destination) const;

virtual int32 PerInstanceDataSize() const;
virtual bool InitPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance);
virtual void DestroyPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance);
virtual bool PerInstanceTick(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance, float DeltaSeconds);

// FNiagaraDataInterfaceProxy (RenderThread)
virtual void ConsumePerInstanceDataFromGameThread(void* PerInstanceData, const FNiagaraSystemInstanceID& Instance);
virtual void PreStage(const FNDIGpuComputePreStageContext& Context);
virtual void PostStage(const FNDIGpuComputePostStageContext& Context);
virtual void PostSimulate(const FNDIGpuComputePostSimulateContext& Context);

// UNiagaraFunctionLibrary (ìœ í‹¸ë¦¬í‹°)
static void OverrideSystemUserVariableStaticMeshComponent(UNiagaraComponent* NiagaraSystem, const FString& OverrideName, UStaticMeshComponent* StaticMeshComponent);
static void OverrideSystemUserVariableSkeletalMeshComponent(UNiagaraComponent* NiagaraSystem, const FString& OverrideName, USkeletalMeshComponent* SkeletalMeshComponent);
static void SetTextureObject(UNiagaraComponent* NiagaraSystem, const FString& OverrideName, UTexture* Texture);
static UNiagaraDataInterfaceSkeletalMesh* GetSkeletalMeshDataInterface(UNiagaraComponent* NiagaraSystem, const FString& OverrideName);
static void SetSkeletalMeshDataInterfaceSamplingRegions(UNiagaraComponent* NiagaraSystem, const FString& OverrideName, const TArray<FName>& SamplingRegions);
static void SetSkeletalMeshDataInterfaceFilteredBones(UNiagaraComponent* NiagaraSystem, const FString& OverrideName, const TArray<FName>& FilteredBones);
static void SetSkeletalMeshDataInterfaceFilteredSockets(UNiagaraComponent* NiagaraSystem, const FString& OverrideName, const TArray<FName>& FilteredSockets);
```

### í•µì‹¬ ê°œë… ìš”ì•½

| ê°œë… | ì„¤ëª… |
|------|------|
| **UNiagaraDataInterface** | Game Threadì—ì„œ ë°ì´í„° ê´€ë¦¬ |
| **FNiagaraDataInterfaceProxy** | Render Threadì—ì„œ GPU ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ |
| **Per-Instance Data** | ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤ë³„ ê³ ìœ  ë°ì´í„° |
| **VM External Function** | CPUì—ì„œ ì‹¤í–‰ë˜ëŠ” C++ í•¨ìˆ˜ |
| **HLSL Function** | GPUì—ì„œ ì‹¤í–‰ë˜ëŠ” ì…°ì´ë” í•¨ìˆ˜ |
| **BuildShaderParameters** | GPU íŒŒë¼ë¯¸í„° êµ¬ì¡° ì •ì˜ |
| **SetShaderParameters** | GPU íŒŒë¼ë¯¸í„° ê°’ ì„¤ì • |
| **PreStage/PostStage** | Sim Stage ì „í›„ ì²˜ë¦¬ |

---

> ğŸ”„ Updated: 2026-02-18 â€” DataInterface ê´€ë ¨ ì¤‘ë³µ ë¬¸ì„œë¥¼ í†µí•© (5ê°œ â†’ 2ê°œ)
> ğŸ”„ **ì‘ì„±ì¼**: 2025-11-10
> ğŸ“ **ë¬¸ì„œ ë²„ì „**: v1.1
> âœ… **ì†ŒìŠ¤ ê²€ì¦**: UE 5.7.0 (52+ DataInterface íƒ€ì… í™•ì¸)
> ğŸ“‚ **Niagara ë¬¸ì„œ ì™„ë£Œ**: 5/5 ë¬¸ì„œ ì‘ì„± ì™„ë£Œ

## Merged Notes (from Niagara/Advanced/DataInterface_Advanced.md)

### DataInterface_Advanced - Niagara ë°ì´í„° ì¸í„°í˜ì´ìŠ¤ ì‹¬í™” (Advanced Data Interface Implementation)
#### ğŸ§­ ê°œìš” (Overview)
ì´ ë¬¸ì„œëŠ” **Niagara DataInterfaceì˜ ê³ ê¸‰ êµ¬í˜„ ì„¸ë¶€ì‚¬í•­**ì„ ë‹¤ë£¹ë‹ˆë‹¤. ê¸°ë³¸ ê°œë…ê³¼ 52+ ë‚´ì¥ íƒ€ì… ì¹´í…Œê³ ë¦¬ëŠ” [Core/DataInterface.md](../Core/DataInterface.md)ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”.

> ğŸ”„ Updated: 2026-02-18 â€” DataInterface ê´€ë ¨ ì¤‘ë³µ ë¬¸ì„œë¥¼ í†µí•© (5ê°œ â†’ 2ê°œ). Advanced_DataInterface_Implementation.mdì˜ ë‚´ìš©ì„ ë³¸ ë¬¸ì„œë¡œ í†µí•©.

**ë‹¤ë£¨ëŠ” ì£¼ì œ:**
- VM í•¨ìˆ˜ ë°”ì¸ë”© ë©”ì»¤ë‹ˆì¦˜ê³¼ í…œí”Œë¦¿ ê¸°ë°˜ ë””ìŠ¤íŒ¨ì¹˜
- GPU ì…°ì´ë” íŒŒë¼ë¯¸í„° ë¹Œë”ì™€ HLSL ì½”ë“œ ìƒì„±
- PerInstanceData ìƒëª…ì£¼ê¸°ì™€ ë©”ëª¨ë¦¬ ê´€ë¦¬
- RenderThread Proxy íŒ¨í„´ê³¼ ë°ì´í„° ì „ë‹¬
- ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸ë³„ ë™ì‘ ë¶„ë¥˜ (Instance vs PerStage)
- ì‚¬ìš©ì ì •ì˜ DataInterface ì œì‘ ìƒì„¸ ê°€ì´ë“œ

**ğŸ“‚ ìœ„ì¹˜:**
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterface.h` (ê¸°ë³¸ í´ë˜ìŠ¤)
- `Engine/Plugins/FX/Niagara/Source/Niagara/Private/DataInterface/` (êµ¬í˜„ .cpp íŒŒì¼)

---

#### ğŸ¯ DataInterfaceì˜ ì—­í• ê³¼ ì±…ì„ (Role and Responsibilities)
##### DataInterfaceê°€ í•´ê²°í•˜ëŠ” ë¬¸ì œ
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Niagara ì‹œë®¬ë ˆì´ì…˜ê³¼ ì™¸ë¶€ ë°ì´í„° ì‚¬ì´ì˜ ê°„ê·¹                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  ë¬¸ì œ 1: ì´ì¢… ì‹¤í–‰ í™˜ê²½ (Heterogeneous Execution)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  CPU ì‹œë®¬ë ˆì´ì…˜:                                          â”‚          â”‚
â”‚  â”‚  â””â”€ VectorVM (SIMD ê¸°ë°˜ ê°€ìƒ ë¨¸ì‹ )                       â”‚          â”‚
â”‚  â”‚      â”œâ”€ C++ í•¨ìˆ˜ í¬ì¸í„°ë¡œ ì™¸ë¶€ í•¨ìˆ˜ í˜¸ì¶œ                 â”‚          â”‚
â”‚  â”‚      â””â”€ ë©”ëª¨ë¦¬ ì§ì ‘ ì ‘ê·¼ ê°€ëŠ¥                             â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  GPU ì‹œë®¬ë ˆì´ì…˜:                                          â”‚          â”‚
â”‚  â”‚  â””â”€ Compute Shader (HLSL)                               â”‚          â”‚
â”‚  â”‚      â”œâ”€ HLSL ì½”ë“œ ë¬¸ìì—´ë¡œ ì»´íŒŒì¼                        â”‚          â”‚
â”‚  â”‚      â””â”€ Shader íŒŒë¼ë¯¸í„°ë¡œë§Œ ë°ì´í„° ì „ë‹¬ ê°€ëŠ¥             â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚  â†’ DataInterfaceëŠ” **ë™ì¼í•œ ì¸í„°í˜ì´ìŠ¤**ë¡œ ì–‘ìª½ ëª¨ë‘ ì§€ì›               â”‚
â”‚                                                                         â”‚
â”‚  ë¬¸ì œ 2: íƒ€ì… ì•ˆì „ì„±ê³¼ ì»´íŒŒì¼ ì‹œ ê²€ì¦                                    â”‚
â”‚  - C++ í•¨ìˆ˜ í¬ì¸í„°: íƒ€ì… ì²´í¬ ì—†ìŒ, ëŸ°íƒ€ì„ í¬ë˜ì‹œ ìœ„í—˜                  â”‚
â”‚  - HLSL ì½”ë“œ ìƒì„±: ë¬¸ìì—´ ì¡°ì‘, íƒ€ì… ë¶ˆì¼ì¹˜ ê°€ëŠ¥                         â”‚
â”‚  â†’ FNiagaraFunctionSignatureë¡œ **ì»´íŒŒì¼ ì‹œ íƒ€ì… ì²´í¬**                 â”‚
â”‚                                                                         â”‚
â”‚  ë¬¸ì œ 3: ë°ì´í„° ê³µìœ ì™€ ë™ê¸°í™”                                            â”‚
â”‚  - GameThread: ë°ì´í„° ì†Œìœ  ë° ìˆ˜ì •                                      â”‚
â”‚  - RenderThread: GPU ë¦¬ì†ŒìŠ¤ ì ‘ê·¼                                        â”‚
â”‚  â†’ **Proxy íŒ¨í„´**ìœ¼ë¡œ ìŠ¤ë ˆë“œ ê°„ ì•ˆì „í•œ ë°ì´í„° ì „ë‹¬                       â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

##### í•µì‹¬ ì„¤ê³„ ì² í•™
| ì„¤ê³„ ì›ì¹™ | ì´ìœ  | êµ¬í˜„ ë°©ë²• |
|----------|------|----------|
| **CPU/GPU ì¶”ìƒí™”** | í”Œë«í¼ ë…ë¦½ì  ì‹œë®¬ë ˆì´ì…˜ | `GetVMExternalFunction()` + `GetFunctionHLSL()` |
| **íƒ€ì… ì•ˆì „ì„±** | ì»´íŒŒì¼ ì‹œ ì˜¤ë¥˜ ê°ì§€ | `FNiagaraFunctionSignature` íƒ€ì… ì‹œìŠ¤í…œ |
| **ìŠ¤ë ˆë“œ ë¶„ë¦¬** | GameThread/RenderThread ì•ˆì „ì„± | Proxy íŒ¨í„´, `ProvidePerInstanceDataForRenderThread()` |
| **í™•ì¥ì„±** | í”ŒëŸ¬ê·¸ì¸ ë° í”„ë¡œì íŠ¸ ì»¤ìŠ¤í…€ DI | ê°€ìƒ í•¨ìˆ˜ ê¸°ë°˜, ëª¨ë“ˆí˜• ì„¤ê³„ |
| **ì„±ëŠ¥ ìµœì í™”** | GPU ì¸ë¼ì¸, CPU SIMD | HLSL ì½”ë“œ ìƒì„±, VectorVM í†µí•© |

---

#### ğŸ—ï¸ í´ë˜ìŠ¤ ê³„ì¸µ êµ¬ì¡° (Class Hierarchy)
##### UNiagaraDataInterface ìƒì„¸ ë¶„ì„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       UNiagaraDataInterface                             â”‚
â”‚  (ëª¨ë“  DataInterfaceì˜ ì¶”ìƒ ê¸°ë³¸ í´ë˜ìŠ¤)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ìƒì† ì²´ì¸:                                                              â”‚
â”‚    UObject â†’ UNiagaraDataInterfaceBase â†’ UNiagaraDataInterface         â”‚
â”‚                                                                         â”‚
â”‚  Private:                                                               â”‚
â”‚    - Proxy : TUniquePtr<FNiagaraDataInterfaceProxy>                    â”‚
â”‚      // RenderThreadìš© Proxy ê°ì²´                                       â”‚
â”‚                                                                         â”‚
â”‚    - bRenderDataDirty : uint32 (bitfield)                              â”‚
â”‚      // GPU ë°ì´í„° ì—…ë°ì´íŠ¸ í•„ìš” ì—¬ë¶€                                    â”‚
â”‚                                                                         â”‚
â”‚    - bUsedWithCPUScript : uint32 (bitfield)                            â”‚
â”‚      // CPU ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ì‚¬ìš© ì—¬ë¶€                                     â”‚
â”‚                                                                         â”‚
â”‚    - bUsedWithGPUScript : uint32 (bitfield)                            â”‚
â”‚      // GPU ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ì‚¬ìš© ì—¬ë¶€                                     â”‚
â”‚                                                                         â”‚
â”‚  Public - í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ ì œê³µ:                                            â”‚
â”‚    + GetFunctionsInternal(TArray<FNiagaraFunctionSignature>&) : void  â”‚
â”‚      // ì´ DIê°€ ì œê³µí•˜ëŠ” í•¨ìˆ˜ ëª©ë¡ ë°˜í™˜ (WITH_EDITORONLY_DATA)          â”‚
â”‚                                                                         â”‚
â”‚  Public - CPU ì‹¤í–‰:                                                      â”‚
â”‚    + GetVMExternalFunction(BindingInfo, InstanceData, OutFunc) : void â”‚
â”‚      // CPU ì‹œë®¬ë ˆì´ì…˜ìš© C++ í•¨ìˆ˜ í¬ì¸í„° ë°”ì¸ë”©                          â”‚
â”‚      // VectorVMì—ì„œ í˜¸ì¶œë¨                                              â”‚
â”‚                                                                         â”‚
â”‚  Public - GPU ì‹¤í–‰:                                                      â”‚
â”‚    + BuildShaderParameters(ShaderParametersBuilder) : void            â”‚
â”‚      // GPU Shader íŒŒë¼ë¯¸í„° êµ¬ì¡°ì²´ ì •ì˜                                  â”‚
â”‚                                                                         â”‚
â”‚    + SetShaderParameters(Context) : void                               â”‚
â”‚      // GPU Shader íŒŒë¼ë¯¸í„° ê°’ ì„¤ì •                                      â”‚
â”‚                                                                         â”‚
â”‚    + GetParameterDefinitionHLSL(ParamInfo, OutHLSL) : void             â”‚
â”‚      // HLSL íŒŒë¼ë¯¸í„° ì„ ì–¸ ì½”ë“œ ìƒì„±                                     â”‚
â”‚                                                                         â”‚
â”‚    + GetFunctionHLSL(ParamInfo, FunctionInfo, OutHLSL) : bool          â”‚
â”‚      // HLSL í•¨ìˆ˜ êµ¬í˜„ ì½”ë“œ ìƒì„±                                         â”‚
â”‚                                                                         â”‚
â”‚  Public - ìƒëª…ì£¼ê¸°:                                                      â”‚
â”‚    + InitPerInstanceData(PerInstanceData, SystemInstance) : bool       â”‚
â”‚      // ì¸ìŠ¤í„´ìŠ¤ë³„ ë°ì´í„° ì´ˆê¸°í™”                                         â”‚
â”‚                                                                         â”‚
â”‚    + DestroyPerInstanceData(PerInstanceData, SystemInstance) : void    â”‚
â”‚      // ì¸ìŠ¤í„´ìŠ¤ë³„ ë°ì´í„° ì •ë¦¬                                           â”‚
â”‚                                                                         â”‚
â”‚    + PerInstanceTick(PerInstanceData, SystemInstance, DeltaSeconds)    â”‚
â”‚      // ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸ (PreSimulate)                                 â”‚
â”‚                                                                         â”‚
â”‚    + PerInstanceTickPostSimulate(PerInstanceData, ...) : bool          â”‚
â”‚      // ì‹œë®¬ë ˆì´ì…˜ í›„ ì—…ë°ì´íŠ¸                                           â”‚
â”‚                                                                         â”‚
â”‚  Public - RenderThread ë°ì´í„° ì „ë‹¬:                                      â”‚
â”‚    + ProvidePerInstanceDataForRenderThread(DataForRT, PerInstanceData) â”‚
â”‚      // GameThread â†’ RenderThread ë°ì´í„° ì „ë‹¬                           â”‚
â”‚                                                                         â”‚
â”‚    + PerInstanceDataPassedToRenderThreadSize() : int32                 â”‚
â”‚      // ì „ë‹¬í•  ë°ì´í„° í¬ê¸° (16ë°”ì´íŠ¸ ì •ë ¬ í•„ìˆ˜!)                         â”‚
â”‚                                                                         â”‚
â”‚  Public - ìœ í‹¸ë¦¬í‹°:                                                      â”‚
â”‚    + Equals(const UNiagaraDataInterface*) : bool                       â”‚
â”‚      // DI ë™ë“±ì„± ë¹„êµ                                                   â”‚
â”‚                                                                         â”‚
â”‚    + CopyToInternal(UNiagaraDataInterface*) : bool                     â”‚
â”‚      // DI ë³µì‚¬ (íŒŒë¼ë¯¸í„° ì˜¤ë²„ë¼ì´ë“œ ì‹œ)                                 â”‚
â”‚                                                                         â”‚
â”‚    + CanExecuteOnTarget(ENiagaraSimTarget) : bool                      â”‚
â”‚      // CPU/GPU ì§€ì› ì—¬ë¶€ ë°˜í™˜                                           â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ“‚ ì†ŒìŠ¤ ê²€ì¦:** `NiagaraDataInterface.h:569-957`

##### FNiagaraDataInterfaceProxy êµ¬ì¡°
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   FNiagaraDataInterfaceProxy                            â”‚
â”‚  (RenderThreadì—ì„œ ì‚¬ìš©ë˜ëŠ” DIì˜ Proxy ê°ì²´)                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ì—­í• :                                                                   â”‚
â”‚  - GameThreadì™€ RenderThread ë¶„ë¦¬                                       â”‚
â”‚  - GPU ë¦¬ì†ŒìŠ¤ ì†Œìœ  ë° ê´€ë¦¬                                               â”‚
â”‚  - Compute Shader íŒŒë¼ë¯¸í„° ì œê³µ                                          â”‚
â”‚                                                                         â”‚
â”‚  Public:                                                                â”‚
â”‚    + PerInstanceDataPassedToRenderThreadSize() : int32 (pure virtual)  â”‚
â”‚      // GameThreadì—ì„œ ë°›ì„ ë°ì´í„° í¬ê¸°                                  â”‚
â”‚                                                                         â”‚
â”‚    + ConsumePerInstanceDataFromGameThread(void*, SystemInstanceID)     â”‚
â”‚      // GameThread ë°ì´í„° ì†Œë¹„ ë° ì €ì¥                                   â”‚
â”‚                                                                         â”‚
â”‚    + ResetData(FNDIGpuComputeResetContext&) : void                     â”‚
â”‚      // GPU ë°ì´í„° ì´ˆê¸°í™” (ì‹œìŠ¤í…œ ë¦¬ì…‹ ì‹œ)                               â”‚
â”‚                                                                         â”‚
â”‚    + PreStage(FNDIGpuComputePreStageContext&) : void                   â”‚
â”‚      // Simulation Stage ì‹œì‘ ì „ í˜¸ì¶œ                                    â”‚
â”‚                                                                         â”‚
â”‚    + PostStage(FNDIGpuComputePostStageContext&) : void                 â”‚
â”‚      // Simulation Stage ì¢…ë£Œ í›„ í˜¸ì¶œ                                    â”‚
â”‚                                                                         â”‚
â”‚    + PostSimulate(FNDIGpuComputePostSimulateContext&) : void           â”‚
â”‚      // ì „ì²´ ì‹œë®¬ë ˆì´ì…˜ ì¢…ë£Œ í›„ í˜¸ì¶œ                                      â”‚
â”‚                                                                         â”‚
â”‚  FNiagaraDataInterfaceProxyRW (Read/Write í™•ì¥):                        â”‚
â”‚    + GetDispatchArgs(FNDIGpuComputeDispatchArgsGenContext&)            â”‚
â”‚      // Iteration Sourceë¡œ ì‚¬ìš©ë  ë•Œ Dispatch ì¸ìˆ˜ ì œê³µ                  â”‚
â”‚                                                                         â”‚
â”‚    + GetElementCount(SystemInstanceID) : FIntVector (deprecated)       â”‚
â”‚      // GPU Iteration ì¹´ìš´íŠ¸ (ë ˆê±°ì‹œ)                                    â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ“‚ ì†ŒìŠ¤ ê²€ì¦:** `NiagaraDataInterface.h:394-427`, `NiagaraDataInterfaceRW.h:85-106`

---

#### ğŸ”„ VM í•¨ìˆ˜ ë°”ì¸ë”© ë©”ì»¤ë‹ˆì¦˜ (VM Function Binding Mechanism)
##### VectorVM ì™¸ë¶€ í•¨ìˆ˜ í˜¸ì¶œ íë¦„
```
CPU ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰ íë¦„:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                         â”‚
â”‚  1. Niagara ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ì‹œì‘                                           â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚     â”‚  FNiagaraSystemInstance::Tick()                      â”‚          â”‚
â”‚     â”‚  â””â”€ FNiagaraEmitterInstance::Tick()                  â”‚          â”‚
â”‚     â”‚      â””â”€ ExecuteScript(UpdateScript)                  â”‚          â”‚
â”‚     â”‚          â””â”€ VectorVM::Exec(...)                      â”‚          â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  2. VectorVMì´ DataInterface í•¨ìˆ˜ í˜¸ì¶œ ê°ì§€                              â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚     â”‚  Bytecode:                                            â”‚          â”‚
â”‚     â”‚    EXTERNAL_FUNC_CALL  // OpCode                     â”‚          â”‚
â”‚     â”‚    FunctionBindingIndex = 5  // ì–´ë–¤ í•¨ìˆ˜?            â”‚          â”‚
â”‚     â”‚    InputRegisters = [R0, R1, R2]                     â”‚          â”‚
â”‚     â”‚    OutputRegisters = [R3]                            â”‚          â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  3. FVMExternalFunction ì¡°íšŒ ë° ì‹¤í–‰                                     â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚     â”‚  FVMExternalFunctionBindingInfo BindingInfo = {      â”‚          â”‚
â”‚     â”‚    Name: "SampleTexture2D",                          â”‚          â”‚
â”‚     â”‚    OwnerName: "User.MyTexture",                      â”‚          â”‚
â”‚     â”‚    InputParamLocations: [Register, Register, Const],â”‚          â”‚
â”‚     â”‚    NumInputs: 3,                                     â”‚          â”‚
â”‚     â”‚    NumOutputs: 1                                     â”‚          â”‚
â”‚     â”‚  };                                                  â”‚          â”‚
â”‚     â”‚                                                      â”‚          â”‚
â”‚     â”‚  // GetVMExternalFunction í˜¸ì¶œ                       â”‚          â”‚
â”‚     â”‚  DataInterface->GetVMExternalFunction(               â”‚          â”‚
â”‚     â”‚    BindingInfo,                                      â”‚          â”‚
â”‚     â”‚    InstanceData,  // ì¸ìŠ¤í„´ìŠ¤ë³„ ë°ì´í„° í¬ì¸í„°         â”‚          â”‚
â”‚     â”‚    OutFunc        // í•¨ìˆ˜ í¬ì¸í„° ì¶œë ¥                 â”‚          â”‚
â”‚     â”‚  );                                                  â”‚          â”‚
â”‚     â”‚                                                      â”‚          â”‚
â”‚     â”‚  // í•¨ìˆ˜ ì‹¤í–‰                                         â”‚          â”‚
â”‚     â”‚  OutFunc.Execute(Context);                          â”‚          â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  4. C++ í•¨ìˆ˜ ë‚´ë¶€ì—ì„œ íŒŒë¼ë¯¸í„° ì½ê¸°/ì“°ê¸°                                  â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚     â”‚  void VMSampleTexture(FVectorVMExternalFunctionContext& Context)â”‚
â”‚     â”‚  {                                                   â”‚          â”‚
â”‚     â”‚    // ì…ë ¥ íŒŒë¼ë¯¸í„° í•¸ë“¤ëŸ¬ ìƒì„±                       â”‚          â”‚
â”‚     â”‚    VectorVM::FExternalFuncInputHandler<FVector2f> UVParam(Context);â”‚
â”‚     â”‚    VectorVM::FExternalFuncInputHandler<float> MipParam(Context);â”‚
â”‚     â”‚                                                      â”‚          â”‚
â”‚     â”‚    // ì¶œë ¥ íŒŒë¼ë¯¸í„° í•¸ë“¤ëŸ¬ ìƒì„±                       â”‚          â”‚
â”‚     â”‚    VectorVM::FExternalFuncRegisterHandler<FLinearColor> OutColor(Context);â”‚
â”‚     â”‚                                                      â”‚          â”‚
â”‚     â”‚    // ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤(íŒŒí‹°í´) ìˆœíšŒ                      â”‚          â”‚
â”‚     â”‚    for (int32 i = 0; i < Context.GetNumInstances(); ++i)â”‚      â”‚
â”‚     â”‚    {                                                 â”‚          â”‚
â”‚     â”‚      FVector2f UV = UVParam.GetAndAdvance();       â”‚          â”‚
â”‚     â”‚      float MipLevel = MipParam.GetAndAdvance();     â”‚          â”‚
â”‚     â”‚                                                      â”‚          â”‚
â”‚     â”‚      // ì‹¤ì œ ì‘ì—… ìˆ˜í–‰                                â”‚          â”‚
â”‚     â”‚      FLinearColor Color = Texture->Sample(UV, MipLevel);â”‚      â”‚
â”‚     â”‚                                                      â”‚          â”‚
â”‚     â”‚      // ê²°ê³¼ ì“°ê¸°                                     â”‚          â”‚
â”‚     â”‚      *OutColor.GetDestAndAdvance() = Color;         â”‚          â”‚
â”‚     â”‚    }                                                 â”‚          â”‚
â”‚     â”‚  }                                                   â”‚          â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

##### í…œí”Œë¦¿ ê¸°ë°˜ í•¨ìˆ˜ ë°”ì¸ë” ì‹œìŠ¤í…œ
Unreal Engineì€ **ë§¤í¬ë¡œì™€ í…œí”Œë¦¿ì„ í™œìš©í•œ íƒ€ì… ì•ˆì „ ë°”ì¸ë”© ì‹œìŠ¤í…œ**ì„ ì œê³µí•©ë‹ˆë‹¤:

```cpp
// âœ… í…œí”Œë¦¿ ê¸°ë°˜ í•¨ìˆ˜ ë°”ì¸ë” ì˜ˆì‹œ
// NiagaraDataInterface.h:113-146

// 1. í•¨ìˆ˜ ë°”ì¸ë” ì •ì˜ ë§¤í¬ë¡œ
#define DEFINE_NDI_FUNC_BINDER(ClassName, FuncName)\
struct NDI_FUNC_BINDER(ClassName, FuncName)\
{\
    template<typename ... ParamTypes>\
    static void Bind(UNiagaraDataInterface* Interface, \
                     const FVMExternalFunctionBindingInfo& BindingInfo, \
                     void* InstanceData, \
                     FVMExternalFunction &OutFunc)\
    {\
        // Lambdaë¡œ ë©¤ë²„ í•¨ìˆ˜ í˜¸ì¶œ ë˜í•‘
        auto Lambda = [Interface](FVectorVMExternalFunctionContext& Context) { \
            static_cast<ClassName*>(Interface)->FuncName<ParamTypes...>(Context); \
        };\
        OutFunc = FVMExternalFunction::CreateLambda(Lambda);\
    }\
};

// 2. íŒŒë¼ë¯¸í„° íƒ€ì… ë°”ì¸ë”
template<int32 ParamIdx, typename DataType, typename NextBinder>
struct TNDIParamBinder
{
    template<typename... ParamTypes>
    static void Bind(UNiagaraDataInterface* Interface,
                     const FVMExternalFunctionBindingInfo& BindingInfo,
                     void* InstanceData,
                     FVMExternalFunction &OutFunc)
    {
        // InputParamLocationsë¥¼ í™•ì¸í•˜ì—¬ Const/Register ì„ íƒ
        if (BindingInfo.InputParamLocations[ParamIdx])
        {
            // Const íŒŒë¼ë¯¸í„°
            NextBinder::template Bind<ParamTypes...,
                VectorVM::FExternalFuncConstHandler<DataType>>(
                Interface, BindingInfo, InstanceData, OutFunc);
        }
        else
        {
            // Register íŒŒë¼ë¯¸í„°
            NextBinder::template Bind<ParamTypes...,
                VectorVM::FExternalFuncRegisterHandler<DataType>>(
                Interface, BindingInfo, InstanceData, OutFunc);
        }
    }
};

// 3. ì‚¬ìš© ì˜ˆì‹œ (UNiagaraDataInterfaceSkeletalMesh)
DEFINE_NDI_FUNC_BINDER(UNiagaraDataInterfaceSkeletalMesh, GetSkinnedBoneData);

void UNiagaraDataInterfaceSkeletalMesh::GetVMExternalFunction(
    const FVMExternalFunctionBindingInfo& BindingInfo,
    void* InstanceData,
    FVMExternalFunction &OutFunc)
{
    if (BindingInfo.Name == GetSkinnedBoneDataName)
    {
        // í…œí”Œë¦¿ ë°”ì¸ë”ë¥¼ í†µí•´ íƒ€ì… ì•ˆì „í•˜ê²Œ ë°”ì¸ë”©
        TNDIParamBinder<0, int32,                     // íŒŒë¼ë¯¸í„° 0: BoneIndex (int32)
          TNDIParamBinder<1, FNiagaraBool,            // íŒŒë¼ë¯¸í„° 1: bInterpolated (bool)
            TNDIExplicitBinder<FSkinningHandler,      // SkinningHandler (í…œí”Œë¦¿ íƒ€ì…)
              TNDIExplicitBinder<FTransformHandler,   // TransformHandler (í…œí”Œë¦¿ íƒ€ì…)
                NDI_FUNC_BINDER(UNiagaraDataInterfaceSkeletalMesh, GetSkinnedBoneData)
        >>>>::Bind(this, BindingInfo, InstanceData, OutFunc);
    }
}
```

**í•µì‹¬ ë©”ì»¤ë‹ˆì¦˜:**
1. **ì»´íŒŒì¼ ì‹œ íƒ€ì… ì²´í¬**: í…œí”Œë¦¿ìœ¼ë¡œ íŒŒë¼ë¯¸í„° íƒ€ì… ì•ˆì „ì„± ë³´ì¥
2. **ëŸ°íƒ€ì„ íƒ€ì… ì„ íƒ**: `InputParamLocations`ë¥¼ ë³´ê³  Const/Register ê²°ì •
3. **ì œë¡œ ì˜¤ë²„í—¤ë“œ**: ì»´íŒŒì¼ íƒ€ì„ì— ëª¨ë“  íƒ€ì… ê²°ì •, ëŸ°íƒ€ì„ íƒ€ì… ê²€ì‚¬ ì—†ìŒ

**ğŸ“‚ ì†ŒìŠ¤ ê²€ì¦:** `NiagaraDataInterface.h:72-145`

---

#### ğŸ¨ GPU ì…°ì´ë” íŒŒë¼ë¯¸í„° ì‹œìŠ¤í…œ (GPU Shader Parameter System)
##### BuildShaderParametersì™€ SetShaderParameters íë¦„
```
GPU ì…°ì´ë” íŒŒë¼ë¯¸í„° ì„¤ì • íë¦„:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                         â”‚
â”‚  [ì»´íŒŒì¼ ì‹œ - HLSL ì½”ë“œ ìƒì„±]                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  1. GetParameterDefinitionHLSL() í˜¸ì¶œ                    â”‚          â”‚
â”‚  â”‚     â†’ HLSL íŒŒë¼ë¯¸í„° ì„ ì–¸ ì½”ë“œ ìƒì„±                       â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ì˜ˆì‹œ (UNiagaraDataInterfaceTexture):                   â”‚          â”‚
â”‚  â”‚  ```hlsl                                                 â”‚          â”‚
â”‚  â”‚  Texture2D {ParameterName}_Texture;                     â”‚          â”‚
â”‚  â”‚  SamplerState {ParameterName}_TextureSampler;           â”‚          â”‚
â”‚  â”‚  int2 {ParameterName}_TextureSize;                      â”‚          â”‚
â”‚  â”‚  ```                                                     â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  2. GetFunctionHLSL() í˜¸ì¶œ                               â”‚          â”‚
â”‚  â”‚     â†’ HLSL í•¨ìˆ˜ êµ¬í˜„ ì½”ë“œ ìƒì„±                           â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ì˜ˆì‹œ:                                                   â”‚          â”‚
â”‚  â”‚  ```hlsl                                                 â”‚          â”‚
â”‚  â”‚  void SampleTexture2D_{InstanceIndex}(                  â”‚          â”‚
â”‚  â”‚      float2 UV, float MipLevel, out float4 Color)       â”‚          â”‚
â”‚  â”‚  {                                                       â”‚          â”‚
â”‚  â”‚      Color = {ParameterName}_Texture.SampleLevel(       â”‚          â”‚
â”‚  â”‚          {ParameterName}_TextureSampler, UV, MipLevel); â”‚          â”‚
â”‚  â”‚  }                                                       â”‚          â”‚
â”‚  â”‚  ```                                                     â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  [ëŸ°íƒ€ì„ - Shader íŒŒë¼ë¯¸í„° ë¹Œë“œ]                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  3. BuildShaderParameters() í˜¸ì¶œ (1íšŒ, ì´ˆê¸°í™” ì‹œ)        â”‚          â”‚
â”‚  â”‚     â†’ Shader íŒŒë¼ë¯¸í„° êµ¬ì¡°ì²´ ë ˆì´ì•„ì›ƒ ì •ì˜               â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ì˜ˆì‹œ (UNiagaraDataInterfaceTexture):                   â”‚          â”‚
â”‚  â”‚  ```cpp                                                  â”‚          â”‚
â”‚  â”‚  void BuildShaderParameters(                             â”‚          â”‚
â”‚  â”‚      FNiagaraShaderParametersBuilder& ShaderParametersBuilder) constâ”‚
â”‚  â”‚  {                                                       â”‚          â”‚
â”‚  â”‚    ShaderParametersBuilder.AddNestedStruct<FShaderParameters>();â”‚  â”‚
â”‚  â”‚  }                                                       â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  // FShaderParameters êµ¬ì¡°ì²´ ì •ì˜:                       â”‚          â”‚
â”‚  â”‚  BEGIN_SHADER_PARAMETER_STRUCT(FShaderParameters, )     â”‚          â”‚
â”‚  â”‚      SHADER_PARAMETER(FIntPoint, TextureSize)           â”‚          â”‚
â”‚  â”‚      SHADER_PARAMETER(int32, MipLevels)                 â”‚          â”‚
â”‚  â”‚      SHADER_PARAMETER_RDG_TEXTURE(Texture2D, Texture)   â”‚          â”‚
â”‚  â”‚      SHADER_PARAMETER_SAMPLER(SamplerState, TextureSampler)â”‚      â”‚
â”‚  â”‚  END_SHADER_PARAMETER_STRUCT()                          â”‚          â”‚
â”‚  â”‚  ```                                                     â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  [ëŸ°íƒ€ì„ - Shader íŒŒë¼ë¯¸í„° ê°’ ì„¤ì •]                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  4. SetShaderParameters() í˜¸ì¶œ (ë§¤ Dispatchë§ˆë‹¤)         â”‚          â”‚
â”‚  â”‚     â†’ ì‹¤ì œ GPU ë¦¬ì†ŒìŠ¤ ë°”ì¸ë”©                             â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ì˜ˆì‹œ:                                                   â”‚          â”‚
â”‚  â”‚  ```cpp                                                  â”‚          â”‚
â”‚  â”‚  void SetShaderParameters(                               â”‚          â”‚
â”‚  â”‚      const FNiagaraDataInterfaceSetShaderParametersContext& Context) constâ”‚
â”‚  â”‚  {                                                       â”‚          â”‚
â”‚  â”‚    // Proxy ë°ì´í„° ê°€ì ¸ì˜¤ê¸°                              â”‚          â”‚
â”‚  â”‚    const FNiagaraDataInterfaceProxyTexture& DIProxy =   â”‚          â”‚
â”‚  â”‚        Context.GetProxy<FNiagaraDataInterfaceProxyTexture>();â”‚     â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚    // Shader íŒŒë¼ë¯¸í„° êµ¬ì¡°ì²´ ê°€ì ¸ì˜¤ê¸°                    â”‚          â”‚
â”‚  â”‚    FShaderParameters* Parameters =                       â”‚          â”‚
â”‚  â”‚        Context.GetParameterNestedStruct<FShaderParameters>();â”‚     â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚    // ê°’ ì„¤ì •                                             â”‚          â”‚
â”‚  â”‚    Parameters->TextureSize = DIProxy.TextureSize;       â”‚          â”‚
â”‚  â”‚    Parameters->MipLevels = DIProxy.MipLevels;           â”‚          â”‚
â”‚  â”‚    Parameters->Texture = DIProxy.TextureRDG;            â”‚          â”‚
â”‚  â”‚    Parameters->TextureSampler = DIProxy.SamplerStateRHI;â”‚          â”‚
â”‚  â”‚  }                                                       â”‚          â”‚
â”‚  â”‚  ```                                                     â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  5. GPUì—ì„œ ì‹¤í–‰                                                         â”‚
â”‚     â†’ Compute Shaderê°€ íŒŒë¼ë¯¸í„°ë¥¼ í†µí•´ ë¦¬ì†ŒìŠ¤ ì ‘ê·¼                       â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

##### FNiagaraDataInterfaceSetShaderParametersContext êµ¬ì¡°
```cpp
// NiagaraDataInterface.h:431-530

struct FNiagaraDataInterfaceSetShaderParametersContext
{
    // í•µì‹¬ ë©¤ë²„:
    FRDGBuilder& GraphBuilder;  // RenderGraph ë¹Œë”
    const FNiagaraGpuComputeDispatchInterface& ComputeDispatchInterface;
    const FNiagaraGPUSystemTick& SystemTick;
    const FNiagaraComputeInstanceData& ComputeInstanceData;
    const FNiagaraSimStageData& SimStageData;

    // Shader íŒŒë¼ë¯¸í„° ê´€ë ¨:
    const FNiagaraShaderRef& ShaderRef;
    const FNiagaraShaderScriptParametersMetadata& ShaderParametersMetadata;
    uint8* BaseParameters;  // íŒŒë¼ë¯¸í„° ë©”ëª¨ë¦¬ ë² ì´ìŠ¤ í¬ì¸í„°

    FNiagaraDataInterfaceProxy* DataInterfaceProxy;
    mutable uint32 ParametersOffset;  // í˜„ì¬ íŒŒë¼ë¯¸í„° ì˜¤í”„ì…‹

    // ì£¼ìš” ë©”ì„œë“œ:

    // 1. Proxy ê°€ì ¸ì˜¤ê¸°
    template<typename T>
    T& GetProxy() const
    {
        return static_cast<T&>(*DataInterfaceProxy);
    }

    // 2. Nested Struct íŒŒë¼ë¯¸í„° ê°€ì ¸ì˜¤ê¸°
    template<typename T>
    T* GetParameterNestedStruct() const
    {
        const uint32 StructOffset = Align(ParametersOffset,
                                         TShaderParameterStructTypeInfo<T>::Alignment);
        ParametersOffset = StructOffset +
                          TShaderParameterStructTypeInfo<T>::GetStructMetadata()->GetSize();
        return reinterpret_cast<T*>(BaseParameters + StructOffset);
    }

    // 3. Included Struct íŒŒë¼ë¯¸í„° ê°€ì ¸ì˜¤ê¸° (ì˜¤í”„ì…‹ ìë™ ê³„ì‚° ì•ˆ í•¨)
    template<typename T>
    T* GetParameterIncludedStruct() const
    {
        return reinterpret_cast<T*>(
            GetParameterIncludedStruct(TShaderParameterStructTypeInfo<T>::GetStructMetadata())
        );
    }

    // 4. Loose Array íŒŒë¼ë¯¸í„° ê°€ì ¸ì˜¤ê¸°
    template<typename T>
    TArrayView<T> GetParameterLooseArray(int32 NumElements) const
    {
        const uint32 ArrayOffset = Align(ParametersOffset, SHADER_PARAMETER_ARRAY_ELEMENT_ALIGNMENT);
        ParametersOffset = ArrayOffset + (sizeof(T) * NumElements);
        return TArrayView<T>(reinterpret_cast<T*>(BaseParameters + ArrayOffset), NumElements);
    }

    // 5. íŒŒë¼ë¯¸í„° ë°”ì¸ë”© ì—¬ë¶€ í™•ì¸
    bool IsParameterBound(const void* ParameterAddress) const;
    bool IsResourceBound(const void* ResourceAddress) const;
};
```

**ğŸ“‚ ì†ŒìŠ¤ ê²€ì¦:** `NiagaraDataInterface.h:431-530`

##### ì£¼ìš” DataInterfaceë³„ Shader Parameters ì˜ˆì‹œ
```cpp
// 1. UNiagaraDataInterfaceTexture
// NiagaraDataInterfaceTexture.h:16-21

BEGIN_SHADER_PARAMETER_STRUCT(FShaderParameters, )
    SHADER_PARAMETER(FIntPoint, TextureSize)       // Texture í¬ê¸°
    SHADER_PARAMETER(int32, MipLevels)             // Mip ë ˆë²¨ ìˆ˜
    SHADER_PARAMETER_RDG_TEXTURE(Texture2D, Texture)  // RDG Texture
    SHADER_PARAMETER_SAMPLER(SamplerState, TextureSampler)  // Sampler
END_SHADER_PARAMETER_STRUCT()

// 2. UNiagaraDataInterfaceCamera
// NiagaraDataInterfaceCamera.h:33-35

BEGIN_SHADER_PARAMETER_STRUCT(FShaderParameters, )
    SHADER_PARAMETER(int32, SplitscreenMode)  // Split Screen ëª¨ë“œ
END_SHADER_PARAMETER_STRUCT()

// 3. UNiagaraDataInterfaceParticleRead
// NiagaraDataInterfaceParticleRead.h:16-30

BEGIN_SHADER_PARAMETER_STRUCT(FShaderParameters, )
    SHADER_PARAMETER(uint32, IsLocalSpace)
    SHADER_PARAMETER(int, NumSpawnedParticles)
    SHADER_PARAMETER(int, SpawnedParticlesAcquireTag)
    SHADER_PARAMETER(uint32, InstanceCountOffset)
    SHADER_PARAMETER(uint32, ParticleStrideFloat)
    SHADER_PARAMETER(uint32, ParticleStrideInt)
    SHADER_PARAMETER(uint32, ParticleStrideHalf)
    SHADER_PARAMETER(int, AcquireTagRegisterIndex)
    SHADER_PARAMETER_SRV(Buffer<int>, SpawnedIDsBuffer)
    SHADER_PARAMETER_SRV(Buffer<int>, IDToIndexTable)
    SHADER_PARAMETER_SRV(Buffer<float>, InputFloatBuffer)
    SHADER_PARAMETER_SRV(Buffer<int>, InputIntBuffer)
    SHADER_PARAMETER_SRV(Buffer<half>, InputHalfBuffer)
END_SHADER_PARAMETER_STRUCT()
```

**í•µì‹¬ íŒŒë¼ë¯¸í„° íƒ€ì…:**
- `SHADER_PARAMETER`: ê¸°ë³¸ íƒ€ì… (int32, float, FVector ë“±)
- `SHADER_PARAMETER_RDG_TEXTURE`: RenderGraph Texture
- `SHADER_PARAMETER_RDG_BUFFER`: RenderGraph Buffer
- `SHADER_PARAMETER_SRV`: Shader Resource View (ì½ê¸° ì „ìš©)
- `SHADER_PARAMETER_UAV`: Unordered Access View (ì½ê¸°/ì“°ê¸°)
- `SHADER_PARAMETER_SAMPLER`: Texture Sampler

---

#### ğŸ§¬ PerInstanceData ìƒëª…ì£¼ê¸° (PerInstanceData Lifecycle)
##### PerInstanceDataì˜ í•„ìš”ì„±
```
ì™œ PerInstanceDataê°€ í•„ìš”í•œê°€?
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                         â”‚
â”‚  ë¬¸ì œ: DataInterfaceëŠ” ì—ì…‹ì— ì €ì¥ë˜ëŠ” CDO (Class Default Object)        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  UNiagaraDataInterfaceSkeletalMesh* DI = ...;            â”‚          â”‚
â”‚  â”‚  // ì´ DI ì¸ìŠ¤í„´ìŠ¤ëŠ” ì—¬ëŸ¬ NiagaraComponentì—ì„œ ê³µìœ ë¨!    â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  NiagaraComponent A â†’ ë™ì¼ DI ì‚¬ìš©                       â”‚          â”‚
â”‚  â”‚  NiagaraComponent B â†’ ë™ì¼ DI ì‚¬ìš©                       â”‚          â”‚
â”‚  â”‚  NiagaraComponent C â†’ ë™ì¼ DI ì‚¬ìš©                       â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ê° ì»´í¬ë„ŒíŠ¸ëŠ” ë‹¤ë¥¸ SkeletalMeshComponentë¥¼ ì°¸ì¡°!         â”‚          â”‚
â”‚  â”‚  â†’ DIì— ì§ì ‘ ì €ì¥í•˜ë©´ ë®ì–´ì¨ì§                           â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  í•´ê²°ì±…: ê° SystemInstanceë§ˆë‹¤ ë³„ë„ì˜ PerInstanceData í• ë‹¹               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  UNiagaraDataInterfaceSkeletalMesh (CDO)                 â”‚          â”‚
â”‚  â”‚  â””â”€ ê³µí†µ ì„¤ì •ë§Œ ì €ì¥ (DefaultMesh, FilteredBones ë“±)     â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  FNDISkeletalMesh_InstanceData A                         â”‚          â”‚
â”‚  â”‚  â”œâ”€ SceneComponent: CharacterA->GetMesh()                â”‚          â”‚
â”‚  â”‚  â”œâ”€ SkinningData: CharacterAì˜ Skinning ìºì‹œ             â”‚          â”‚
â”‚  â”‚  â””â”€ Transform: CharacterAì˜ ì›”ë“œ ë³€í™˜                    â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  FNDISkeletalMesh_InstanceData B                         â”‚          â”‚
â”‚  â”‚  â”œâ”€ SceneComponent: CharacterB->GetMesh()                â”‚          â”‚
â”‚  â”‚  â”œâ”€ SkinningData: CharacterBì˜ Skinning ìºì‹œ             â”‚          â”‚
â”‚  â”‚  â””â”€ Transform: CharacterBì˜ ì›”ë“œ ë³€í™˜                    â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

##### PerInstanceData ìƒëª…ì£¼ê¸° ë‹¤ì´ì–´ê·¸ë¨
```
SystemInstance ìƒì„± â†’ DI PerInstanceData ìƒëª…ì£¼ê¸°:

  NiagaraComponent          SystemInstance           DataInterface
       â”‚                         â”‚                         â”‚
       â”‚ Activate()              â”‚                         â”‚
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                         â”‚
       â”‚                         â”‚ Init()                  â”‚
       â”‚                         â”‚                         â”‚
       â”‚                         â”‚ InitDataInterfaces()    â”‚
       â”‚                         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
       â”‚                         â”‚                         â”‚
       â”‚                         â”‚                         â”‚ PerInstanceDataSize()
       â”‚                         â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â†’ sizeof(FMyInstanceData)
       â”‚                         â”‚                         â”‚
       â”‚                         â”‚ Allocate Memory         â”‚
       â”‚                         â”‚ (Placement New ì‚¬ìš©)     â”‚
       â”‚                         â”‚                         â”‚
       â”‚                         â”‚ InitPerInstanceData()   â”‚
       â”‚                         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
       â”‚                         â”‚                         â”‚ new (Memory) FMyInstanceData()
       â”‚                         â”‚                         â”‚ // ë©¤ë²„ ì´ˆê¸°í™”
       â”‚                         â”‚                         â”‚ // ë¦¬ì†ŒìŠ¤ í• ë‹¹
       â”‚                         â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ return true/false
       â”‚                         â”‚                         â”‚
       â”‚                         â”‚ â˜… ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ ì‹œìŠ¤í…œ ë¹„í™œì„±í™”
       â”‚                         â”‚                         â”‚
  â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€
  ë§¤ í”„ë ˆì„                       â”‚                         â”‚
  â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€
       â”‚                         â”‚                         â”‚
       â”‚ Tick(DeltaTime)         â”‚                         â”‚
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                         â”‚
       â”‚                         â”‚ PerInstanceTick() (PreSimulate)
       â”‚                         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
       â”‚                         â”‚                         â”‚ // ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸
       â”‚                         â”‚                         â”‚ // ì˜ˆ: Transform ê°±ì‹ 
       â”‚                         â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
       â”‚                         â”‚                         â”‚
       â”‚                         â”‚ Execute Scripts         â”‚
       â”‚                         â”‚                         â”‚
       â”‚                         â”‚ PerInstanceTickPostSimulate()
       â”‚                         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
       â”‚                         â”‚                         â”‚ // ì‹œë®¬ë ˆì´ì…˜ í›„ ì²˜ë¦¬
       â”‚                         â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
       â”‚                         â”‚                         â”‚
  â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€
  SystemInstance íŒŒê´´             â”‚                         â”‚
  â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€
       â”‚                         â”‚                         â”‚
       â”‚ Deactivate()            â”‚                         â”‚
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                         â”‚
       â”‚                         â”‚ Cleanup()               â”‚
       â”‚                         â”‚                         â”‚
       â”‚                         â”‚ DestroyPerInstanceData()â”‚
       â”‚                         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
       â”‚                         â”‚                         â”‚ // ë¦¬ì†ŒìŠ¤ í•´ì œ
       â”‚                         â”‚                         â”‚ InstData->~FMyInstanceData()
       â”‚                         â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
       â”‚                         â”‚                         â”‚
       â”‚                         â”‚ Free Memory             â”‚
       â”‚                         â”‚                         â”‚
```

##### PerInstanceData êµ¬í˜„ ì˜ˆì‹œ
```cpp
// âœ… SkeletalMesh DataInterfaceì˜ PerInstanceData
// NiagaraDataInterfaceSkeletalMesh.h:552-684

struct FNDISkeletalMesh_InstanceData
{
    // 1. ì™¸ë¶€ ë¦¬ì†ŒìŠ¤ ì°¸ì¡°
    TWeakObjectPtr<USceneComponent> SceneComponent;  // ìƒ˜í”Œë§í•  ì»´í¬ë„ŒíŠ¸
    TWeakObjectPtr<USkeletalMesh> SkeletalMesh;      // ë©”ì‹œ ì—ì…‹

    // 2. ì‚¬ìš©ì íŒŒë¼ë¯¸í„° ë°”ì¸ë”©
    FNiagaraParameterDirectBinding<UObject*> UserParamBinding;
    TWeakObjectPtr<USceneComponent> CachedAttachParent;
    UObject* CachedUserParam;

    // 3. Skinning ë°ì´í„° í•¸ë“¤
    FSkeletalMeshSkinningDataHandle SkinningData;  // CPU Skinning ìºì‹œ
    FSkeletalMeshUvMappingHandle UvMapping;        // UV Mapping ë°ì´í„°
    FSkeletalMeshConnectivityHandle Connectivity;  // ì¸ì ‘ ì •ë³´

    // 4. ìƒ˜í”Œë§ ì„¤ì •
    TArray<int32> SamplingRegionIndices;           // Sampling Region ì¸ë±ìŠ¤
    FSkeletalMeshSamplingRegionAreaWeightedSampler SamplingRegionAreaWeightedSampler;

    // 5. Transform ìºì‹œ
    FMatrix Transform;                  // í˜„ì¬ í”„ë ˆì„ Transform
    FMatrix TransformInverseTransposed; // Normal/Tangent ë³€í™˜ìš©
    FMatrix PrevTransform;              // ì´ì „ í”„ë ˆì„ Transform
    float DeltaSeconds;                 // Transform ê°„ ì‹œê°„ì°¨

    // 6. Bounds ì •ë³´
    FVector3f PreSkinnedLocalBoundsCenter;
    FVector3f PreSkinnedLocalBoundsExtents;

    // 7. í•„í„°ë§ ì •ë³´
    int32 ExcludedBoneIndex;
    int32 NumFilteredBones;
    int32 NumUnfilteredBones;
    TArray<uint16> FilteredAndUnfilteredBones;

    // 8. Socket ì •ë³´
    struct FCachedSocketInfo
    {
        FTransform3f Transform;
        int32 BoneIdx;
    };
    TArray<FCachedSocketInfo> FilteredSocketInfo;
    int32 FilteredSocketBoneOffset;
    uint32 FilteredSocketTransformsIndex;
    TStaticArray<TArray<FTransform3f>, 2> FilteredSocketTransforms;  // Double buffering

    // 9. GPU ë¦¬ì†ŒìŠ¤
    FSkeletalMeshGpuSpawnStaticBuffers* MeshGpuSpawnStaticBuffers;
    FSkeletalMeshGpuDynamicBufferProxy* MeshGpuSpawnDynamicBuffers;

    // 10. ìƒíƒœ í”Œë˜ê·¸
    uint32 ChangeId;
    uint32 bComponentValid : 1;
    uint32 bMeshValid : 1;
    uint32 bIsGpuUniformlyDistributedSampling : 1;
    uint32 bReadDeformedGeometry : 1;
    uint32 bUnlimitedBoneInfluences : 1;
    bool bAllowCPUMeshDataAccess;
    bool bResetOnLODStreamedIn;
    int32 CachedLODIdx;

    // ë©”ì„œë“œ:
    bool ResetRequired(UNiagaraDataInterfaceSkeletalMesh* Interface,
                      FNiagaraSystemInstance* SystemInstance) const;
    bool Init(UNiagaraDataInterfaceSkeletalMesh* Interface,
             FNiagaraSystemInstance* SystemInstance);
    bool Tick(UNiagaraDataInterfaceSkeletalMesh* Interface,
             FNiagaraSystemInstance* SystemInstance,
             float InDeltaSeconds);
    void Release();
};
```

**ğŸ“‚ ì†ŒìŠ¤ ê²€ì¦:** `NiagaraDataInterfaceSkeletalMesh.h:552-684`

##### PerInstanceData ë©”ëª¨ë¦¬ ê´€ë¦¬
```cpp
// âœ… SystemInstanceì—ì„œ PerInstanceData ê´€ë¦¬
// FNiagaraSystemInstance::InitDataInterfaces()

void FNiagaraSystemInstance::InitDataInterfaces()
{
    for (const auto& DIInfo : DataInterfaceInstanceDataOffsets)
    {
        UNiagaraDataInterface* Interface = DIInfo.Interface;

        // 1. ì¸ìŠ¤í„´ìŠ¤ ë°ì´í„° í¬ê¸° ì¡°íšŒ
        int32 Size = Interface->PerInstanceDataSize();
        if (Size > 0)
        {
            // 2. ë©”ëª¨ë¦¬ í• ë‹¹ (ì—°ì†ëœ ë©”ëª¨ë¦¬ ë¸”ë¡ì—ì„œ)
            uint8* DataPtr = DataInterfaceInstanceDataStorage.GetData() + DIInfo.Offset;

            // 3. Placement Newë¡œ ì´ˆê¸°í™”
            // PerInstanceDataëŠ” UObjectê°€ ì•„ë‹ˆë¯€ë¡œ ì§ì ‘ ë©”ëª¨ë¦¬ ê´€ë¦¬
            bool bSuccess = Interface->InitPerInstanceData(DataPtr, this);

            if (!bSuccess)
            {
                // ì´ˆê¸°í™” ì‹¤íŒ¨ â†’ ì‹œìŠ¤í…œ ë¹„í™œì„±í™”
                UE_LOG(LogNiagara, Warning,
                      TEXT("Failed to init data interface %s"),
                      *Interface->GetName());
                // ... ì‹œìŠ¤í…œ ë¦¬ì…‹ ...
            }
        }
    }
}

void FNiagaraSystemInstance::CleanupDataInterfaces()
{
    for (const auto& DIInfo : DataInterfaceInstanceDataOffsets)
    {
        UNiagaraDataInterface* Interface = DIInfo.Interface;
        int32 Size = Interface->PerInstanceDataSize();

        if (Size > 0)
        {
            uint8* DataPtr = DataInterfaceInstanceDataStorage.GetData() + DIInfo.Offset;

            // ì†Œë©¸ì ëª…ì‹œì  í˜¸ì¶œ
            Interface->DestroyPerInstanceData(DataPtr, this);

            // ë©”ëª¨ë¦¬ëŠ” TArray ì†Œë©¸ ì‹œ ìë™ í•´ì œ
        }
    }
}
```

**í•µì‹¬ í¬ì¸íŠ¸:**
1. **Placement New ì‚¬ìš©**: UObjectê°€ ì•„ë‹ˆë¯€ë¡œ ì§ì ‘ ë©”ëª¨ë¦¬ ê´€ë¦¬
2. **ì—°ì† ë©”ëª¨ë¦¬ í• ë‹¹**: ëª¨ë“  DIì˜ PerInstanceDataë¥¼ í•˜ë‚˜ì˜ TArrayì— ì €ì¥
3. **ëª…ì‹œì  ì†Œë©¸ì í˜¸ì¶œ**: `DestroyPerInstanceData()`ì—ì„œ `~InstanceData()` í˜¸ì¶œ í•„ìš”

---

#### ğŸ”€ RenderThread Proxy íŒ¨í„´ (RenderThread Proxy Pattern)
##### GameThreadì™€ RenderThread ë°ì´í„° íë¦„
```
GameThreadì™€ RenderThread ê°„ ë°ì´í„° ì „ë‹¬:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         GameThread                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  [Tick ì‹œì‘]                                                             â”‚
â”‚  1. UNiagaraDataInterface::PerInstanceTick()                            â”‚
â”‚     - ê²Œì„ ë¡œì§ ì—…ë°ì´íŠ¸                                                  â”‚
â”‚     - ì™¸ë¶€ ë¦¬ì†ŒìŠ¤ ì°¸ì¡° ê°±ì‹  (ì˜ˆ: SkeletalMeshComponent)                  â”‚
â”‚     - PerInstanceData ê°±ì‹                                                â”‚
â”‚                                                                         â”‚
â”‚  2. ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰ (CPU)                                                 â”‚
â”‚     - VectorVM::Exec()                                                  â”‚
â”‚     - GetVMExternalFunction() í˜¸ì¶œëœ í•¨ìˆ˜ ì‹¤í–‰                           â”‚
â”‚                                                                         â”‚
â”‚  3. GPU ì‹œë®¬ë ˆì´ì…˜ ì¤€ë¹„ (GPU ì—ë¯¸í„°ë§Œ)                                    â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚     â”‚  ProvidePerInstanceDataForRenderThread() í˜¸ì¶œ         â”‚          â”‚
â”‚     â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚          â”‚
â”‚     â”‚  â”‚  // DataForRenderThread: ì „ë‹¬í•  ë©”ëª¨ë¦¬      â”‚      â”‚          â”‚
â”‚     â”‚  â”‚  // PerInstanceData: ì†ŒìŠ¤ ë°ì´í„°            â”‚      â”‚          â”‚
â”‚     â”‚  â”‚                                            â”‚      â”‚          â”‚
â”‚     â”‚  â”‚  void ProvidePerInstanceDataForRenderThread(â”‚      â”‚          â”‚
â”‚     â”‚  â”‚      void* DataForRenderThread,            â”‚      â”‚          â”‚
â”‚     â”‚  â”‚      void* PerInstanceData,                â”‚      â”‚          â”‚
â”‚     â”‚  â”‚      const FNiagaraSystemInstanceID& SystemInstance)â”‚      â”‚
â”‚     â”‚  â”‚  {                                         â”‚      â”‚          â”‚
â”‚     â”‚  â”‚    FMyRTData* RTData = (FMyRTData*)DataForRenderThread;â”‚  â”‚
â”‚     â”‚  â”‚    FMyInstanceData* InstData = (FMyInstanceData*)PerInstanceData;â”‚
â”‚     â”‚  â”‚                                            â”‚      â”‚          â”‚
â”‚     â”‚  â”‚    // GPU ë¦¬ì†ŒìŠ¤ í•¸ë“¤ ë³µì‚¬                  â”‚      â”‚          â”‚
â”‚     â”‚  â”‚    RTData->TextureRHI = InstData->Texture->GetResource()->TextureRHI;â”‚
â”‚     â”‚  â”‚    RTData->Transform = InstData->Transform;â”‚      â”‚          â”‚
â”‚     â”‚  â”‚    RTData->bIsValid = InstData->bIsValid;  â”‚      â”‚          â”‚
â”‚     â”‚  â”‚  }                                         â”‚      â”‚          â”‚
â”‚     â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚          â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  4. Enqueue Render Command                                              â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚     â”‚  ENQUEUE_RENDER_COMMAND(FNiagaraUpdateDIProxy)(      â”‚          â”‚
â”‚     â”‚      [DataForRenderThread, SystemInstanceID](        â”‚          â”‚
â”‚     â”‚       FRHICommandListImmediate& RHICmdList)          â”‚          â”‚
â”‚     â”‚      {                                               â”‚          â”‚
â”‚     â”‚        // RenderThreadì—ì„œ ì‹¤í–‰ë¨                    â”‚          â”‚
â”‚     â”‚        Proxy->ConsumePerInstanceDataFromGameThread( â”‚          â”‚
â”‚     â”‚            DataForRenderThread,                      â”‚          â”‚
â”‚     â”‚            SystemInstanceID                          â”‚          â”‚
â”‚     â”‚        );                                            â”‚          â”‚
â”‚     â”‚      }                                               â”‚          â”‚
â”‚     â”‚  );                                                  â”‚          â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“ (Render Command Queue)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        RenderThread                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  [Render Command ì‹¤í–‰]                                                   â”‚
â”‚  5. FNiagaraDataInterfaceProxy::ConsumePerInstanceDataFromGameThread()â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚     â”‚  void ConsumePerInstanceDataFromGameThread(          â”‚          â”‚
â”‚     â”‚      void* PerInstanceData,                          â”‚          â”‚
â”‚     â”‚      const FNiagaraSystemInstanceID& Instance)       â”‚          â”‚
â”‚     â”‚  {                                                   â”‚          â”‚
â”‚     â”‚    FMyRTData* RTData = (FMyRTData*)PerInstanceData; â”‚          â”‚
â”‚     â”‚                                                      â”‚          â”‚
â”‚     â”‚    // Proxy ë‚´ë¶€ ë§µì— ì €ì¥                           â”‚          â”‚
â”‚     â”‚    FMyProxyData& ProxyData =                        â”‚          â”‚
â”‚     â”‚        SystemInstancesToProxyData_RT.FindOrAdd(Instance);â”‚     â”‚
â”‚     â”‚                                                      â”‚          â”‚
â”‚     â”‚    // ë°ì´í„° ë³µì‚¬                                     â”‚          â”‚
â”‚     â”‚    ProxyData.TextureRHI = RTData->TextureRHI;       â”‚          â”‚
â”‚     â”‚    ProxyData.Transform = RTData->Transform;         â”‚          â”‚
â”‚     â”‚    ProxyData.bIsValid = RTData->bIsValid;           â”‚          â”‚
â”‚     â”‚  }                                                   â”‚          â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  [Compute Shader Dispatch]                                              â”‚
â”‚  6. SetShaderParameters() í˜¸ì¶œ                                           â”‚
â”‚     - Proxy ë°ì´í„°ë¥¼ Shader íŒŒë¼ë¯¸í„°ë¡œ ë°”ì¸ë”©                            â”‚
â”‚     - GPU ë¦¬ì†ŒìŠ¤ ì „ë‹¬                                                    â”‚
â”‚                                                                         â”‚
â”‚  7. GPU Compute Shader ì‹¤í–‰                                              â”‚
â”‚     - HLSL ì½”ë“œì—ì„œ íŒŒë¼ë¯¸í„° ì ‘ê·¼                                        â”‚
â”‚     - Texture, Buffer ìƒ˜í”Œë§                                             â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

##### ì‹¤ì œ êµ¬í˜„ ì˜ˆì‹œ: UNiagaraDataInterfaceRenderTarget2D
```cpp
// âœ… GameThreadì—ì„œ RenderThreadë¡œ ë°ì´í„° ì „ë‹¬ ì˜ˆì‹œ
// NiagaraDataInterfaceRenderTarget2D.h

// 1. GameThread ì¸ìŠ¤í„´ìŠ¤ ë°ì´í„°
struct FRenderTarget2DRWInstanceData_GameThread
{
    bool bReleaseResources = false;
    FIntPoint Size = FIntPoint(EForceInit::ForceInitToZero);
    ETextureRenderTargetFormat Format = RTF_RGBA16f;
    TextureFilter Filter = TextureFilter::TF_Default;
    ENiagaraMipMapGeneration MipMapGeneration = ENiagaraMipMapGeneration::Disabled;
    ENiagaraMipMapGenerationType MipMapGenerationType = ENiagaraMipMapGenerationType::Linear;

    bool bManagedTexture = false;
    UTextureRenderTarget2D* TargetTexture = nullptr;

    FNiagaraParameterDirectBinding<UObject*> RTUserParamBinding;
};

// 2. RenderThread Proxy ë°ì´í„°
struct FRenderTarget2DRWInstanceData_RenderThread
{
    FIntPoint Size = FIntPoint(EForceInit::ForceInitToZero);
    int MipLevels = 0;
    ENiagaraMipMapGeneration MipMapGeneration = ENiagaraMipMapGeneration::Disabled;
    ENiagaraMipMapGenerationType MipMapGenerationType = ENiagaraMipMapGenerationType::Linear;
    bool bRebuildMips = false;
    bool bReadThisFrame = false;
    bool bWroteThisFrame = false;

    FSamplerStateRHIRef SamplerStateRHI;
    FTextureRHIRef TextureRHI;

    // RenderGraph Transient ë¦¬ì†ŒìŠ¤
    FRDGTextureRef TransientRDGTexture = nullptr;
    FRDGTextureSRVRef TransientRDGSRV = nullptr;
    FRDGTextureUAVRef TransientRDGUAV = nullptr;
};

// 3. Proxy í´ë˜ìŠ¤
struct FNiagaraDataInterfaceProxyRenderTarget2DProxy : public FNiagaraDataInterfaceProxyRW
{
    // RenderThreadì—ì„œ ê° SystemInstanceë³„ ë°ì´í„° ì €ì¥
    TMap<FNiagaraSystemInstanceID, FRenderTarget2DRWInstanceData_RenderThread>
        SystemInstancesToProxyData_RT;

    virtual void ConsumePerInstanceDataFromGameThread(
        void* PerInstanceData,
        const FNiagaraSystemInstanceID& Instance) override
    {
        // RenderThreadì—ì„œ í˜¸ì¶œë¨!
        // PerInstanceDataëŠ” ì´ë¯¸ ë³µì‚¬ëœ ë°ì´í„°

        // ... êµ¬í˜„ì€ ë³´í†µ ë¹„ì–´ìˆìŒ (ë‹¤ë¥¸ ë©”ì»¤ë‹ˆì¦˜ ì‚¬ìš©) ...
    }

    virtual void PostStage(const FNDIGpuComputePostStageContext& Context) override
    {
        // Simulation Stage ì¢…ë£Œ í›„ ì²˜ë¦¬
        // ì˜ˆ: MipMap ìƒì„±, UAV Barrier ë“±
    }

    virtual void PostSimulate(const FNDIGpuComputePostSimulateContext& Context) override
    {
        // ì „ì²´ ì‹œë®¬ë ˆì´ì…˜ ì¢…ë£Œ í›„ ì •ë¦¬
    }
};
```

**ğŸ“‚ ì†ŒìŠ¤ ê²€ì¦:** `NiagaraDataInterfaceRenderTarget2D.h:18-75`

##### Proxy ë°ì´í„° ì „ë‹¬ ìµœì í™”
```cpp
// âœ… ì‹¤ì œ ë°ì´í„° ì „ë‹¬ ë°©ë²• (ë‘ ê°€ì§€ íŒ¨í„´)

// íŒ¨í„´ 1: ProvidePerInstanceDataForRenderThread ì‚¬ìš© (ê¶Œì¥)
class UMyDataInterface : public UNiagaraDataInterface
{
public:
    virtual int32 PerInstanceDataPassedToRenderThreadSize() const override
    {
        return sizeof(FMyRTData);  // 16ë°”ì´íŠ¸ ì •ë ¬ í•„ìˆ˜!
    }

    virtual void ProvidePerInstanceDataForRenderThread(
        void* DataForRenderThread,
        void* PerInstanceData,
        const FNiagaraSystemInstanceID& SystemInstance) override
    {
        FMyRTData* RTData = static_cast<FMyRTData*>(DataForRenderThread);
        FMyInstanceData* InstData = static_cast<FMyInstanceData*>(PerInstanceData);

        // âœ… ìµœì†Œí•œì˜ ë°ì´í„°ë§Œ ë³µì‚¬
        RTData->Transform = InstData->Transform;
        RTData->TextureRHI = InstData->Texture ?
            InstData->Texture->GetResource()->TextureRHI : nullptr;
        RTData->bIsValid = InstData->bIsValid;

        // âŒ í° ë°°ì—´ ë³µì‚¬ëŠ” í”¼í•˜ê¸°!
        // RTData->LargeArray = InstData->LargeArray;  // ëŠë¦¼!
    }
};

// íŒ¨í„´ 2: SystemInstancesToProxyData_GT ì‚¬ìš© (RenderTarget ë“±)
class UMyDataInterface : public UNiagaraDataInterface
{
    // GameThreadì—ì„œ ì§ì ‘ Proxy Data ê´€ë¦¬
    TMap<FNiagaraSystemInstanceID, FMyInstanceData*> SystemInstancesToProxyData_GT;

public:
    virtual bool PerInstanceTick(
        void* PerInstanceData,
        FNiagaraSystemInstance* SystemInstance,
        float DeltaSeconds) override
    {
        FMyInstanceData* InstData = static_cast<FMyInstanceData*>(PerInstanceData);

        // GameThread ë§µì— ë“±ë¡
        SystemInstancesToProxyData_GT.FindOrAdd(SystemInstance->GetId()) = InstData;

        return false;
    }

    // RenderThreadì—ì„œ GameThread ë§µ ì°¸ì¡°
    // (ë§¤ìš° ì¡°ì‹¬í•´ì„œ ì‚¬ìš©! Thread-safe ë³´ì¥ í•„ìš”)
};
```

**ì¤‘ìš” ì œì•½ì‚¬í•­:**
1. **16ë°”ì´íŠ¸ ì •ë ¬**: `PerInstanceDataPassedToRenderThreadSize()`ëŠ” 16ì˜ ë°°ìˆ˜ì—¬ì•¼ í•¨
2. **ë³µì‚¬ ë¹„ìš©**: ë§¤ í”„ë ˆì„ ë³µì‚¬ë˜ë¯€ë¡œ ìµœì†Œí•œì˜ ë°ì´í„°ë§Œ ì „ë‹¬
3. **RHI ë¦¬ì†ŒìŠ¤**: `FTextureRHIRef`, `FBufferRHIRef` ë“±ì€ ë³µì‚¬ ê°€ëŠ¥ (ì°¸ì¡° ì¹´ìš´íŒ…)
4. **UObject í¬ì¸í„°**: RenderThreadë¡œ ì „ë‹¬ ë¶ˆê°€! (TWeakObjectPtrë„ ì•ˆì „í•˜ì§€ ì•ŠìŒ)

---

#### ğŸ­ ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸ ë¶„ë¥˜ (Execution Context Classification)
##### Instance vs PerStage ì‹¤í–‰
```
DataInterface í•¨ìˆ˜ ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                         â”‚
â”‚  [Instance ì»¨í…ìŠ¤íŠ¸] - ì „ì²´ ì‹œìŠ¤í…œ/ì—ë¯¸í„°ì— ëŒ€í•´ 1íšŒ ì‹¤í–‰                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  ì‹¤í–‰ ì‹œì : ì‹œìŠ¤í…œ ì´ˆê¸°í™”, ì—ë¯¸í„° ìŠ¤í°, í”„ë ˆì„ Tick        â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ì˜ˆì‹œ í•¨ìˆ˜:                                               â”‚          â”‚
â”‚  â”‚  - InitPerInstanceData()                                 â”‚          â”‚
â”‚  â”‚  - PerInstanceTick()                                     â”‚          â”‚
â”‚  â”‚  - PerInstanceTickPostSimulate()                         â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  íŠ¹ì§•:                                                    â”‚          â”‚
â”‚  â”‚  - íŒŒí‹°í´ ê°œìˆ˜ì™€ ë¬´ê´€í•˜ê²Œ 1íšŒë§Œ ì‹¤í–‰                      â”‚          â”‚
â”‚  â”‚  - ì‹œìŠ¤í…œ ë ˆë²¨ ë°ì´í„° ì—…ë°ì´íŠ¸                            â”‚          â”‚
â”‚  â”‚  - ì˜ˆ: Transform ê°±ì‹ , ë¦¬ì†ŒìŠ¤ ë¡œë“œ                        â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  [PerStage ì»¨í…ìŠ¤íŠ¸] - Simulation Stageë³„ë¡œ ì‹¤í–‰                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  ì‹¤í–‰ ì‹œì : ê° Simulation Stage ì‹œì‘/ì¢…ë£Œ ì‹œ              â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ì˜ˆì‹œ í•¨ìˆ˜:                                               â”‚          â”‚
â”‚  â”‚  - PreStageTick(FNDICpuPreStageContext&)                 â”‚          â”‚
â”‚  â”‚  - PostStageTick(FNDICpuPostStageContext&)               â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  GPU ë²„ì „:                                                â”‚          â”‚
â”‚  â”‚  - PreStage(FNDIGpuComputePreStageContext&)              â”‚          â”‚
â”‚  â”‚  - PostStage(FNDIGpuComputePostStageContext&)            â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  íŠ¹ì§•:                                                    â”‚          â”‚
â”‚  â”‚  - ê° Stageë§ˆë‹¤ ì‹¤í–‰ (ParticleSpawn, ParticleUpdate ë“±)  â”‚          â”‚
â”‚  â”‚  - Stageë³„ ì„¤ì • ë³€ê²½ ê°€ëŠ¥                                 â”‚          â”‚
â”‚  â”‚  - ì˜ˆ: Grid Clear, ë²„í¼ ìŠ¤ì™‘                              â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  [PerParticle ì»¨í…ìŠ¤íŠ¸] - ê° íŒŒí‹°í´ë§ˆë‹¤ ì‹¤í–‰                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  ì‹¤í–‰ ì‹œì : Script ì‹¤í–‰ ì¤‘ (VectorVM ë˜ëŠ” Compute Shader) â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ì˜ˆì‹œ í•¨ìˆ˜:                                               â”‚          â”‚
â”‚  â”‚  - GetVMExternalFunction()ì—ì„œ ë°˜í™˜ëœ í•¨ìˆ˜                â”‚          â”‚
â”‚  â”‚  - HLSL í•¨ìˆ˜ (GPU)                                       â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  íŠ¹ì§•:                                                    â”‚          â”‚
â”‚  â”‚  - íŒŒí‹°í´ ìˆ˜ë§Œí¼ ì‹¤í–‰ (NíšŒ)                               â”‚          â”‚
â”‚  â”‚  - ê° íŒŒí‹°í´ì˜ ì†ì„± ê³„ì‚°                                  â”‚          â”‚
â”‚  â”‚  - ì˜ˆ: Texture ìƒ˜í”Œë§, ìœ„ì¹˜ ê³„ì‚°                          â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

##### PreStage/PostStage í™œìš© ì˜ˆì‹œ
```cpp
// âœ… Grid2DCollection: Stageë³„ Clear ì²˜ë¦¬
class UNiagaraDataInterfaceGrid2DCollection : public UNiagaraDataInterfaceRWBase
{
public:
    // Gridë¥¼ Clearí• ì§€ ì—¬ë¶€
    UPROPERTY(EditAnywhere, Category = "Grid")
    bool ClearBeforeNonIterationStage;

    // CPU PreStage
    virtual void PreStageTick(FNDICpuPreStageContext& Context) override
    {
        if (ClearBeforeNonIterationStage && !Context.IsIterationStage())
        {
            // Non-Iteration Stage ì‹œì‘ ì „ Grid Clear
            FMyInstanceData* InstData = Context.GetPerInstanceData<FMyInstanceData>();
            ClearGrid(InstData->GridBuffer);
        }
    }

    // GPU PreStage
    virtual void PreStage(const FNDIGpuComputePreStageContext& Context) override
    {
        if (ClearBeforeNonIterationStage && !Context.IsIterationStage())
        {
            // GPUì—ì„œ Clear Compute Shader ë””ìŠ¤íŒ¨ì¹˜
            FRDGBuilder& GraphBuilder = Context.GetGraphBuilder();
            FRDGTextureRef GridTexture = ...;

            AddClearRenderTargetPass(GraphBuilder, GridTexture, FLinearColor::Black);
        }
    }
};

// âœ… RenderTarget2D: PostStageì—ì„œ MipMap ìƒì„±
class UNiagaraDataInterfaceRenderTarget2D : public UNiagaraDataInterfaceRWBase
{
public:
    virtual void PostStage(const FNDIGpuComputePostStageContext& Context) override
    {
        const FNiagaraDataInterfaceProxyRenderTarget2DProxy& DIProxy =
            Context.GetProxy<FNiagaraDataInterfaceProxyRenderTarget2DProxy>();

        FRenderTarget2DRWInstanceData_RenderThread* ProxyData =
            DIProxy.SystemInstancesToProxyData_RT.Find(Context.GetSystemInstanceID());

        if (ProxyData && ProxyData->bWroteThisFrame)
        {
            // Stage ì¢…ë£Œ í›„ MipMap ìƒì„±
            if (ProxyData->MipMapGeneration != ENiagaraMipMapGeneration::Disabled)
            {
                FNiagaraGenerateMips::GenerateMips(
                    Context.GetGraphBuilder(),
                    ProxyData->TransientRDGTexture,
                    ProxyData->MipMapGenerationType
                );
            }

            ProxyData->bWroteThisFrame = false;
        }
    }
};
```

##### CPU vs GPU Stage Tick ë¹„êµ
| ê¸°ëŠ¥ | CPU (FNDICpuPreStageContext) | GPU (FNDIGpuComputePreStageContext) |
|-----|------------------------------|-------------------------------------|
| **ì‹¤í–‰ ìœ„ì¹˜** | GameThread | RenderThread |
| **PerInstanceData ì ‘ê·¼** | `Context.GetPerInstanceData<T>()` | Proxyë¥¼ í†µí•´ ê°„ì ‘ ì ‘ê·¼ |
| **Usage ì •ë³´** | `Context.Usage` (ScriptUsage) | `Context.GetSimStageData()` |
| **ë¦¬ì†ŒìŠ¤ ì ‘ê·¼** | ì§ì ‘ ë©”ëª¨ë¦¬ ì ‘ê·¼ ê°€ëŠ¥ | RDG (Render Dependency Graph) ì‚¬ìš© |
| **ì£¼ ìš©ë„** | ë°ì´í„° ê°±ì‹ , ì„¤ì • ë³€ê²½ | GPU ë¦¬ì†ŒìŠ¤ ì¤€ë¹„, Transition |

---

#### ğŸ› ï¸ ì‚¬ìš©ì ì •ì˜ DataInterface ì œì‘ ê°€ì´ë“œ (Custom DataInterface Creation Guide)
##### ë‹¨ê³„ë³„ êµ¬í˜„ ê°€ì´ë“œ
```cpp
// ========================================================================
// 1ë‹¨ê³„: í—¤ë” íŒŒì¼ ì‘ì„± (MyNiagaraDataInterfaceCustom.h)
// ========================================================================

#pragma once

#include "NiagaraDataInterface.h"
#include "NiagaraCommon.h"
#include "MyNiagaraDataInterfaceCustom.generated.h"

// PerInstanceData êµ¬ì¡°ì²´ ì •ì˜
struct FMyDI_InstanceData
{
    // ì¸ìŠ¤í„´ìŠ¤ë³„ë¡œ ìœ ì§€í•  ë°ì´í„°
    TWeakObjectPtr<UMyCustomResource> CustomResource;
    FTransform CachedTransform;
    TArray<float> CachedValues;

    // ì´ˆê¸°í™” í•„ìš” ì—¬ë¶€
    bool bNeedsReset = false;
};

// DataInterface í´ë˜ìŠ¤
UCLASS(EditInlineNew, Category = "DataInterface",
       meta = (DisplayName = "My Custom DI"))
class UMyNiagaraDataInterfaceCustom : public UNiagaraDataInterface
{
    GENERATED_UCLASS_BODY()

public:
    // ===== UPROPERTY: ì—ë””í„° ë…¸ì¶œ í”„ë¡œí¼í‹° =====

    /** ì»¤ìŠ¤í…€ ë¦¬ì†ŒìŠ¤ ì°¸ì¡° */
    UPROPERTY(EditAnywhere, Category = "Custom")
    TObjectPtr<UMyCustomResource> CustomResource;

    /** ì‚¬ìš©ì íŒŒë¼ë¯¸í„° ë°”ì¸ë”© */
    UPROPERTY(EditAnywhere, Category = "Custom")
    FNiagaraUserParameterBinding CustomResourceUserParameter;

    /** ìƒ˜í”Œë§ ê°•ë„ */
    UPROPERTY(EditAnywhere, Category = "Custom", meta = (ClampMin = "0", ClampMax = "1"))
    float SamplingIntensity = 1.0f;

    // ===== GPU Shader Parameters =====

    BEGIN_SHADER_PARAMETER_STRUCT(FShaderParameters, )
        SHADER_PARAMETER(float, Intensity)
        SHADER_PARAMETER(FVector3f, CustomVector)
        SHADER_PARAMETER_SRV(Buffer<float>, CustomBuffer)
    END_SHADER_PARAMETER_STRUCT()

    // ===== UObject ì¸í„°í˜ì´ìŠ¤ =====

    virtual void PostInitProperties() override;

    // ===== UNiagaraDataInterface ì¸í„°í˜ì´ìŠ¤ =====

    // ìƒëª…ì£¼ê¸°
    virtual bool InitPerInstanceData(void* PerInstanceData,
                                     FNiagaraSystemInstance* SystemInstance) override;
    virtual void DestroyPerInstanceData(void* PerInstanceData,
                                       FNiagaraSystemInstance* SystemInstance) override;
    virtual int32 PerInstanceDataSize() const override
    {
        return sizeof(FMyDI_InstanceData);
    }

    // Tick
    virtual bool PerInstanceTick(void* PerInstanceData,
                                FNiagaraSystemInstance* SystemInstance,
                                float DeltaSeconds) override;
    virtual bool HasPreSimulateTick() const override { return true; }

    // CPU ì‹¤í–‰
    virtual void GetVMExternalFunction(const FVMExternalFunctionBindingInfo& BindingInfo,
                                      void* InstanceData,
                                      FVMExternalFunction &OutFunc) override;

    // GPU ì‹¤í–‰
    virtual void BuildShaderParameters(FNiagaraShaderParametersBuilder& ShaderParametersBuilder) const override;
    virtual void SetShaderParameters(const FNiagaraDataInterfaceSetShaderParametersContext& Context) const override;

#if WITH_EDITORONLY_DATA
    virtual void GetParameterDefinitionHLSL(const FNiagaraDataInterfaceGPUParamInfo& ParamInfo,
                                           FString& OutHLSL) override;
    virtual bool GetFunctionHLSL(const FNiagaraDataInterfaceGPUParamInfo& ParamInfo,
                                const FNiagaraDataInterfaceGeneratedFunction& FunctionInfo,
                                int FunctionInstanceIndex,
                                FString& OutHLSL) override;
#endif

    // ìœ í‹¸ë¦¬í‹°
    virtual bool Equals(const UNiagaraDataInterface* Other) const override;
    virtual bool CanExecuteOnTarget(ENiagaraSimTarget Target) const override
    {
        return true;  // CPU/GPU ëª¨ë‘ ì§€ì›
    }

protected:
#if WITH_EDITORONLY_DATA
    virtual void GetFunctionsInternal(TArray<FNiagaraFunctionSignature>& OutFunctions) const override;
#endif
    virtual bool CopyToInternal(UNiagaraDataInterface* Destination) const override;

    // ===== VM í•¨ìˆ˜ êµ¬í˜„ =====

    void VMGetCustomValue(FVectorVMExternalFunctionContext& Context);
    void VMSampleCustomResource(FVectorVMExternalFunctionContext& Context);

    // ===== í•¨ìˆ˜ ì´ë¦„ ìƒìˆ˜ =====

    static const FName GetCustomValueName;
    static const FName SampleCustomResourceName;
};

// ========================================================================
// 2ë‹¨ê³„: CPP íŒŒì¼ êµ¬í˜„ (MyNiagaraDataInterfaceCustom.cpp)
// ========================================================================

#include "MyNiagaraDataInterfaceCustom.h"
#include "NiagaraShaderParametersBuilder.h"

// í•¨ìˆ˜ ì´ë¦„ ì •ì˜
const FName UMyNiagaraDataInterfaceCustom::GetCustomValueName(TEXT("GetCustomValue"));
const FName UMyNiagaraDataInterfaceCustom::SampleCustomResourceName(TEXT("SampleCustomResource"));

UMyNiagaraDataInterfaceCustom::UMyNiagaraDataInterfaceCustom(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
{
    // Proxy ìƒì„± (GPU ì‚¬ìš© ì‹œ í•„ìš”)
    Proxy.Reset(new FNiagaraDataInterfaceProxyMyCustom());
}

void UMyNiagaraDataInterfaceCustom::PostInitProperties()
{
    Super::PostInitProperties();

    // ì´ˆê¸°í™” ë¡œì§
    if (HasAnyFlags(RF_ClassDefaultObject))
    {
        // CDO ì´ˆê¸°í™”
        ENiagaraTypeRegistryFlags DIFlags =
            ENiagaraTypeRegistryFlags::AllowAnyVariable |
            ENiagaraTypeRegistryFlags::AllowParameter;
        FNiagaraTypeRegistry::Register(
            FNiagaraTypeDefinition(GetClass()), DIFlags);
    }
}

// ========================================================================
// 3ë‹¨ê³„: GetFunctionsInternal - ì œê³µ í•¨ìˆ˜ ëª©ë¡ ì •ì˜
// ========================================================================

#if WITH_EDITORONLY_DATA
void UMyNiagaraDataInterfaceCustom::GetFunctionsInternal(
    TArray<FNiagaraFunctionSignature>& OutFunctions) const
{
    // í•¨ìˆ˜ 1: GetCustomValue
    {
        FNiagaraFunctionSignature Sig;
        Sig.Name = GetCustomValueName;
        Sig.bMemberFunction = true;
        Sig.bRequiresContext = false;
        Sig.bSupportsGPU = true;
        Sig.bSupportsCPU = true;

        // ì…ë ¥ íŒŒë¼ë¯¸í„°
        Sig.Inputs.Add(FNiagaraVariable(
            FNiagaraTypeDefinition(GetClass()), TEXT("CustomDI")));
        Sig.Inputs.Add(FNiagaraVariable(
            FNiagaraTypeDefinition::GetIntDef(), TEXT("Index")));

        // ì¶œë ¥ íŒŒë¼ë¯¸í„°
        Sig.Outputs.Add(FNiagaraVariable(
            FNiagaraTypeDefinition::GetFloatDef(), TEXT("Value")));

        Sig.SetDescription(LOCTEXT("GetCustomValueDesc",
            "Gets a custom value at the specified index."));

        OutFunctions.Add(Sig);
    }

    // í•¨ìˆ˜ 2: SampleCustomResource
    {
        FNiagaraFunctionSignature Sig;
        Sig.Name = SampleCustomResourceName;
        Sig.bMemberFunction = true;
        Sig.bRequiresContext = false;
        Sig.bSupportsGPU = true;
        Sig.bSupportsCPU = true;

        Sig.Inputs.Add(FNiagaraVariable(
            FNiagaraTypeDefinition(GetClass()), TEXT("CustomDI")));
        Sig.Inputs.Add(FNiagaraVariable(
            FNiagaraTypeDefinition::GetVec3Def(), TEXT("Position")));

        Sig.Outputs.Add(FNiagaraVariable(
            FNiagaraTypeDefinition::GetColorDef(), TEXT("Color")));

        Sig.SetDescription(LOCTEXT("SampleCustomResourceDesc",
            "Samples the custom resource at the given position."));

        OutFunctions.Add(Sig);
    }
}
#endif

// ========================================================================
// 4ë‹¨ê³„: InitPerInstanceData - ì¸ìŠ¤í„´ìŠ¤ë³„ ë°ì´í„° ì´ˆê¸°í™”
// ========================================================================

bool UMyNiagaraDataInterfaceCustom::InitPerInstanceData(
    void* PerInstanceData,
    FNiagaraSystemInstance* SystemInstance)
{
    // Placement Newë¡œ êµ¬ì¡°ì²´ ì´ˆê¸°í™”
    FMyDI_InstanceData* InstData = new (PerInstanceData) FMyDI_InstanceData();

    // ì‚¬ìš©ì íŒŒë¼ë¯¸í„°ì—ì„œ ë¦¬ì†ŒìŠ¤ ê°€ì ¸ì˜¤ê¸°
    if (CustomResourceUserParameter.Parameter.IsValid())
    {
        UObject* UserObject = CustomResourceUserParameter.GetValue<UObject*>();
        InstData->CustomResource = Cast<UMyCustomResource>(UserObject);
    }
    else
    {
        // ê¸°ë³¸ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©
        InstData->CustomResource = CustomResource;
    }

    // ë¦¬ì†ŒìŠ¤ ê²€ì¦
    if (!InstData->CustomResource.IsValid())
    {
        UE_LOG(LogNiagara, Warning,
            TEXT("CustomResource is null in %s"),
            *SystemInstance->GetSystem()->GetName());
        return false;  // ì´ˆê¸°í™” ì‹¤íŒ¨ â†’ ì‹œìŠ¤í…œ ë¹„í™œì„±í™”
    }

    // ìºì‹œ ì´ˆê¸°í™”
    InstData->CachedValues.Reserve(100);
    InstData->bNeedsReset = false;

    return true;  // ì„±ê³µ
}

void UMyNiagaraDataInterfaceCustom::DestroyPerInstanceData(
    void* PerInstanceData,
    FNiagaraSystemInstance* SystemInstance)
{
    FMyDI_InstanceData* InstData = static_cast<FMyDI_InstanceData*>(PerInstanceData);

    // ëª…ì‹œì  ì†Œë©¸ì í˜¸ì¶œ
    InstData->~FMyDI_InstanceData();
}

// ========================================================================
// 5ë‹¨ê³„: PerInstanceTick - ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸
// ========================================================================

bool UMyNiagaraDataInterfaceCustom::PerInstanceTick(
    void* PerInstanceData,
    FNiagaraSystemInstance* SystemInstance,
    float DeltaSeconds)
{
    FMyDI_InstanceData* InstData = static_cast<FMyDI_InstanceData*>(PerInstanceData);

    // Transform ìºì‹±
    if (USceneComponent* AttachComponent = SystemInstance->GetAttachComponent())
    {
        InstData->CachedTransform = AttachComponent->GetComponentTransform();
    }

    // ë¦¬ì†ŒìŠ¤ ì—…ë°ì´íŠ¸ ì²´í¬
    if (InstData->CustomResource.IsValid())
    {
        if (InstData->CustomResource->HasDataChanged())
        {
            InstData->bNeedsReset = true;
        }
    }

    // true ë°˜í™˜ ì‹œ ì¸ìŠ¤í„´ìŠ¤ ë¦¬ì…‹
    return InstData->bNeedsReset;
}

// ========================================================================
// 6ë‹¨ê³„: GetVMExternalFunction - CPU í•¨ìˆ˜ ë°”ì¸ë”©
// ========================================================================

void UMyNiagaraDataInterfaceCustom::GetVMExternalFunction(
    const FVMExternalFunctionBindingInfo& BindingInfo,
    void* InstanceData,
    FVMExternalFunction &OutFunc)
{
    if (BindingInfo.Name == GetCustomValueName)
    {
        OutFunc = FVMExternalFunction::CreateUObject(
            this, &UMyNiagaraDataInterfaceCustom::VMGetCustomValue);
    }
    else if (BindingInfo.Name == SampleCustomResourceName)
    {
        OutFunc = FVMExternalFunction::CreateUObject(
            this, &UMyNiagaraDataInterfaceCustom::VMSampleCustomResource);
    }
}

// ========================================================================
// 7ë‹¨ê³„: VM í•¨ìˆ˜ êµ¬í˜„
// ========================================================================

void UMyNiagaraDataInterfaceCustom::VMGetCustomValue(
    FVectorVMExternalFunctionContext& Context)
{
    // PerInstanceData ê°€ì ¸ì˜¤ê¸°
    FMyDI_InstanceData* InstData = static_cast<FMyDI_InstanceData*>(Context.GetUserPtrTable()[0]);

    // ì…ë ¥ íŒŒë¼ë¯¸í„° í•¸ë“¤ëŸ¬
    VectorVM::FExternalFuncInputHandler<int32> IndexParam(Context);

    // ì¶œë ¥ íŒŒë¼ë¯¸í„° í•¸ë“¤ëŸ¬
    VectorVM::FExternalFuncRegisterHandler<float> OutValue(Context);

    // ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤(íŒŒí‹°í´) ìˆœíšŒ
    for (int32 i = 0; i < Context.GetNumInstances(); ++i)
    {
        int32 Index = IndexParam.GetAndAdvance();

        // ë²”ìœ„ ì²´í¬
        float Value = 0.0f;
        if (InstData->CachedValues.IsValidIndex(Index))
        {
            Value = InstData->CachedValues[Index];
        }

        // ê²°ê³¼ ì“°ê¸°
        *OutValue.GetDestAndAdvance() = Value * SamplingIntensity;
    }
}

void UMyNiagaraDataInterfaceCustom::VMSampleCustomResource(
    FVectorVMExternalFunctionContext& Context)
{
    FMyDI_InstanceData* InstData = static_cast<FMyDI_InstanceData*>(Context.GetUserPtrTable()[0]);

    // ì…ë ¥
    VectorVM::FExternalFuncInputHandler<FVector3f> PositionParam(Context);

    // ì¶œë ¥
    VectorVM::FExternalFuncRegisterHandler<FLinearColor> OutColor(Context);

    for (int32 i = 0; i < Context.GetNumInstances(); ++i)
    {
        FVector3f Position = PositionParam.GetAndAdvance();

        FLinearColor Color = FLinearColor::Black;

        if (InstData->CustomResource.IsValid())
        {
            // ì»¤ìŠ¤í…€ ë¦¬ì†ŒìŠ¤ ìƒ˜í”Œë§
            Color = InstData->CustomResource->SampleAtPosition(FVector(Position));
        }

        *OutColor.GetDestAndAdvance() = Color;
    }
}

// ========================================================================
// 8ë‹¨ê³„: GPU Shader Parameters
// ========================================================================

void UMyNiagaraDataInterfaceCustom::BuildShaderParameters(
    FNiagaraShaderParametersBuilder& ShaderParametersBuilder) const
{
    ShaderParametersBuilder.AddNestedStruct<FShaderParameters>();
}

void UMyNiagaraDataInterfaceCustom::SetShaderParameters(
    const FNiagaraDataInterfaceSetShaderParametersContext& Context) const
{
    const FNiagaraDataInterfaceProxyMyCustom& DIProxy =
        Context.GetProxy<FNiagaraDataInterfaceProxyMyCustom>();

    FShaderParameters* Parameters =
        Context.GetParameterNestedStruct<FShaderParameters>();

    Parameters->Intensity = SamplingIntensity;
    Parameters->CustomVector = DIProxy.GetCustomVector();
    Parameters->CustomBuffer = DIProxy.GetCustomBufferSRV();
}

// ========================================================================
// 9ë‹¨ê³„: HLSL ì½”ë“œ ìƒì„±
// ========================================================================

#if WITH_EDITORONLY_DATA
void UMyNiagaraDataInterfaceCustom::GetParameterDefinitionHLSL(
    const FNiagaraDataInterfaceGPUParamInfo& ParamInfo,
    FString& OutHLSL)
{
    const FString TemplateFile = TEXT("/Plugin/FX/Niagara/Private/NiagaraDataInterfaceMyCustomTemplate.ush");
    OutHLSL += FString::Printf(TEXT("#include \"%s\"\n"), *TemplateFile);
}

bool UMyNiagaraDataInterfaceCustom::GetFunctionHLSL(
    const FNiagaraDataInterfaceGPUParamInfo& ParamInfo,
    const FNiagaraDataInterfaceGeneratedFunction& FunctionInfo,
    int FunctionInstanceIndex,
    FString& OutHLSL)
{
    if (FunctionInfo.DefinitionName == GetCustomValueName)
    {
        OutHLSL += FString::Printf(TEXT(R"(
            void %s(int Index, out float Value)
            {
                // {ParameterName}_CustomBufferëŠ” BuildShaderParametersì—ì„œ ì •ì˜ë¨
                Value = {ParameterName}_CustomBuffer[Index] * {ParameterName}_Intensity;
            }
        )"), *FunctionInfo.InstanceName);

        return true;
    }
    else if (FunctionInfo.DefinitionName == SampleCustomResourceName)
    {
        OutHLSL += FString::Printf(TEXT(R"(
            void %s(float3 Position, out float4 Color)
            {
                float3 LocalPos = Position - {ParameterName}_CustomVector;
                float Distance = length(LocalPos);

                // ê°„ë‹¨í•œ ê·¸ë¼ë””ì–¸íŠ¸
                Color = lerp(
                    float4(1, 0, 0, 1),  // Red
                    float4(0, 0, 1, 1),  // Blue
                    saturate(Distance / 100.0)
                );
            }
        )"), *FunctionInfo.InstanceName);

        return true;
    }

    return false;
}
#endif

// ========================================================================
// 10ë‹¨ê³„: Equalsì™€ CopyToInternal
// ========================================================================

bool UMyNiagaraDataInterfaceCustom::Equals(const UNiagaraDataInterface* Other) const
{
    if (!Super::Equals(Other))
        return false;

    const UMyNiagaraDataInterfaceCustom* OtherCustom =
        CastChecked<UMyNiagaraDataInterfaceCustom>(Other);

    return OtherCustom->CustomResource == CustomResource &&
           OtherCustom->SamplingIntensity == SamplingIntensity;
}

bool UMyNiagaraDataInterfaceCustom::CopyToInternal(UNiagaraDataInterface* Destination) const
{
    if (!Super::CopyToInternal(Destination))
        return false;

    UMyNiagaraDataInterfaceCustom* DestCustom =
        CastChecked<UMyNiagaraDataInterfaceCustom>(Destination);

    DestCustom->CustomResource = CustomResource;
    DestCustom->CustomResourceUserParameter = CustomResourceUserParameter;
    DestCustom->SamplingIntensity = SamplingIntensity;

    return true;
}
```

##### ì²´í¬ë¦¬ìŠ¤íŠ¸
**í•„ìˆ˜ êµ¬í˜„:**
- [ ] `GetFunctionsInternal()` - í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ ì •ì˜
- [ ] `InitPerInstanceData()` / `DestroyPerInstanceData()` - ìƒëª…ì£¼ê¸°
- [ ] `PerInstanceDataSize()` - ì¸ìŠ¤í„´ìŠ¤ ë°ì´í„° í¬ê¸°
- [ ] `GetVMExternalFunction()` - CPU í•¨ìˆ˜ ë°”ì¸ë”©
- [ ] `Equals()` / `CopyToInternal()` - ë¹„êµ/ë³µì‚¬
- [ ] `CanExecuteOnTarget()` - CPU/GPU ì§€ì› ëª…ì‹œ

**GPU ì§€ì› ì‹œ ì¶”ê°€:**
- [ ] `BuildShaderParameters()` - Shader íŒŒë¼ë¯¸í„° êµ¬ì¡°ì²´
- [ ] `SetShaderParameters()` - íŒŒë¼ë¯¸í„° ê°’ ì„¤ì •
- [ ] `GetParameterDefinitionHLSL()` - HLSL ì„ ì–¸
- [ ] `GetFunctionHLSL()` - HLSL í•¨ìˆ˜ êµ¬í˜„
- [ ] `Proxy` í´ë˜ìŠ¤ êµ¬í˜„

**ê³ ê¸‰ ê¸°ëŠ¥:**
- [ ] `PerInstanceTick()` - ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸
- [ ] `PreStageTick()` / `PostStageTick()` - Stageë³„ ì²˜ë¦¬
- [ ] `ProvidePerInstanceDataForRenderThread()` - GPU ë°ì´í„° ì „ë‹¬
- [ ] User Parameter ë°”ì¸ë”©

---

#### ğŸ“Š ì„±ëŠ¥ ë° ì£¼ì˜ì‚¬í•­ (Performance and Best Practices)
##### GPU ì§€ì› ì œì•½ì‚¬í•­
```
GPUì—ì„œ ì‚¬ìš© ë¶ˆê°€ëŠ¥í•œ ê¸°ëŠ¥:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âŒ Physics Collision (UNiagaraDataInterfaceCollisionQuery)              â”‚
â”‚  - ì´ìœ : PhysX/ChaosëŠ” CPU ì „ìš©, GPUì—ì„œ ë¬¼ë¦¬ ì¿¼ë¦¬ ë¶ˆê°€                  â”‚
â”‚  - ëŒ€ì•ˆ: AsyncGpuTrace (Ray Tracing ì‚¬ìš©)                                â”‚
â”‚                                                                         â”‚
â”‚  âŒ Audio (UNiagaraDataInterfaceAudioPlayer, AudioSpectrum ë“±)           â”‚
â”‚  - ì´ìœ : Audio Engineì€ CPU ì „ìš©                                         â”‚
â”‚  - ëŒ€ì•ˆ: CPU ì‹œë®¬ë ˆì´ì…˜ ì‚¬ìš© ë˜ëŠ” íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬                        â”‚
â”‚                                                                         â”‚
â”‚  âŒ Export (UNiagaraDataInterfaceExport)                                 â”‚
â”‚  - ì´ìœ : GPU â†’ CPU ë°ì´í„° ì „ì†¡ ì§€ì—°                                      â”‚
â”‚  - ëŒ€ì•ˆ: RenderTarget ì‚¬ìš© í›„ Readback                                   â”‚
â”‚                                                                         â”‚
â”‚  âš ï¸  SkeletalMesh (ì¼ë¶€ ê¸°ëŠ¥ë§Œ GPU ì§€ì›)                                â”‚
â”‚  - GPU ì§€ì›: GetSkinnedVertexPosition, RandomTriCoord ë“±                â”‚
â”‚  - GPU ë¯¸ì§€ì›: CPU Skinning ê¸°ë°˜ í•¨ìˆ˜, ë³µì¡í•œ í•„í„°ë§                     â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

##### ìµœì í™” íŒ
```cpp
// âœ… ì¢‹ì€ ì˜ˆ: PerInstanceData ìµœì†Œí™”
struct FMyDI_InstanceData
{
    // âœ… í•„ìˆ˜ ë°ì´í„°ë§Œ ì €ì¥
    TWeakObjectPtr<UTexture> Texture;
    FMatrix Transform;
    bool bIsValid;

    // âŒ í° ë°°ì—´ í”¼í•˜ê¸° (ìºì‹œ ë¯¸ìŠ¤ ìœ ë°œ)
    // TArray<FVector> LargeArray;  // ë‚˜ì¨!
};

// âœ… ì¢‹ì€ ì˜ˆ: VM í•¨ìˆ˜ ìµœì í™”
void VMSampleTexture(FVectorVMExternalFunctionContext& Context)
{
    // âœ… Context ë°–ì—ì„œ ê³µí†µ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
    FMyDI_InstanceData* InstData = static_cast<FMyDI_InstanceData*>(Context.GetUserPtrTable()[0]);
    UTexture* Texture = InstData->Texture.Get();

    // âŒ ë§¤ íŒŒí‹°í´ë§ˆë‹¤ í¬ì¸í„° ê°€ì ¸ì˜¤ê¸° (ëŠë¦¼!)
    // for (int32 i = 0; i < Context.GetNumInstances(); ++i)
    // {
    //     UTexture* Texture = InstData->Texture.Get();  // ë°˜ë³µ í˜¸ì¶œ!
    // }

    // âœ… ë£¨í”„ ë‚´ë¶€ì—ì„œ ìµœì†Œí•œì˜ ì‘ì—…ë§Œ
    VectorVM::FExternalFuncInputHandler<FVector2f> UVParam(Context);
    VectorVM::FExternalFuncRegisterHandler<FLinearColor> OutColor(Context);

    for (int32 i = 0; i < Context.GetNumInstances(); ++i)
    {
        FVector2f UV = UVParam.GetAndAdvance();
        FLinearColor Color = Texture->Sample(UV);  // ë¹ ë¦„
        *OutColor.GetDestAndAdvance() = Color;
    }
}

// âœ… ì¢‹ì€ ì˜ˆ: GPU Shader Parameters - ìµœì†Œ ë°ì´í„° ì „ë‹¬
void SetShaderParameters(const FNiagaraDataInterfaceSetShaderParametersContext& Context) const
{
    FShaderParameters* Parameters = Context.GetParameterNestedStruct<FShaderParameters>();

    // âœ… í•„ìˆ˜ ë°ì´í„°ë§Œ ì „ë‹¬
    Parameters->TextureSize = FIntPoint(256, 256);
    Parameters->Texture = TextureRDG;

    // âŒ ë¶ˆí•„ìš”í•œ í° ë°°ì—´ ì „ë‹¬ í”¼í•˜ê¸°
    // for (int32 i = 0; i < 1000; ++i)
    // {
    //     Parameters->LargeArray[i] = ...;  // ë„ˆë¬´ ëŠë¦¼!
    // }
}

// âœ… ì¢‹ì€ ì˜ˆ: HLSL ì½”ë“œ ìµœì í™”
bool GetFunctionHLSL(...)
{
    // âœ… ê°„ê²°í•œ HLSL ì½”ë“œ
    OutHLSL = TEXT(R"(
        void SampleTexture(float2 UV, out float4 Color)
        {
            Color = {ParameterName}_Texture.SampleLevel(
                {ParameterName}_Sampler, UV, 0);
        }
    )");

    // âŒ ë³µì¡í•œ ë¶„ê¸°ë¬¸ í”¼í•˜ê¸° (GPU ì„±ëŠ¥ ì €í•˜)
    // if (condition1) { ... }
    // else if (condition2) { ... }
    // else if (condition3) { ... }
    // â†’ ëŒ€ì‹  Lookup Table ì‚¬ìš©
}
```

##### í”í•œ ì‹¤ìˆ˜ (Common Pitfalls)
```cpp
// âŒ ë‚˜ìœ ì˜ˆ 1: PerInstanceDataì— UObject ì§ì ‘ ì €ì¥
struct FMyDI_InstanceData
{
    UTexture* Texture;  // âŒ GC ë˜ë©´ Dangling Pointer!
};

// âœ… ì˜¬ë°”ë¥¸ ë°©ë²•: TWeakObjectPtr ì‚¬ìš©
struct FMyDI_InstanceData
{
    TWeakObjectPtr<UTexture> Texture;  // âœ… ì•ˆì „
};

// âŒ ë‚˜ìœ ì˜ˆ 2: InitPerInstanceData ì‹¤íŒ¨ ì‹œ ê·¸ëƒ¥ ì§„í–‰
bool InitPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance)
{
    FMyDI_InstanceData* InstData = new (PerInstanceData) FMyDI_InstanceData();

    if (!InstData->Texture.IsValid())
    {
        // âŒ ê·¸ëƒ¥ true ë°˜í™˜ (ì‹œìŠ¤í…œì€ ê³„ì† ì‹¤í–‰ë˜ì§€ë§Œ í¬ë˜ì‹œ ìœ„í—˜!)
        return true;
    }
}

// âœ… ì˜¬ë°”ë¥¸ ë°©ë²•: ì‹¤íŒ¨ ì‹œ false ë°˜í™˜
bool InitPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance)
{
    FMyDI_InstanceData* InstData = new (PerInstanceData) FMyDI_InstanceData();

    if (!InstData->Texture.IsValid())
    {
        UE_LOG(LogNiagara, Warning, TEXT("Texture is null"));
        return false;  // âœ… ì‹œìŠ¤í…œ ë¹„í™œì„±í™”
    }

    return true;
}

// âŒ ë‚˜ìœ ì˜ˆ 3: DestroyPerInstanceDataì—ì„œ ì†Œë©¸ì í˜¸ì¶œ ì•ˆ í•¨
void DestroyPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance)
{
    // âŒ ì†Œë©¸ì í˜¸ì¶œ ì—†ì´ ê·¸ëƒ¥ ë°˜í™˜ â†’ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜!
}

// âœ… ì˜¬ë°”ë¥¸ ë°©ë²•: ëª…ì‹œì  ì†Œë©¸ì í˜¸ì¶œ
void DestroyPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance)
{
    FMyDI_InstanceData* InstData = static_cast<FMyDI_InstanceData*>(PerInstanceData);
    InstData->~FMyDI_InstanceData();  // âœ… ì†Œë©¸ì í˜¸ì¶œ
}

// âŒ ë‚˜ìœ ì˜ˆ 4: PerInstanceDataPassedToRenderThreadSizeê°€ 16ë°”ì´íŠ¸ ì •ë ¬ ì•ˆ ë¨
virtual int32 PerInstanceDataPassedToRenderThreadSize() const override
{
    return sizeof(FMyRTData);  // âŒ FMyRTDataê°€ 13ë°”ì´íŠ¸ë©´ ì—ëŸ¬!
}

// âœ… ì˜¬ë°”ë¥¸ ë°©ë²•: 16ë°”ì´íŠ¸ ì •ë ¬ ë³´ì¥
virtual int32 PerInstanceDataPassedToRenderThreadSize() const override
{
    return Align(sizeof(FMyRTData), 16);  // âœ… 16ì˜ ë°°ìˆ˜ë¡œ ì˜¬ë¦¼
}
```

---

#### ğŸ”— ê´€ë ¨ ë¬¸ì„œ (Related Documents)
- **[Core/DataInterface.md](../Core/DataInterface.md)** - DataInterface ê¸°ë³¸ ê°œë… ë° 52+ ë‚´ì¥ íƒ€ì…
- **[VectorVM.md](VectorVM.md)** - VectorVM ì‹¤í–‰ ì—”ì§„ ìƒì„¸
- **[NiagaraShader.md](NiagaraShader.md)** - GPU Shader ì»´íŒŒì¼ ë° ì‹¤í–‰
- **[NiagaraSystemInstance.md](../Core/NiagaraSystemInstance.md)** - SystemInstance ìƒëª…ì£¼ê¸°

---

#### ğŸ“š ì°¸ê³  ìë£Œ (References)
##### ì†ŒìŠ¤ íŒŒì¼
**ê¸°ë³¸ í´ë˜ìŠ¤:**
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterface.h:569-957`
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterfaceRW.h:85-313`

**ì£¼ìš” êµ¬í˜„ ì˜ˆì‹œ:**
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterfaceTexture.h`
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterfaceSkeletalMesh.h:552-1126`
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterfaceCollisionQuery.h`
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterfaceRenderTarget2D.h`
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterfaceParticleRead.h`
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterfaceCamera.h`
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraDataInterfaceAudioPlayer.h`

##### ê³µì‹ ë¬¸ì„œ
- [Creating Custom Niagara Data Interfaces](https://docs.unrealengine.com/5.7/en-US/creating-custom-niagara-data-interfaces/)
- [Niagara GPU Execution](https://docs.unrealengine.com/5.7/en-US/niagara-gpu-execution/)
- [VectorVM Documentation](https://docs.unrealengine.com/5.7/en-US/vector-vm/)

##### í•µì‹¬ API
```cpp
// UNiagaraDataInterface ì£¼ìš” ê°€ìƒ í•¨ìˆ˜
virtual void GetFunctionsInternal(TArray<FNiagaraFunctionSignature>& OutFunctions) const;
virtual void GetVMExternalFunction(const FVMExternalFunctionBindingInfo& BindingInfo,
                                  void* InstanceData,
                                  FVMExternalFunction &OutFunc);

virtual void BuildShaderParameters(FNiagaraShaderParametersBuilder& ShaderParametersBuilder) const;
virtual void SetShaderParameters(const FNiagaraDataInterfaceSetShaderParametersContext& Context) const;

virtual bool InitPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance);
virtual void DestroyPerInstanceData(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance);
virtual int32 PerInstanceDataSize() const;

virtual bool PerInstanceTick(void* PerInstanceData, FNiagaraSystemInstance* SystemInstance, float DeltaSeconds);
virtual void PreStageTick(FNDICpuPreStageContext& Context);
virtual void PostStageTick(FNDICpuPostStageContext& Context);

virtual void ProvidePerInstanceDataForRenderThread(void* DataForRenderThread,
                                                   void* PerInstanceData,
                                                   const FNiagaraSystemInstanceID& SystemInstance);
virtual int32 PerInstanceDataPassedToRenderThreadSize() const;

// FNiagaraDataInterfaceProxy ì£¼ìš” ë©”ì„œë“œ
virtual void ConsumePerInstanceDataFromGameThread(void* PerInstanceData,
                                                  const FNiagaraSystemInstanceID& Instance);
virtual void PreStage(const FNDIGpuComputePreStageContext& Context);
virtual void PostStage(const FNDIGpuComputePostStageContext& Context);
virtual void PostSimulate(const FNDIGpuComputePostSimulateContext& Context);
```

---

> ğŸ”„ Updated: 2026-02-18 â€” DataInterface ê´€ë ¨ ì¤‘ë³µ ë¬¸ì„œë¥¼ í†µí•© (5ê°œ â†’ 2ê°œ)
> ğŸ”„ **ì‘ì„±ì¼**: 2025-11-21
> ğŸ“ **ë¬¸ì„œ ë²„ì „**: v1.1
> âœ… **ì†ŒìŠ¤ ê²€ì¦**: UE 5.7.0
> ğŸ“‚ **Advanced ë¬¸ì„œ**: Niagara DataInterface ì‹¬í™” ë¶„ì„ ì™„ë£Œ

