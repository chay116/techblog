---
title: "Compiler - Niagara ì»´íŒŒì¼ëŸ¬ ì‹œìŠ¤í…œ (Niagara Compiler System)"
date: "2026-02-18"
status: "stable"
project: "UnrealEngine"
lang: "ko"
category: "unreal-summary"
track: "Niagara"
tags: ["unreal", "Niagara"]
---
> Updated: 2026-02-18 ? merged duplicate content from related documents.

> ğŸ”„ Updated: 2026-02-18 â€” Script_Compilation.md ë‚´ìš©ì„ í†µí•©í•˜ì—¬ ë‹¨ì¼ ì»´íŒŒì¼ëŸ¬ ë¬¸ì„œë¡œ ë³‘í•©

# Compiler - Niagara ì»´íŒŒì¼ëŸ¬ ì‹œìŠ¤í…œ (Niagara Compiler System)

## ğŸ§­ ê°œìš” (Overview)

**Niagara Compiler**ëŠ” **ê·¸ë˜í”„ ê¸°ë°˜ ë¹„ì£¼ì–¼ ìŠ¤í¬ë¦½íŒ…ì„ ì‹¤í–‰ ê°€ëŠ¥í•œ ì½”ë“œë¡œ ë³€í™˜í•˜ëŠ” ì»´íŒŒì¼ ì‹œìŠ¤í…œ**ì…ë‹ˆë‹¤. Niagara ì—ë””í„°ì—ì„œ ì‘ì„±ëœ ë…¸ë“œ ê·¸ë˜í”„ë¥¼ ë¶„ì„í•˜ì—¬ CPUìš© VectorVM ë°”ì´íŠ¸ì½”ë“œì™€ GPUìš© HLSL ì½”ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

**í•µì‹¬ ì—­í• :**
- **ê·¸ë˜í”„ ë¶„ì„**: UNiagaraGraphì˜ ë…¸ë“œ íŠ¸ë¦¬ ìˆœíšŒ ë° ë¶„ì„
- **HLSL ìƒì„±**: ë…¸ë“œ ê·¸ë˜í”„ë¥¼ HLSL ì½”ë“œë¡œ ë³€í™˜ (FNiagaraHlslTranslator)
- **VectorVM ë°”ì´íŠ¸ì½”ë“œ ìƒì„±**: HLSLì„ VectorVM ëª…ë ¹ì–´ë¡œ ì»´íŒŒì¼
- **GPU Shader ì»´íŒŒì¼**: HLSLì„ í”Œë«í¼ë³„ Compute Shaderë¡œ ì»´íŒŒì¼
- **ìµœì í™”**: Dead code elimination, constant folding, ì¤‘ë³µ ì œê±°
- **íƒ€ì… ì²´í¬**: ì»´íŒŒì¼ ì‹œ íƒ€ì… ê²€ì¦ ë° ì—ëŸ¬ ë³´ê³ 
- **DDC í†µí•©**: ì»´íŒŒì¼ ê²°ê³¼ ìºì‹±

**ì»´íŒŒì¼ íŒŒì´í”„ë¼ì¸:**

```
UNiagaraGraph (ë…¸ë“œ ê·¸ë˜í”„)
      â†“
FNiagaraHlslTranslator (ê·¸ë˜í”„ â†’ HLSL)
      â”œâ”€ ë…¸ë“œ ìˆœíšŒ
      â”œâ”€ ì½”ë“œ ì²­í¬ ìƒì„±
      â”œâ”€ í•¨ìˆ˜ ì¸ë¼ì¸
      â””â”€ HLSL ì½”ë“œ ì¶œë ¥
      â†“
FHlslNiagaraCompiler (ì»´íŒŒì¼ëŸ¬)
      â”œâ”€ [CPU ê²½ë¡œ]
      â”‚   â”œâ”€ HLSL â†’ VectorVM ë°”ì´íŠ¸ì½”ë“œ
      â”‚   â”œâ”€ ìµœì í™”
      â”‚   â””â”€ FNiagaraVMExecutableData ìƒì„±
      â”‚
      â””â”€ [GPU ê²½ë¡œ]
          â”œâ”€ HLSL â†’ Compute Shader ì»´íŒŒì¼
          â”œâ”€ í”Œë«í¼ë³„ Shader ìƒì„± (DX12, Vulkan ë“±)
          â””â”€ FNiagaraShaderMap ìƒì„±
```

**ğŸ“‚ ìœ„ì¹˜:**
- `Engine/Plugins/FX/Niagara/Source/NiagaraEditor/Private/NiagaraCompiler.h` (FHlslNiagaraCompiler)
- `Engine/Plugins/FX/Niagara/Source/NiagaraEditor/Private/NiagaraHlslTranslator.h` (FNiagaraHlslTranslator)
- `Engine/Plugins/FX/Niagara/Source/NiagaraEditor/Public/NiagaraGraph.h` (UNiagaraGraph)

---

## ğŸ¯ ì„¤ê³„ ì² í•™: ì™œ ì»´íŒŒì¼ëŸ¬ì¸ê°€?

### ë¬¸ì œ: ì¸í„°í”„ë¦¬í„° ë°©ì‹ì˜ í•œê³„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ì¸í„°í”„ë¦¬í„° ì‹¤í–‰ì˜ ë¬¸ì œì                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  âŒ ë¬¸ì œ 1: ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œ                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  - ë§¤ í”„ë ˆì„ ê·¸ë˜í”„ ìˆœíšŒ í•„ìš”                             â”‚          â”‚
â”‚  â”‚  - ë…¸ë“œ ì—°ê²° ì¡°íšŒ ì˜¤ë²„í—¤ë“œ                               â”‚          â”‚
â”‚  â”‚  - ê°€ìƒ í•¨ìˆ˜ í˜¸ì¶œ ë¹„ìš©                                   â”‚          â”‚
â”‚  â”‚  â†’ 10k íŒŒí‹°í´ ì‹œë®¬ë ˆì´ì…˜ ì‹œ ~50ms (ë„ˆë¬´ ëŠë¦¼!)          â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  âŒ ë¬¸ì œ 2: ìµœì í™” ë¶ˆê°€ëŠ¥                                                â”‚
â”‚  - Dead code ì œê±° ë¶ˆê°€                                                  â”‚
â”‚  - Constant folding ë¶ˆê°€                                                â”‚
â”‚  - ì¤‘ë³µ ê³„ì‚° ì œê±° ë¶ˆê°€                                                  â”‚
â”‚  - SIMD ìµœì í™” ë¶ˆê°€                                                     â”‚
â”‚                                                                         â”‚
â”‚  âŒ ë¬¸ì œ 3: GPU ì‹¤í–‰ ë¶ˆê°€ëŠ¥                                              â”‚
â”‚  - ê·¸ë˜í”„ êµ¬ì¡°ë¥¼ GPUë¡œ ì „ì†¡ ë¶ˆê°€                                         â”‚
â”‚  - Compute Shaderë¡œ ë³€í™˜ ë¶ˆê°€                                           â”‚
â”‚  - ëŒ€ëŸ‰ íŒŒí‹°í´ ì‹œë®¬ë ˆì´ì…˜ ë¶ˆê°€                                           â”‚
â”‚                                                                         â”‚
â”‚  âŒ ë¬¸ì œ 4: íƒ€ì… ì²´í¬ ì§€ì—°                                               â”‚
â”‚  - ëŸ°íƒ€ì„ì— íƒ€ì… ì˜¤ë¥˜ ë°œê²¬                                               â”‚
â”‚  - í¬ë˜ì‹œ ìœ„í—˜ ë†’ìŒ                                                     â”‚
â”‚  - ë””ë²„ê¹… ì–´ë ¤ì›€                                                        â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
                   ì»´íŒŒì¼ëŸ¬ ì†”ë£¨ì…˜:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                         â”‚
â”‚  âœ… í•´ê²° 1: Ahead-of-Time (AOT) ì»´íŒŒì¼                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  ê·¸ë˜í”„ ìˆ˜ì • ì‹œ (ì—ë””í„°ì—ì„œ):                             â”‚          â”‚
â”‚  â”‚  â””â”€ ì»´íŒŒì¼ëŸ¬ ì‹¤í–‰ (1íšŒë§Œ)                                â”‚          â”‚
â”‚  â”‚      â”œâ”€ ê·¸ë˜í”„ ë¶„ì„                                       â”‚          â”‚
â”‚  â”‚      â”œâ”€ HLSL ìƒì„±                                        â”‚          â”‚
â”‚  â”‚      â”œâ”€ ìµœì í™”                                           â”‚          â”‚
â”‚  â”‚      â””â”€ ë°”ì´íŠ¸ì½”ë“œ/Shader ìƒì„±                           â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ëŸ°íƒ€ì„ (ê²Œì„ ì‹¤í–‰ ì¤‘):                                   â”‚          â”‚
â”‚  â”‚  â””â”€ ì»´íŒŒì¼ëœ ë°”ì´íŠ¸ì½”ë“œ/Shader ì§ì ‘ ì‹¤í–‰                 â”‚          â”‚
â”‚  â”‚      â†’ ê·¸ë˜í”„ ìˆœíšŒ ì—†ìŒ!                                 â”‚          â”‚
â”‚  â”‚      â†’ 10k íŒŒí‹°í´ ì‹œë®¬ë ˆì´ì…˜ ~0.5ms (100ë°° ë¹ ë¦„!)        â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  âœ… í•´ê²° 2: ê°•ë ¥í•œ ìµœì í™”                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  ì»´íŒŒì¼ ì‹œ ìµœì í™”:                                        â”‚          â”‚
â”‚  â”‚  â”œâ”€ Dead Code Elimination                               â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë…¸ë“œ ì œê±°                         â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â”œâ”€ Constant Folding                                    â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ ì»´íŒŒì¼ ì‹œ ìƒìˆ˜ ê³„ì‚°                             â”‚          â”‚
â”‚  â”‚  â”‚       ì˜ˆ: 3.14 * 2.0 â†’ 6.28 (ëŸ°íƒ€ì„ ê³„ì‚° ë¶ˆí•„ìš”)     â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â”œâ”€ Common Subexpression Elimination                    â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ ì¤‘ë³µ ê³„ì‚° ì œê±°                                  â”‚          â”‚
â”‚  â”‚  â”‚       ì˜ˆ: (A + B) ë‘ ë²ˆ ê³„ì‚° â†’ í•œ ë²ˆë§Œ ê³„ì‚°         â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â”œâ”€ Function Inlining                                   â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ í•¨ìˆ˜ í˜¸ì¶œ ì˜¤ë²„í—¤ë“œ ì œê±°                         â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â””â”€ SIMD ì½”ë“œ ìƒì„±                                       â”‚          â”‚
â”‚  â”‚      â””â”€ VectorVM: 4ê°œ íŒŒí‹°í´ ë™ì‹œ ì²˜ë¦¬                  â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  âœ… í•´ê²° 3: CPU/GPU ì–‘ìª½ ì½”ë“œ ìƒì„±                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  ë‹¨ì¼ ê·¸ë˜í”„ â†’ ë‘ ê°€ì§€ ì¶œë ¥:                              â”‚          â”‚
â”‚  â”‚  â”œâ”€ VectorVM ë°”ì´íŠ¸ì½”ë“œ (CPU)                            â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ SIMD ìµœì í™”, 4ê°œì”© ë³‘ë ¬ ì²˜ë¦¬                    â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â””â”€ HLSL Compute Shader (GPU)                           â”‚          â”‚
â”‚  â”‚      â””â”€ ìˆ˜ë§Œ íŒŒí‹°í´ ë³‘ë ¬ ì²˜ë¦¬                            â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  âœ… í•´ê²° 4: ì»´íŒŒì¼ íƒ€ì„ íƒ€ì… ì²´í¬                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  ì»´íŒŒì¼ ì‹œ:                                               â”‚          â”‚
â”‚  â”‚  â”œâ”€ ëª¨ë“  ë…¸ë“œ ì—°ê²°ì˜ íƒ€ì… ê²€ì¦                           â”‚          â”‚
â”‚  â”‚  â”œâ”€ íƒ€ì… ë¶ˆì¼ì¹˜ ì‹œ ì»´íŒŒì¼ ì—ëŸ¬                           â”‚          â”‚
â”‚  â”‚  â””â”€ ì—ë””í„°ì—ì„œ ë¹¨ê°„ìƒ‰ ë…¸ë“œ í‘œì‹œ                          â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  â†’ ëŸ°íƒ€ì„ í¬ë˜ì‹œ ë°©ì§€!                                   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  âœ… í•´ê²° 5: DDC ìºì‹±                                                     â”‚
â”‚  - ì»´íŒŒì¼ ê²°ê³¼ë¥¼ DDCì— ì €ì¥                                              â”‚
â”‚  - ë‹¤ìŒ ì‹¤í–‰ ì‹œ ì¦‰ì‹œ ë¡œë“œ (<1ì´ˆ)                                         â”‚
â”‚  - íŒ€ì› ê°„ ìºì‹œ ê³µìœ  ê°€ëŠ¥                                                â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ì„¤ê³„ ê²°ì •

| ê²°ì • ì‚¬í•­ | ì´ìœ  | íŠ¸ë ˆì´ë“œì˜¤í”„ |
|----------|------|-------------|
| **AOT ì»´íŒŒì¼** | ëŸ°íƒ€ì„ ì„±ëŠ¥ ê·¹ëŒ€í™” | ì»´íŒŒì¼ ì‹œê°„ í•„ìš” |
| **HLSL ì¤‘ê°„ ì–¸ì–´** | CPU/GPU ì–‘ìª½ ìƒì„± ê°€ëŠ¥ | HLSL ë¬¸ë²• ì œì•½ |
| **ì½”ë“œ ì²­í¬ ê¸°ë°˜** | ì ì§„ì  ì½”ë“œ ìƒì„±, ìµœì í™” | ë³µì¡ë„ ì¦ê°€ |
| **íƒ€ì… ì²´í¬ ê°•ì œ** | ëŸ°íƒ€ì„ ì•ˆì „ì„± ë³´ì¥ | ìœ ì—°ì„± ê°ì†Œ |
| **DDC í†µí•©** | ì¬ì»´íŒŒì¼ ì‹œê°„ ì ˆì•½ | ë””ìŠ¤í¬ ê³µê°„ ì‚¬ìš© |

---

## ğŸ—ï¸ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ (System Architecture)

### 1. UNiagaraGraph (ë…¸ë“œ ê·¸ë˜í”„ êµ¬ì¡°)

**ì—­í• :** Niagara ì—ë””í„°ì˜ ë¹„ì£¼ì–¼ ìŠ¤í¬ë¦½íŒ… ê·¸ë˜í”„

**êµ¬ì¡°:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         UNiagaraGraph                                   â”‚
â”‚  (ë…¸ë“œ ê¸°ë°˜ ë¹„ì£¼ì–¼ ìŠ¤í¬ë¦½íŒ… ê·¸ë˜í”„)                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ìƒì†: UObject â†’ UEdGraph â†’ UNiagaraGraph                               â”‚
â”‚                                                                         â”‚
â”‚  Private:                                                               â”‚
â”‚    - Nodes : TArray<UNiagaraNode*>                                     â”‚
â”‚      // ê·¸ë˜í”„ì˜ ëª¨ë“  ë…¸ë“œ                                               â”‚
â”‚      //   UNiagaraNodeInput (íŒŒë¼ë¯¸í„° ì…ë ¥)                             â”‚
â”‚      //   UNiagaraNodeOutput (ì¶œë ¥ ë…¸ë“œ)                                â”‚
â”‚      //   UNiagaraNodeFunctionCall (í•¨ìˆ˜ í˜¸ì¶œ)                          â”‚
â”‚      //   UNiagaraNodeOp (ì—°ì‚°ì: Add, Mul ë“±)                          â”‚
â”‚      //   UNiagaraNodeParameterMapGet/Set (íŒŒë¼ë¯¸í„° ë§µ ì ‘ê·¼)            â”‚
â”‚                                                                         â”‚
â”‚    - CachedUsageInfo : TArray<FNiagaraGraphScriptUsageInfo>           â”‚
â”‚      // Usageë³„ ìºì‹œëœ ì»´íŒŒì¼ ì •ë³´                                       â”‚
â”‚                                                                         â”‚
â”‚    - ChangeId : FGuid                                                  â”‚
â”‚      // ê·¸ë˜í”„ ë³€ê²½ ID (ë³€ê²½ ê°ì§€ìš©)                                     â”‚
â”‚                                                                         â”‚
â”‚  ì£¼ìš” ë©”ì„œë“œ:                                                            â”‚
â”‚    + FindOutputNode(ENiagaraScriptUsage, FGuid) : UNiagaraNodeOutput* â”‚
â”‚      // íŠ¹ì • Usageì˜ ì¶œë ¥ ë…¸ë“œ ì°¾ê¸°                                      â”‚
â”‚                                                                         â”‚
â”‚    + BuildTraversal(TArray<UNiagaraNode*>&, ENiagaraScriptUsage)      â”‚
â”‚      // ì¶œë ¥ ë…¸ë“œë¶€í„° ì—­ìˆœìœ¼ë¡œ ë…¸ë“œ ìˆœíšŒ                                 â”‚
â”‚                                                                         â”‚
â”‚    + GetParameters(TArray<FNiagaraVariable>&, TArray<FNiagaraVariable>&)â”‚
â”‚      // ì…ë ¥/ì¶œë ¥ íŒŒë¼ë¯¸í„° ëª©ë¡ ë°˜í™˜                                     â”‚
â”‚                                                                         â”‚
â”‚    + NotifyGraphNeedsRecompile() : void                                â”‚
â”‚      // ê·¸ë˜í”„ ë³€ê²½ ì•Œë¦¼ (ì¬ì»´íŒŒì¼ íŠ¸ë¦¬ê±°)                               â”‚
â”‚                                                                         â”‚
â”‚    + GatherExternalDependencyData(...) : void                          â”‚
â”‚      // ì™¸ë¶€ ì˜ì¡´ì„± ìˆ˜ì§‘ (DDC í‚¤ ìƒì„±ìš©)                                 â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ“‚ ì†ŒìŠ¤ ê²€ì¦:**
- `NiagaraGraph.h:209-300` - UNiagaraGraph í´ë˜ìŠ¤

**ë…¸ë“œ íƒ€ì… ì˜ˆì‹œ:**

```
Niagara ê·¸ë˜í”„ ë…¸ë“œ íƒ€ì…:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                         â”‚
â”‚  [ì…ë ¥ ë…¸ë“œ]                                                             â”‚
â”‚  UNiagaraNodeInput                                                      â”‚
â”‚  â””â”€ íŒŒë¼ë¯¸í„° ì…ë ¥ (User.SpawnRate, Engine.DeltaTime ë“±)                 â”‚
â”‚                                                                         â”‚
â”‚  [ì¶œë ¥ ë…¸ë“œ]                                                             â”‚
â”‚  UNiagaraNodeOutput                                                     â”‚
â”‚  â””â”€ ìŠ¤í¬ë¦½íŠ¸ ì¶œë ¥ (Particles.Position, Particles.Color ë“±)              â”‚
â”‚                                                                         â”‚
â”‚  [ì—°ì‚° ë…¸ë“œ]                                                             â”‚
â”‚  UNiagaraNodeOp                                                         â”‚
â”‚  â”œâ”€ Add (A + B)                                                        â”‚
â”‚  â”œâ”€ Multiply (A * B)                                                   â”‚
â”‚  â”œâ”€ Divide (A / B)                                                     â”‚
â”‚  â””â”€ ...                                                                â”‚
â”‚                                                                         â”‚
â”‚  [í•¨ìˆ˜ í˜¸ì¶œ ë…¸ë“œ]                                                        â”‚
â”‚  UNiagaraNodeFunctionCall                                               â”‚
â”‚  â”œâ”€ Sample Texture                                                     â”‚
â”‚  â”œâ”€ Curl Noise                                                         â”‚
â”‚  â”œâ”€ Collision Query                                                    â”‚
â”‚  â””â”€ ì‚¬ìš©ì ì •ì˜ í•¨ìˆ˜                                                     â”‚
â”‚                                                                         â”‚
â”‚  [íŒŒë¼ë¯¸í„° ë§µ ë…¸ë“œ]                                                      â”‚
â”‚  UNiagaraNodeParameterMapGet                                            â”‚
â”‚  â””â”€ íŒŒë¼ë¯¸í„° ì½ê¸° (Particles.Position)                                  â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraNodeParameterMapSet                                            â”‚
â”‚  â””â”€ íŒŒë¼ë¯¸í„° ì“°ê¸° (Particles.Position = NewValue)                       â”‚
â”‚                                                                         â”‚
â”‚  [ì œì–´ íë¦„ ë…¸ë“œ]                                                        â”‚
â”‚  UNiagaraNodeIf                                                         â”‚
â”‚  â””â”€ ì¡°ê±´ë¬¸ (if A > B then C else D)                                    â”‚
â”‚                                                                         â”‚
â”‚  UNiagaraNodeStaticSwitch                                               â”‚
â”‚  â””â”€ ì •ì  ë¶„ê¸° (ì»´íŒŒì¼ ì‹œ ê²°ì •)                                           â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. FNiagaraHlslTranslator (HLSL ë³€í™˜ê¸°)

**ì—­í• :** ë…¸ë“œ ê·¸ë˜í”„ë¥¼ HLSL ì½”ë“œë¡œ ë³€í™˜

**êµ¬ì¡°:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   FNiagaraHlslTranslator                                â”‚
â”‚  (ê·¸ë˜í”„ â†’ HLSL ë³€í™˜ê¸°)                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ì—­í• : ë…¸ë“œ ê·¸ë˜í”„ë¥¼ ë¶„ì„í•˜ì—¬ HLSL ì½”ë“œ ìƒì„±                              â”‚
â”‚                                                                         â”‚
â”‚  Protected:                                                             â”‚
â”‚    - CodeChunks : TArray<FNiagaraCodeChunk>                            â”‚
â”‚      // ìƒì„±ëœ ì½”ë“œ ì²­í¬ ëª©ë¡                                            â”‚
â”‚                                                                         â”‚
â”‚    - ChunksByMode : TArray<int32>[ENiagaraCodeChunkMode::Num]         â”‚
â”‚      // ëª¨ë“œë³„ ì²­í¬ ì¸ë±ìŠ¤ ë°°ì—´:                                         â”‚
â”‚      //   [GlobalConstant] - ì „ì—­ ìƒìˆ˜                                 â”‚
â”‚      //   [Uniform] - Uniform íŒŒë¼ë¯¸í„°                                 â”‚
â”‚      //   [Body] - ë©”ì¸ ë°”ë”” ì½”ë“œ                                       â”‚
â”‚      //   [SpawnBody] - Spawn ì „ìš© ì½”ë“œ                                â”‚
â”‚      //   [UpdateBody] - Update ì „ìš© ì½”ë“œ                              â”‚
â”‚                                                                         â”‚
â”‚    - Functions : TMap<FNiagaraFunctionSignature, FNiagaraFunctionBody>â”‚
â”‚      // ìƒì„±ëœ í•¨ìˆ˜ ëª©ë¡                                                 â”‚
â”‚                                                                         â”‚
â”‚    - CompilationOutput : FNiagaraTranslatorOutput                      â”‚
â”‚      // ìµœì¢… ì¶œë ¥ (ScriptData, HLSL ì½”ë“œ)                               â”‚
â”‚                                                                         â”‚
â”‚    - MessageLog : FCompilerResultsLog                                  â”‚
â”‚      // ì»´íŒŒì¼ ì—ëŸ¬/ê²½ê³  ë¡œê·¸                                            â”‚
â”‚                                                                         â”‚
â”‚    - HlslOutput : FString                                              â”‚
â”‚      // ìƒì„±ëœ HLSL ì½”ë“œ (ìµœì¢… ê²°ê³¼)                                     â”‚
â”‚                                                                         â”‚
â”‚  ì£¼ìš” ë©”ì„œë“œ:                                                            â”‚
â”‚    + Translate(CompileData, CompileOptions) : FNiagaraTranslateResultsâ”‚
â”‚      // ê·¸ë˜í”„ë¥¼ HLSLë¡œ ë³€í™˜ (ë©”ì¸ ì—”íŠ¸ë¦¬ í¬ì¸íŠ¸)                        â”‚
â”‚                                                                         â”‚
â”‚    + AddSourceChunk(SymbolName, Type) : int32                          â”‚
â”‚      // ì†ŒìŠ¤ ì²­í¬ ì¶”ê°€ (ë‹¤ë¥¸ ì²­í¬ì˜ ì…ë ¥)                                â”‚
â”‚                                                                         â”‚
â”‚    + AddBodyChunk(SymbolName, Definition, Type) : int32                â”‚
â”‚      // ë°”ë”” ì²­í¬ ì¶”ê°€ (ì‹¤ì œ ì‹¤í–‰ ì½”ë“œ)                                  â”‚
â”‚                                                                         â”‚
â”‚    + AddUniformChunk(SymbolName, Variable) : int32                     â”‚
â”‚      // Uniform íŒŒë¼ë¯¸í„° ì¶”ê°€                                           â”‚
â”‚                                                                         â”‚
â”‚    + GetFunctionDefinitions() : FString                                â”‚
â”‚      // í•¨ìˆ˜ ì •ì˜ HLSL ìƒì„±                                             â”‚
â”‚                                                                         â”‚
â”‚    + DefineMain(...) : void                                            â”‚
â”‚      // main() í•¨ìˆ˜ HLSL ìƒì„±                                           â”‚
â”‚                                                                         â”‚
â”‚    + DefineDataInterfaceHLSL(...) : void                               â”‚
â”‚      // DataInterface HLSL ìƒì„±                                        â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ“‚ ì†ŒìŠ¤ ê²€ì¦:**
- `NiagaraHlslTranslator.h:224-400` - FNiagaraHlslTranslator í´ë˜ìŠ¤

### 3. FNiagaraCodeChunk (ì½”ë“œ ì²­í¬)

**ì—­í• :** ì¤‘ê°„ í‘œí˜„ (IR) - HLSL ì½”ë“œ ì¡°ê°

**êµ¬ì¡°:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      FNiagaraCodeChunk                                  â”‚
â”‚  (ì¤‘ê°„ í‘œí˜„ - HLSL ì½”ë“œ ì¡°ê°)                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ì—­í• : í•˜ë‚˜ì˜ ì½”ë“œ í‘œí˜„ì‹ ë˜ëŠ” ë¬¸ì¥                                       â”‚
â”‚                                                                         â”‚
â”‚  êµ¬ì¡°:                                                                   â”‚
â”‚    - SymbolName : FString                                              â”‚
â”‚      // ì‹¬ë³¼ ì´ë¦„ (ë³€ìˆ˜ëª…)                                               â”‚
â”‚      // ì˜ˆ: "TempVar0", "Particles_Position"                           â”‚
â”‚                                                                         â”‚
â”‚    - Definition : FString                                              â”‚
â”‚      // ì½”ë“œ ì •ì˜ (í‘œí˜„ì‹)                                               â”‚
â”‚      // ì˜ˆ: "{0} + {1}", "sin({0})"                                    â”‚
â”‚                                                                         â”‚
â”‚    - Type : FNiagaraTypeDefinition                                     â”‚
â”‚      // ê²°ê³¼ íƒ€ì… (Float, Vector3, Vector4 ë“±)                          â”‚
â”‚                                                                         â”‚
â”‚    - SourceChunks : TArray<int32>                                      â”‚
â”‚      // ì…ë ¥ ì²­í¬ ì¸ë±ìŠ¤ (ì˜ì¡´ì„±)                                        â”‚
â”‚                                                                         â”‚
â”‚    - Mode : ENiagaraCodeChunkMode                                      â”‚
â”‚      // GlobalConstant, Uniform, Body, SpawnBody, UpdateBody ë“±        â”‚
â”‚                                                                         â”‚
â”‚    - bDecl : bool                                                      â”‚
â”‚      // ì„ ì–¸ í•„ìš” ì—¬ë¶€ (float TempVar0 = ...)                           â”‚
â”‚                                                                         â”‚
â”‚  ì˜ˆì‹œ:                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  ì²­í¬ #0:                                                â”‚          â”‚
â”‚  â”‚    SymbolName = "Gravity"                                â”‚          â”‚
â”‚  â”‚    Definition = "float3(0, 0, -980)"                     â”‚          â”‚
â”‚  â”‚    Type = Vector3                                        â”‚          â”‚
â”‚  â”‚    Mode = GlobalConstant                                 â”‚          â”‚
â”‚  â”‚    bDecl = true                                          â”‚          â”‚
â”‚  â”‚    â†’ ìƒì„±ëœ HLSL: "static const float3 Gravity = float3(0, 0, -980);"â”‚ â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ì²­í¬ #1:                                                â”‚          â”‚
â”‚  â”‚    SymbolName = "DeltaTime"                              â”‚          â”‚
â”‚  â”‚    Definition = "Emitter_DeltaTime"                      â”‚          â”‚
â”‚  â”‚    Type = Float                                          â”‚          â”‚
â”‚  â”‚    Mode = Uniform                                        â”‚          â”‚
â”‚  â”‚    â†’ ìƒì„±ëœ HLSL: (Uniform ë²„í¼ì—ì„œ ê°€ì ¸ì˜´)              â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ì²­í¬ #2:                                                â”‚          â”‚
â”‚  â”‚    SymbolName = "TempVar0"                               â”‚          â”‚
â”‚  â”‚    Definition = "{0} * {1}"                              â”‚          â”‚
â”‚  â”‚    SourceChunks = [0, 1]  // Gravity, DeltaTime         â”‚          â”‚
â”‚  â”‚    Type = Vector3                                        â”‚          â”‚
â”‚  â”‚    Mode = Body                                           â”‚          â”‚
â”‚  â”‚    bDecl = true                                          â”‚          â”‚
â”‚  â”‚    â†’ ìƒì„±ëœ HLSL: "float3 TempVar0 = Gravity * DeltaTime;"â”‚         â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ì²­í¬ #3:                                                â”‚          â”‚
â”‚  â”‚    SymbolName = "Particles_Velocity"                     â”‚          â”‚
â”‚  â”‚    Definition = "{0} + {1}"                              â”‚          â”‚
â”‚  â”‚    SourceChunks = [ParticlesVelocity_Read, 2]           â”‚          â”‚
â”‚  â”‚    Type = Vector3                                        â”‚          â”‚
â”‚  â”‚    Mode = Body                                           â”‚          â”‚
â”‚  â”‚    â†’ ìƒì„±ëœ HLSL:                                        â”‚          â”‚
â”‚  â”‚       "Particles_Velocity = Particles_Velocity + TempVar0;"â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ“‚ ì†ŒìŠ¤ ê²€ì¦:**
- `NiagaraHlslTranslator.h:105-160` - FNiagaraCodeChunk êµ¬ì¡°ì²´

### 4. FHlslNiagaraCompiler (ë©”ì¸ ì»´íŒŒì¼ëŸ¬)

**ì—­í• :** HLSL ì½”ë“œë¥¼ VectorVM ë°”ì´íŠ¸ì½”ë“œ ë˜ëŠ” GPU Shaderë¡œ ì»´íŒŒì¼

**êµ¬ì¡°:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FHlslNiagaraCompiler                                 â”‚
â”‚  (HLSL â†’ VectorVM/Shader ì»´íŒŒì¼ëŸ¬)                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ìƒì†: INiagaraCompiler â†’ FHlslNiagaraCompiler                          â”‚
â”‚                                                                         â”‚
â”‚  Protected:                                                             â”‚
â”‚    - CompileResults : FNiagaraCompileResults                           â”‚
â”‚      // ì»´íŒŒì¼ ê²°ê³¼ (ì„±ê³µ, ì—ëŸ¬, ê²½ê³ )                                   â”‚
â”‚                                                                         â”‚
â”‚    - CompilationJob : TUniquePtr<FNiagaraCompilerJob>                  â”‚
â”‚      // í˜„ì¬ ì»´íŒŒì¼ ì‘ì—…                                                 â”‚
â”‚                                                                         â”‚
â”‚  ì£¼ìš” ë©”ì„œë“œ:                                                            â”‚
â”‚    + CompileScript(...) : int32                                        â”‚
â”‚      // ìŠ¤í¬ë¦½íŠ¸ ì»´íŒŒì¼ (CPU + GPU)                                     â”‚
â”‚                                                                         â”‚
â”‚    + CompileScriptVM(...) : uint32                                     â”‚
â”‚      // VectorVM ë°”ì´íŠ¸ì½”ë“œ ì»´íŒŒì¼ (CPU ì „ìš©)                           â”‚
â”‚                                                                         â”‚
â”‚    + CreateShaderIntermediateData(...) : int32                         â”‚
â”‚      // Shader ì»´íŒŒì¼ ì‘ì—… ìƒì„± (GPU ì „ìš©)                              â”‚
â”‚                                                                         â”‚
â”‚    + GetCompileResult(JobID, bWait) : TOptional<FNiagaraCompileResults>â”‚
â”‚      // ì»´íŒŒì¼ ê²°ê³¼ ê°€ì ¸ì˜¤ê¸° (ë¹„ë™ê¸°)                                    â”‚
â”‚                                                                         â”‚
â”‚    + Error(FText) : void                                               â”‚
â”‚      // ì»´íŒŒì¼ ì—ëŸ¬ ê¸°ë¡                                                 â”‚
â”‚                                                                         â”‚
â”‚    + Warning(FText) : void                                             â”‚
â”‚      // ì»´íŒŒì¼ ê²½ê³  ê¸°ë¡                                                 â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ğŸ“‚ ì†ŒìŠ¤ ê²€ì¦:**
- `NiagaraCompiler.h:32-62` - FHlslNiagaraCompiler í´ë˜ìŠ¤

---

## ğŸ”„ ì»´íŒŒì¼ íŒŒì´í”„ë¼ì¸ (Compilation Pipeline)

### ì „ì²´ ì»´íŒŒì¼ íë¦„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Niagara ì»´íŒŒì¼ íŒŒì´í”„ë¼ì¸ ì „ì²´ íë¦„                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  [1] ì»´íŒŒì¼ íŠ¸ë¦¬ê±°                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  ì—ë””í„°ì—ì„œ ê·¸ë˜í”„ ìˆ˜ì •:                                  â”‚          â”‚
â”‚  â”‚  - ë…¸ë“œ ì¶”ê°€/ì‚­ì œ/ìˆ˜ì •                                    â”‚          â”‚
â”‚  â”‚  - ì—°ê²° ë³€ê²½                                             â”‚          â”‚
â”‚  â”‚  - íŒŒë¼ë¯¸í„° ë³€ê²½                                         â”‚          â”‚
â”‚  â”‚  â””â”€ UNiagaraGraph::NotifyGraphNeedsRecompile()         â”‚          â”‚
â”‚  â”‚      â””â”€ ChangeId ì—…ë°ì´íŠ¸                               â”‚          â”‚
â”‚  â”‚          â””â”€ ì»´íŒŒì¼ ìš”ì²­                                  â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚                                                               â”‚
â”‚         â†“                                                               â”‚
â”‚  [2] ê·¸ë˜í”„ ë¶„ì„ (FNiagaraHlslTranslator)                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  FNiagaraHlslTranslator::Translate()                    â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â”œâ”€ [2-1] ë…¸ë“œ ìˆœíšŒ (Traversal)                         â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ BuildTraversal(OutputNode)                     â”‚          â”‚
â”‚  â”‚  â”‚       â””â”€ ì¶œë ¥ ë…¸ë“œë¶€í„° ì—­ìˆœìœ¼ë¡œ ìˆœíšŒ                â”‚          â”‚
â”‚  â”‚  â”‚           â””â”€ [Output] â† [MapSet] â† [Add] â† [Input]â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â”œâ”€ [2-2] íƒ€ì… ê²€ì¦                                      â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ ê° ë…¸ë“œ ì—°ê²°ì˜ íƒ€ì… ì²´í¬                        â”‚          â”‚
â”‚  â”‚  â”‚       â”œâ”€ Float â†’ Float âœ…                            â”‚          â”‚
â”‚  â”‚  â”‚       â”œâ”€ Vector3 â†’ Vector3 âœ…                        â”‚          â”‚
â”‚  â”‚  â”‚       â””â”€ Float â†’ Vector3 âŒ (ì»´íŒŒì¼ ì—ëŸ¬)            â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â”œâ”€ [2-3] ì½”ë“œ ì²­í¬ ìƒì„±                                â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ for each Node:                                 â”‚          â”‚
â”‚  â”‚  â”‚       â””â”€ Node->Compile(Translator)                  â”‚          â”‚
â”‚  â”‚  â”‚           â””â”€ Translator->AddBodyChunk(...)          â”‚          â”‚
â”‚  â”‚  â”‚               â””â”€ CodeChunks ë°°ì—´ì— ì¶”ê°€             â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â”œâ”€ [2-4] ìµœì í™”                                        â”‚          â”‚
â”‚  â”‚  â”‚   â”œâ”€ Constant Folding                               â”‚          â”‚
â”‚  â”‚  â”‚   â”‚   â””â”€ 3.14 * 2.0 â†’ 6.28 (ì»´íŒŒì¼ ì‹œ ê³„ì‚°)         â”‚          â”‚
â”‚  â”‚  â”‚   â”œâ”€ Dead Code Elimination                          â”‚          â”‚
â”‚  â”‚  â”‚   â”‚   â””â”€ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ì²­í¬ ì œê±°                    â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ Common Subexpression Elimination               â”‚          â”‚
â”‚  â”‚  â”‚       â””â”€ ì¤‘ë³µ ê³„ì‚° ì œê±°                             â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â””â”€ [2-5] HLSL ì½”ë“œ ìƒì„±                                â”‚          â”‚
â”‚  â”‚      â”œâ”€ DefineDataInterfaceHLSL() - DI í•¨ìˆ˜            â”‚          â”‚
â”‚  â”‚      â”œâ”€ DefineExternalFunctionsHLSL() - ì™¸ë¶€ í•¨ìˆ˜      â”‚          â”‚
â”‚  â”‚      â”œâ”€ GetFunctionDefinitions() - ì‚¬ìš©ì í•¨ìˆ˜         â”‚          â”‚
â”‚  â”‚      â””â”€ DefineMain() - main() í•¨ìˆ˜                     â”‚          â”‚
â”‚  â”‚          â””â”€ HlslOutput = ìµœì¢… HLSL ì½”ë“œ                â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚                                                               â”‚
â”‚         â†“                                                               â”‚
â”‚  [3] CPU ì»´íŒŒì¼ (VectorVM ë°”ì´íŠ¸ì½”ë“œ)                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  FHlslNiagaraCompiler::CompileScriptVM()                â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â”œâ”€ [3-1] HLSL â†’ ì¤‘ê°„ í‘œí˜„ (IR)                         â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ VectorVM Backend íŒŒì‹±                          â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â”œâ”€ [3-2] IR â†’ VectorVM ëª…ë ¹ì–´                          â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ HLSL "A + B * C"                               â”‚          â”‚
â”‚  â”‚  â”‚       â†’ VectorVM Bytecode:                          â”‚          â”‚
â”‚  â”‚  â”‚         LOAD A                                       â”‚          â”‚
â”‚  â”‚  â”‚         LOAD B                                       â”‚          â”‚
â”‚  â”‚  â”‚         LOAD C                                       â”‚          â”‚
â”‚  â”‚  â”‚         MUL B, C â†’ Temp0                            â”‚          â”‚
â”‚  â”‚  â”‚         ADD A, Temp0 â†’ Output                       â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â”œâ”€ [3-3] ìµœì í™”                                        â”‚          â”‚
â”‚  â”‚  â”‚   â”œâ”€ Register Allocation (ë ˆì§€ìŠ¤í„° í• ë‹¹)            â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ Peephole Optimization (íŒ¨í„´ ìµœì í™”)            â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â””â”€ [3-4] FNiagaraVMExecutableData ìƒì„±                â”‚          â”‚
â”‚  â”‚      â”œâ”€ ByteCode (ë°”ì´íŠ¸ì½”ë“œ)                           â”‚          â”‚
â”‚  â”‚      â”œâ”€ NumTempRegisters (ì„ì‹œ ë ˆì§€ìŠ¤í„° ê°œìˆ˜)           â”‚          â”‚
â”‚  â”‚      â”œâ”€ DataInterfaceInfo (DI ì •ë³´)                    â”‚          â”‚
â”‚  â”‚      â””â”€ Parameters (íŒŒë¼ë¯¸í„° í…Œì´ë¸”)                    â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚                                                               â”‚
â”‚         â†“                                                               â”‚
â”‚  [4] GPU ì»´íŒŒì¼ (Compute Shader)                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  FHlslNiagaraCompiler::CreateShaderIntermediateData()   â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â”œâ”€ [4-1] HLSL â†’ Compute Shader ë˜í•‘                    â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ HLSL ì½”ë“œë¥¼ Compute Shader main()ì— í¬í•¨       â”‚          â”‚
â”‚  â”‚  â”‚       [numthreads(64, 1, 1)]                         â”‚          â”‚
â”‚  â”‚  â”‚       void NiagaraComputeMain(...)                   â”‚          â”‚
â”‚  â”‚  â”‚       {                                               â”‚          â”‚
â”‚  â”‚  â”‚           // ìƒì„±ëœ HLSL ì½”ë“œ                         â”‚          â”‚
â”‚  â”‚  â”‚       }                                               â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â”œâ”€ [4-2] Shader ì»´íŒŒì¼ ì‘ì—… ìƒì„±                       â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ FShaderCompileJob ìƒì„±                         â”‚          â”‚
â”‚  â”‚  â”‚       â”œâ”€ ShaderType = FNiagaraShader                â”‚          â”‚
â”‚  â”‚  â”‚       â”œâ”€ ShaderPlatform = SM5, SM6, Vulkan ë“±       â”‚          â”‚
â”‚  â”‚  â”‚       â””â”€ CompilerInput (HLSL ì½”ë“œ)                   â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â”œâ”€ [4-3] í”Œë«í¼ë³„ Shader ì»´íŒŒì¼ (ë¹„ë™ê¸°)               â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ ShaderCompilerWorker í”„ë¡œì„¸ìŠ¤                   â”‚          â”‚
â”‚  â”‚  â”‚       â”œâ”€ DirectX Shader Compiler (DXC)              â”‚          â”‚
â”‚  â”‚  â”‚       â”œâ”€ SPIRV-Cross (Vulkan)                       â”‚          â”‚
â”‚  â”‚  â”‚       â””â”€ í”Œë«í¼ë³„ ì»´íŒŒì¼ëŸ¬                           â”‚          â”‚
â”‚  â”‚  â”‚                                                       â”‚          â”‚
â”‚  â”‚  â””â”€ [4-4] FNiagaraShaderMap ìƒì„±                       â”‚          â”‚
â”‚  â”‚      â””â”€ í”Œë«í¼ë³„ ì»´íŒŒì¼ëœ Shader ì €ì¥                   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚                                                               â”‚
â”‚         â†“                                                               â”‚
â”‚  [5] ê²°ê³¼ ì €ì¥ (DDC)                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  UNiagaraScript::SetVMCompilationResults()              â”‚          â”‚
â”‚  â”‚  â”œâ”€ CachedScriptVM = VMExecutableData                   â”‚          â”‚
â”‚  â”‚  â”œâ”€ CachedScriptVMId = CompilationId                    â”‚          â”‚
â”‚  â”‚  â””â”€ ScriptResource = ShaderMap                          â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  DDCì— ì €ì¥:                                             â”‚          â”‚
â”‚  â”‚  â””â”€ Key = "NIAGARAVM_<Hash>_<Usage>_<Version>"         â”‚          â”‚
â”‚  â”‚      â””â”€ Value = Serialized VMExecutableData + ShaderMapâ”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  [6] ì™„ë£Œ                                                                â”‚
â”‚  â””â”€ ì»´íŒŒì¼ëœ ìŠ¤í¬ë¦½íŠ¸ ì¦‰ì‹œ ì‚¬ìš© ê°€ëŠ¥                                     â”‚
â”‚      â”œâ”€ CPU: VectorVM::Exec(VMExecutableData)                          â”‚
â”‚      â””â”€ GPU: RHI::DispatchComputeShader(ShaderMap)                     â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ì»´íŒŒì¼ ì‹œê°„ ë¶„ì„

```
ì»´íŒŒì¼ ë‹¨ê³„ë³„ ì‹œê°„ (ì¼ë°˜ì ì¸ ParticleUpdateScript ê¸°ì¤€):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ë‹¨ê³„                                â”‚ ì‹œê°„      â”‚ ë¹„ìœ¨  â”‚               â”‚
â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  [1] ê·¸ë˜í”„ ìˆœíšŒ ë° ë¶„ì„              â”‚ ~50ms     â”‚ 5%    â”‚               â”‚
â”‚  [2] ì½”ë“œ ì²­í¬ ìƒì„±                   â”‚ ~100ms    â”‚ 10%   â”‚               â”‚
â”‚  [3] HLSL ì½”ë“œ ìƒì„±                   â”‚ ~50ms     â”‚ 5%    â”‚               â”‚
â”‚  [4] VectorVM ë°”ì´íŠ¸ì½”ë“œ ì»´íŒŒì¼       â”‚ ~200ms    â”‚ 20%   â”‚               â”‚
â”‚  [5] GPU Shader ì»´íŒŒì¼                â”‚ ~600ms    â”‚ 60%   â”‚ (ê°€ì¥ ëŠë¦¼)   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  ì´í•©                                 â”‚ ~1000ms   â”‚ 100%  â”‚               â”‚
â”‚                                                                         â”‚
â”‚  DDC Hit (ìºì‹œ):                                                         â”‚
â”‚  - ë¡œë“œ ì‹œê°„: <100ms (10ë°° ë¹ ë¦„!)                                        â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## âš™ï¸ VectorVM ì‹¤í–‰ ìƒì„¸ (VectorVM Execution Details)

### VectorVM ì•„í‚¤í…ì²˜

**ğŸ“‚ ì†ŒìŠ¤ ê²€ì¦:**
- `VectorVM.h:1-300` - VectorVM ì•„í‚¤í…ì²˜ ë° OpCode ì •ì˜

**í•µì‹¬ êµ¬ì„±:**

```cpp
// VectorVM.h:1-50
// SIMD í­ ì •ì˜
#define VECTOR_WIDTH (128)           // 128 bits
#define VECTOR_WIDTH_BYTES (16)      // 16 bytes
#define VECTOR_WIDTH_FLOATS (4)      // 4 floats (SSE)

// VectorVMì€ 4ê°œ íŒŒí‹°í´ì„ ë™ì‹œì— ì²˜ë¦¬ (SIMD)
// - SSE: __m128 (4 Ã— float)
// - AVX: __m256 (8 Ã— float) - ì¼ë¶€ í”Œë«í¼
```

**OpCode êµ¬ì¡° (178ê°œ OpCode):**

```cpp
// VectorVM.h:100-300 (ì¼ë¶€ ë°œì·Œ)
#define VVM_OP_XM_LIST \
VVM_OP_XM( done, Other, 0, 0, done, 0, 0, VVM_INS_PARAM_FFFFFF) /* 0 */\
VVM_OP_XM( add, Op, 2, 1, f, 0, 2, VVM_INS_PARAM_FFFFFF) /* 1 */\
VVM_OP_XM( sub, Op, 2, 1, f, 2, 3, VVM_INS_PARAM_FFFFFF) /* 2 */\
VVM_OP_XM( mul, Op, 2, 1, f, 5, 8, VVM_INS_PARAM_FFFFFF) /* 3 */\
VVM_OP_XM( div, Op, 2, 1, f, 12, 15, VVM_INS_PARAM_FFFFFF) /* 4 */\
VVM_OP_XM( mad, Op, 3, 1, f, 0, 0, VVM_INS_PARAM_FFFFFF) /* 5 - Multiply-Add */\
// ... ê¸°ë³¸ ì—°ì‚°ìë“¤ ...
VVM_OP_XM( addi, Op, 2, 1, i, 0, 2, VVM_INS_PARAM_FFFFFF) /* 20 - Integer Add */\
// ... ì •ìˆ˜ ì—°ì‚°ë“¤ ...
VVM_OP_XM( cmplt, Op, 2, 1, f, 0, 0, VVM_INS_PARAM_FFFFFF) /* 40 - Compare Less Than */\
// ... ë¹„êµ ì—°ì‚°ë“¤ ...
VVM_OP_XM( select, Op, 3, 1, f, 0, 0, VVM_INS_PARAM_FFFFFF) /* 50 - Conditional Select */\
// ... ë²¡í„° ì—°ì‚°ë“¤ ...
VVM_OP_XM( sin, Op, 1, 1, f, 0, 0, VVM_INS_PARAM_FFFFFF) /* 60 */\
VVM_OP_XM( cos, Op, 1, 1, f, 0, 0, VVM_INS_PARAM_FFFFFF) /* 61 */\
// ... ìˆ˜í•™ í•¨ìˆ˜ë“¤ ...

// ğŸ”¥ Merged OpCodes (ìµœì í™”ëœ ì¡°í•© ì—°ì‚°) - ì•½ 48ê°œ
VVM_OP_XM( mad_add, Op, 4, 1, f, 0, 0, VVM_INS_PARAM_FFFFFF) /* 130 - (A*B + C) + D */\
VVM_OP_XM( mul_mad0, Op, 4, 1, f, 0, 0, VVM_INS_PARAM_FFFFFF) /* 137 - (A*B) * (C*D + E) */\
VVM_OP_XM( add_mul, Op, 3, 1, f, 0, 0, VVM_INS_PARAM_FFFFFF) /* 140 - (A + B) * C */\
VVM_OP_XM( mul_add_mul, Op, 5, 1, f, 0, 0, VVM_INS_PARAM_FFFFFF) /* 145 - (A*B + C*D) */\
// ... ìì£¼ ì‚¬ìš©ë˜ëŠ” íŒ¨í„´ë“¤ ì¡°í•© ...
```

**OpCode ë¶„ë¥˜:**

| ì¹´í…Œê³ ë¦¬ | OpCode ê°œìˆ˜ | ì˜ˆì‹œ |
|---------|------------|------|
| **ê¸°ë³¸ ì‚°ìˆ ** | ~20 | add, sub, mul, div, mad |
| **ì •ìˆ˜ ì—°ì‚°** | ~15 | addi, subi, muli, divi |
| **ë¹„êµ ì—°ì‚°** | ~10 | cmplt, cmple, cmpeq |
| **ë²¡í„° ì—°ì‚°** | ~15 | dot3, cross, length, normalize |
| **ìˆ˜í•™ í•¨ìˆ˜** | ~20 | sin, cos, exp, log, sqrt, pow |
| **ë¹„íŠ¸ ì—°ì‚°** | ~10 | bit_and, bit_or, bit_xor |
| **ì œì–´ íë¦„** | ~5 | select (ì¡°ê±´ë¶€ ì„ íƒ) |
| **ë©”ëª¨ë¦¬ ì ‘ê·¼** | ~15 | load, store, gather, scatter |
| **ğŸ”¥ Merged Ops** | ~48 | mad_add, mul_mad0, add_mul ë“± |
| **ê¸°íƒ€** | ~20 | done, nop, debug ë“± |

### VectorVM ë°”ì´íŠ¸ì½”ë“œ ì‹¤í–‰ íë¦„

```
VectorVM::Exec(Context) í˜¸ì¶œ íë¦„:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [1] ì´ˆê¸°í™”                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  - ë°”ì´íŠ¸ì½”ë“œ ë¡œë“œ (FNiagaraVMExecutableData)            â”‚          â”‚
â”‚  â”‚  - ë ˆì§€ìŠ¤í„° í…Œì´ë¸” ì¤€ë¹„ (Temp, Constant, Input, Output)  â”‚          â”‚
â”‚  â”‚  - DataInterface ë°”ì¸ë”©                                  â”‚          â”‚
â”‚  â”‚  - ì¸ìŠ¤í„´ìŠ¤ ê°œìˆ˜ í™•ì¸ (NumInstances)                     â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚                                                               â”‚
â”‚         â†“                                                               â”‚
â”‚  [2] SIMD ë°°ì¹˜ ë£¨í”„ (4ê°œì”© ì²˜ë¦¬)                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  for (int32 i = 0; i < NumInstances; i += 4)            â”‚          â”‚
â”‚  â”‚  {                                                       â”‚          â”‚
â”‚  â”‚      // 4ê°œ íŒŒí‹°í´ì„ ë™ì‹œì— ì²˜ë¦¬ (SIMD)                 â”‚          â”‚
â”‚  â”‚      __m128 TempRegs[NumTempRegs];                      â”‚          â”‚
â”‚  â”‚      __m128* InputRegs = ...;                           â”‚          â”‚
â”‚  â”‚      __m128* OutputRegs = ...;                          â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚      // OpCode ì‹¤í–‰ ë£¨í”„                                â”‚          â”‚
â”‚  â”‚      for (int32 OpIdx = 0; OpIdx < NumOps; ++OpIdx)    â”‚          â”‚
â”‚  â”‚      {                                                   â”‚          â”‚
â”‚  â”‚          uint8 OpCode = ByteCode[OpIdx];                â”‚          â”‚
â”‚  â”‚          switch (OpCode)                                â”‚          â”‚
â”‚  â”‚          {                                               â”‚          â”‚
â”‚  â”‚              case VVM_add:                              â”‚          â”‚
â”‚  â”‚                  // TempRegs[Dst] = TempRegs[A] + TempRegs[B]â”‚   â”‚
â”‚  â”‚                  TempRegs[Dst] = _mm_add_ps(TempRegs[A], TempRegs[B]);â”‚ â”‚
â”‚  â”‚                  break;                                 â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚              case VVM_mul:                              â”‚          â”‚
â”‚  â”‚                  TempRegs[Dst] = _mm_mul_ps(TempRegs[A], TempRegs[B]);â”‚ â”‚
â”‚  â”‚                  break;                                 â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚              case VVM_mad:                              â”‚          â”‚
â”‚  â”‚                  // (A * B) + C                         â”‚          â”‚
â”‚  â”‚                  __m128 Mul = _mm_mul_ps(TempRegs[A], TempRegs[B]);â”‚  â”‚
â”‚  â”‚                  TempRegs[Dst] = _mm_add_ps(Mul, TempRegs[C]);â”‚      â”‚
â”‚  â”‚                  break;                                 â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚              case VVM_mad_add:  // ğŸ”¥ Merged OpCode    â”‚          â”‚
â”‚  â”‚                  // (A * B + C) + D                     â”‚          â”‚
â”‚  â”‚                  __m128 Mul = _mm_mul_ps(TempRegs[A], TempRegs[B]);â”‚  â”‚
â”‚  â”‚                  __m128 Add1 = _mm_add_ps(Mul, TempRegs[C]);â”‚        â”‚
â”‚  â”‚                  TempRegs[Dst] = _mm_add_ps(Add1, TempRegs[D]);â”‚    â”‚
â”‚  â”‚                  break;                                 â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚              // ... 178ê°œ OpCode í•¸ë“¤ë§ ...             â”‚          â”‚
â”‚  â”‚          }                                               â”‚          â”‚
â”‚  â”‚      }                                                   â”‚          â”‚
â”‚  â”‚  }                                                       â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚         â”‚                                                               â”‚
â”‚         â†“                                                               â”‚
â”‚  [3] ë‚˜ë¨¸ì§€ íŒŒí‹°í´ ì²˜ë¦¬ (< 4ê°œ)                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  if (RemainderCount > 0)                                â”‚          â”‚
â”‚  â”‚  {                                                       â”‚          â”‚
â”‚  â”‚      // ìŠ¤ì¹¼ë¼ ëª¨ë“œë¡œ ë‚˜ë¨¸ì§€ 1~3ê°œ ì²˜ë¦¬                  â”‚          â”‚
â”‚  â”‚      // ë˜ëŠ” ë§ˆìŠ¤í‚¹ëœ SIMD ì—°ì‚°                          â”‚          â”‚
â”‚  â”‚  }                                                       â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Merged OpCodes ìµœì í™”

**ë¬¸ì œ: ë¹ˆë²ˆí•œ OpCode ì¡°í•©**

```cpp
// ìì£¼ ë‚˜íƒ€ë‚˜ëŠ” ì½”ë“œ íŒ¨í„´:
// ì˜ˆì‹œ 1: (A * B + C) + D
OpCode 1: VVM_mul  (A, B â†’ Temp0)
OpCode 2: VVM_add  (Temp0, C â†’ Temp1)
OpCode 3: VVM_add  (Temp1, D â†’ Output)

// ë¬¸ì œ:
// - 3ê°œ OpCode = 3ë²ˆ ë””ìŠ¤íŒ¨ì¹˜ ì˜¤ë²„í—¤ë“œ
// - 2ê°œ ì„ì‹œ ë ˆì§€ìŠ¤í„° ì‚¬ìš©
// - 3ë²ˆì˜ ë©”ëª¨ë¦¬ ì“°ê¸°/ì½ê¸°
```

**í•´ê²°ì±…: Merged OpCode**

```cpp
// ğŸ”¥ ìµœì í™”ëœ ë‹¨ì¼ OpCode:
OpCode 1: VVM_mad_add  (A, B, C, D â†’ Output)

// ì´ì :
// - 1ê°œ OpCode = 1ë²ˆ ë””ìŠ¤íŒ¨ì¹˜ (3ë°° ë¹ ë¦„)
// - ì„ì‹œ ë ˆì§€ìŠ¤í„° ë¶ˆí•„ìš”
// - 1ë²ˆì˜ ë©”ëª¨ë¦¬ ì“°ê¸°
// - ì»´íŒŒì¼ëŸ¬ê°€ ìë™ìœ¼ë¡œ ê°ì§€í•˜ì—¬ ìƒì„±
```

**Merged OpCode ìƒì„± ì˜ˆì‹œ:**

```
Niagara ê·¸ë˜í”„:
[Input: Velocity]
      â†“
[Input: DeltaTime]
      â†“
[Multiply: Velocity * DeltaTime â†’ Displacement]
      â†“
[Input: Position]
      â†“
[Add: Position + Displacement â†’ TempPos]
      â†“
[Input: Offset]
      â†“
[Add: TempPos + Offset â†’ FinalPosition]
      â†“
[Output: Particles.Position]

ì»´íŒŒì¼ëŸ¬ ë¶„ì„:
- íŒ¨í„´ ê°ì§€: (A * B) + C + D
- Merged OpCode ì„ íƒ: VVM_mad_add

ìƒì„±ëœ ë°”ì´íŠ¸ì½”ë“œ:
OpCode: VVM_mad_add
  Src1: Velocity (Input)
  Src2: DeltaTime (Input)
  Src3: Position (Input)
  Src4: Offset (Input)
  Dst: Particles.Position (Output)

â†’ 4ê°œ OpCode â†’ 1ê°œ OpCode (4ë°° ì••ì¶•!)
```

**ì„±ëŠ¥ ë¹„êµ (10,000 íŒŒí‹°í´):**

```
ì¼ë°˜ OpCode (Multiply + Add + Add):
- OpCode ì‹¤í–‰: 3 Ã— 10,000 / 4 = 7,500 SIMD ì—°ì‚°
- ë””ìŠ¤íŒ¨ì¹˜ ì˜¤ë²„í—¤ë“œ: 3 Ã— 2,500 = 7,500íšŒ
- ì´ ì‹œê°„: ~1.2ms

Merged OpCode (mad_add):
- OpCode ì‹¤í–‰: 1 Ã— 10,000 / 4 = 2,500 SIMD ì—°ì‚°
- ë””ìŠ¤íŒ¨ì¹˜ ì˜¤ë²„í—¤ë“œ: 2,500íšŒ
- ì´ ì‹œê°„: ~0.4ms (3ë°° ë¹ ë¦„!)
```

### ë ˆì§€ìŠ¤í„° í• ë‹¹ ìµœì í™”

**ë ˆì§€ìŠ¤í„° íƒ€ì…:**

```cpp
// VectorVM ë ˆì§€ìŠ¤í„° ì¢…ë¥˜
enum class EVectorVMRegisterType
{
    Temp,       // ì„ì‹œ ë ˆì§€ìŠ¤í„° (ìŠ¤íƒ í• ë‹¹)
    Constant,   // ìƒìˆ˜ ë ˆì§€ìŠ¤í„° (ì½ê¸° ì „ìš©)
    Input,      // ì…ë ¥ ë ˆì§€ìŠ¤í„° (DataSet ì½ê¸°)
    Output,     // ì¶œë ¥ ë ˆì§€ìŠ¤í„° (DataSet ì“°ê¸°)
};
```

**ë ˆì§€ìŠ¤í„° í• ë‹¹ ì „ëµ:**

```
ì»´íŒŒì¼ëŸ¬ ìµœì í™”:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [1] ìƒëª…ì£¼ê¸° ë¶„ì„                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  OpCode 1: ADD  (A, B â†’ Temp0)                          â”‚          â”‚
â”‚  â”‚  OpCode 2: MUL  (Temp0, C â†’ Temp1)                      â”‚          â”‚
â”‚  â”‚  OpCode 3: SUB  (Temp1, D â†’ Output)                     â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ë¶„ì„:                                                   â”‚          â”‚
â”‚  â”‚  - Temp0 ìƒëª…ì£¼ê¸°: OpCode 1 â†’ OpCode 2                 â”‚          â”‚
â”‚  â”‚  - Temp1 ìƒëª…ì£¼ê¸°: OpCode 2 â†’ OpCode 3                 â”‚          â”‚
â”‚  â”‚  â†’ Temp0ê³¼ Temp1 ì¬ì‚¬ìš© ë¶ˆê°€ (ê²¹ì¹¨)                     â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â”‚  [2] ë ˆì§€ìŠ¤í„° ì¬ì‚¬ìš©                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚  OpCode 1: ADD  (A, B â†’ Temp0)                          â”‚          â”‚
â”‚  â”‚  OpCode 2: MUL  (Temp0, C â†’ Temp1)                      â”‚          â”‚
â”‚  â”‚  OpCode 3: SUB  (Temp1, D â†’ Output)                     â”‚          â”‚
â”‚  â”‚  OpCode 4: DIV  (E, F â†’ Temp0)  // Temp0 ì¬ì‚¬ìš©!       â”‚          â”‚
â”‚  â”‚                                                          â”‚          â”‚
â”‚  â”‚  ë¶„ì„:                                                   â”‚          â”‚
â”‚  â”‚  - OpCode 3 ì´í›„ Temp0 ì‚¬ìš© ì¢…ë£Œ                        â”‚          â”‚
â”‚  â”‚  - OpCode 4ì—ì„œ Temp0 ì¬ì‚¬ìš© ê°€ëŠ¥                       â”‚          â”‚
â”‚  â”‚  â†’ ë ˆì§€ìŠ¤í„° ê°œìˆ˜ ìµœì†Œí™” (ë©”ëª¨ë¦¬ ì ˆì•½)                   â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### SIMD ëª…ë ¹ì–´ ìµœì í™”

**SSE/AVX í™œìš©:**

```cpp
// SSE (128-bit, 4 floats)
__m128 VectorAdd(__m128 A, __m128 B)
{
    return _mm_add_ps(A, B);  // ë‹¨ì¼ ëª…ë ¹ì–´ë¡œ 4ê°œ ë§ì…ˆ
}

// AVX (256-bit, 8 floats) - ì§€ì› í”Œë«í¼
__m256 VectorAddAVX(__m256 A, __m256 B)
{
    return _mm256_add_ps(A, B);  // ë‹¨ì¼ ëª…ë ¹ì–´ë¡œ 8ê°œ ë§ì…ˆ
}

// ì„±ëŠ¥:
// - ìŠ¤ì¹¼ë¼: 1 float Ã— 4 cycles = 4 cycles
// - SSE: 4 floats Ã— 1 cycle = 1 cycle (4ë°° ë¹ ë¦„)
// - AVX: 8 floats Ã— 1 cycle = 1 cycle (8ë°° ë¹ ë¦„)
```

**ë³µì¡í•œ ì—°ì‚° ìµœì í™” ì˜ˆì‹œ:**

```cpp
// ë²¡í„° ì •ê·œí™” (Normalize)
__m128 VectorNormalize(__m128 X, __m128 Y, __m128 Z)
{
    // Length = sqrt(X*X + Y*Y + Z*Z)
    __m128 XX = _mm_mul_ps(X, X);
    __m128 YY = _mm_mul_ps(Y, Y);
    __m128 ZZ = _mm_mul_ps(Z, Z);
    __m128 Sum = _mm_add_ps(_mm_add_ps(XX, YY), ZZ);
    __m128 Length = _mm_sqrt_ps(Sum);

    // ì—­ìˆ˜ ê³„ì‚° (1/Length) - ë¹ ë¥¸ ê·¼ì‚¬ì¹˜ ì‚¬ìš©
    __m128 InvLength = _mm_rsqrt_ps(Sum);  // ì—­ì œê³±ê·¼ ê·¼ì‚¬ (ë§¤ìš° ë¹ ë¦„)

    // Normalize
    __m128 NormX = _mm_mul_ps(X, InvLength);
    __m128 NormY = _mm_mul_ps(Y, InvLength);
    __m128 NormZ = _mm_mul_ps(Z, InvLength);

    return NormX;  // (NormX, NormY, NormZ ê°ê° ë°˜í™˜)
}

// ì„±ëŠ¥:
// - ìŠ¤ì¹¼ë¼ ë²„ì „: ~20 cycles per particle
// - SIMD ë²„ì „: ~20 cycles for 4 particles (4ë°° ë¹ ë¦„)
```

---

## ğŸ’¡ ì‹¤ì „ ì˜ˆì‹œ (Practical Examples)

### âœ… ì¢‹ì€ ì˜ˆ: ê°„ë‹¨í•œ ê·¸ë˜í”„ â†’ HLSL ë³€í™˜

```cpp
// Niagara ê·¸ë˜í”„ ì˜ˆì‹œ:
/*
[Input: Particles.Position (Vector3)]
        â†“
[Input: Particles.Velocity (Vector3)]
        â†“
[Input: Engine.DeltaTime (Float)]
        â†“
[Multiply: Velocity * DeltaTime â†’ TempVar0 (Vector3)]
        â†“
[Add: Position + TempVar0 â†’ NewPosition (Vector3)]
        â†“
[Output: Particles.Position = NewPosition]
*/

// âœ… ë³€í™˜ëœ HLSL ì½”ë“œ (FNiagaraHlslTranslator ì¶œë ¥):
/*
// Uniforms
cbuffer EmitterParameters
{
    float Engine_DeltaTime;
};

// Main Function
void ParticleUpdateMain(inout float3 Particles_Position, inout float3 Particles_Velocity)
{
    // [Multiply] Velocity * DeltaTime
    float3 TempVar0 = Particles_Velocity * Engine_DeltaTime;

    // [Add] Position + TempVar0
    float3 NewPosition = Particles_Position + TempVar0;

    // [Output] Write to Particles.Position
    Particles_Position = NewPosition;
}
*/

// âœ… ìƒì„±ëœ VectorVM ë°”ì´íŠ¸ì½”ë“œ (ì˜ì‚¬ ì½”ë“œ):
/*
OpCode: LOAD_INPUT
Dest: Reg0 (Particles.Velocity)

OpCode: LOAD_UNIFORM
Dest: Reg1 (Engine.DeltaTime)

OpCode: MUL_VEC3
Src1: Reg0 (Velocity)
Src2: Reg1 (DeltaTime, broadcast to Vec3)
Dest: Reg2 (TempVar0)

OpCode: LOAD_ATTRIBUTE
Dest: Reg3 (Particles.Position)

OpCode: ADD_VEC3
Src1: Reg3 (Position)
Src2: Reg2 (TempVar0)
Dest: Reg3 (NewPosition)

OpCode: STORE_ATTRIBUTE
Src: Reg3
Dest: Particles.Position
*/
```

### âœ… ì¢‹ì€ ì˜ˆ: ìµœì í™” - Constant Folding

```cpp
// Niagara ê·¸ë˜í”„ (ìµœì í™” ì „):
/*
[Constant: 3.14]
        â†“
[Constant: 2.0]
        â†“
[Multiply: 3.14 * 2.0 â†’ TempVar0]
        â†“
[Input: Particles.Velocity]
        â†“
[Multiply: Velocity * TempVar0 â†’ Output]
*/

// âŒ ìµœì í™” ì—†ì´ ìƒì„±ëœ HLSL (ë¹„íš¨ìœ¨):
/*
void Main()
{
    float Const0 = 3.14;
    float Const1 = 2.0;
    float TempVar0 = Const0 * Const1;  // ëŸ°íƒ€ì„ì— ê³„ì‚°! (ë¹„íš¨ìœ¨)
    float3 Velocity = Particles_Velocity;
    float3 Output = Velocity * TempVar0;
    Particles_Velocity = Output;
}
*/

// âœ… Constant Folding ìµœì í™” í›„:
/*
void Main()
{
    // ì»´íŒŒì¼ëŸ¬ê°€ 3.14 * 2.0 = 6.28ì„ ë¯¸ë¦¬ ê³„ì‚°
    static const float OptimizedConst = 6.28;
    float3 Velocity = Particles_Velocity;
    float3 Output = Velocity * OptimizedConst;  // ê³±ì…ˆ 1íšŒë§Œ!
    Particles_Velocity = Output;
}
*/

// ì„±ëŠ¥ í–¥ìƒ:
// - ëŸ°íƒ€ì„ ê³±ì…ˆ 1íšŒ ì œê±°
// - 10k íŒŒí‹°í´ Ã— 60 FPS = 600,000íšŒ ê³±ì…ˆ ì œê±°!
```

### âœ… ì¢‹ì€ ì˜ˆ: ìµœì í™” - Dead Code Elimination

```cpp
// Niagara ê·¸ë˜í”„ (ìµœì í™” ì „):
/*
[Input: Particles.Position]
        â†“
[Add: Position + float3(1, 0, 0) â†’ TempVar0]  // ì‚¬ìš©ë˜ì§€ ì•ŠìŒ!
        â†“
[Input: Particles.Velocity]
        â†“
[Output: Particles.Velocity]  // TempVar0ì„ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
*/

// âŒ ìµœì í™” ì—†ì´ ìƒì„±ëœ HLSL (ë¶ˆí•„ìš”í•œ ê³„ì‚°):
/*
void Main()
{
    float3 Position = Particles_Position;
    float3 TempVar0 = Position + float3(1, 0, 0);  // ì‚¬ìš© ì•ˆ í•¨!
    float3 Velocity = Particles_Velocity;
    Particles_Velocity = Velocity;
}
*/

// âœ… Dead Code Elimination í›„:
/*
void Main()
{
    // TempVar0 ê´€ë ¨ ì½”ë“œ ì™„ì „íˆ ì œê±°ë¨
    float3 Velocity = Particles_Velocity;
    Particles_Velocity = Velocity;
}
*/

// ì¶”ê°€ ìµœì í™” (Copy Propagation):
/*
void Main()
{
    // Velocity ë³€ìˆ˜ë„ ì œê±° (ì§ì ‘ ëŒ€ì…)
    // ì•„ë¬´ ì‘ì—…ë„ í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ í•¨ìˆ˜ ì „ì²´ê°€ ë¹ˆ í•¨ìˆ˜ë¡œ ìµœì í™”ë¨
}
*/
```

### âŒ ë‚˜ìœ ì˜ˆ: íƒ€ì… ë¶ˆì¼ì¹˜

```cpp
// âŒ ì˜ëª»ëœ ê·¸ë˜í”„ ì—°ê²°
/*
[Input: Particles.Position (Vector3)]
        â†“
[Input: Engine.DeltaTime (Float)]
        â†“
[Add: Position + DeltaTime â†’ ???]  // íƒ€ì… ë¶ˆì¼ì¹˜!
*/

// ì»´íŒŒì¼ ì—ëŸ¬:
/*
Error: Type mismatch in node "Add"
  Input A: Vector3 (Particles.Position)
  Input B: Float (Engine.DeltaTime)
  Expected: Both inputs must be of the same type

Location: Graph "ParticleUpdateScript", Node "Add Vector"

Fix:
1. Use "Multiply" to convert Float to Vector3 (broadcast)
2. Use separate Add operations for X, Y, Z components
*/

// ì—ë””í„°ì—ì„œ:
// - "Add" ë…¸ë“œê°€ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ í‘œì‹œë¨
// - ë…¸ë“œ ìœ„ì— ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
// - ì»´íŒŒì¼ ì‹¤íŒ¨, ì‹¤í–‰ ë¶ˆê°€
```

### âœ… ì¢‹ì€ ì˜ˆ: DataInterface HLSL ìƒì„±

```cpp
// Niagara ê·¸ë˜í”„:
/*
[DataInterface: CollisionQuery]
        â†“
[Function Call: PerformCollisionQueryLine]
    â”œâ”€ Start: Particles.Position
    â”œâ”€ End: Particles.Position + Particles.Velocity * DeltaTime
    â””â”€ Outputs: bHit, HitLocation, HitNormal
        â†“
[If: bHit]
    Then: Reflect Velocity
        â†“
[Output: Particles.Velocity]
*/

// âœ… FNiagaraHlslTranslatorê°€ ìƒì„±í•œ HLSL:
/*
// DataInterface í•¨ìˆ˜ ì„ ì–¸ (DefineDataInterfaceHLSL)
void CollisionQuery_PerformCollisionQueryLine(
    float3 Start,
    float3 End,
    out bool bHit,
    out float3 HitLocation,
    out float3 HitNormal);

// Main í•¨ìˆ˜ (DefineMain)
void ParticleUpdateMain(
    inout float3 Particles_Position,
    inout float3 Particles_Velocity)
{
    // DataInterface í•¨ìˆ˜ í˜¸ì¶œ
    bool bHit;
    float3 HitLocation;
    float3 HitNormal;

    float3 TraceEnd = Particles_Position + Particles_Velocity * Engine_DeltaTime;

    CollisionQuery_PerformCollisionQueryLine(
        Particles_Position,
        TraceEnd,
        bHit,
        HitLocation,
        HitNormal
    );

    // ì¡°ê±´ë¬¸
    if (bHit)
    {
        // Reflect ê³„ì‚°
        float3 ReflectedVelocity = reflect(Particles_Velocity, HitNormal);
        Particles_Velocity = ReflectedVelocity * 0.8;  // Bounciness
        Particles_Position = HitLocation + HitNormal * 0.1;  // Offset
    }
}
*/

// CPU ì‹¤í–‰ ì‹œ:
// - CollisionQuery_PerformCollisionQueryLineì€ FVMExternalFunctionìœ¼ë¡œ ë°”ì¸ë”©ë¨
// - C++ êµ¬í˜„ í˜¸ì¶œ (UNiagaraDataInterfaceCollisionQuery::PerformLineTrace)

// GPU ì‹¤í–‰ ì‹œ:
// - CollisionQueryëŠ” GPUì—ì„œ ì§€ì› ì•ˆ í•¨ â†’ ì»´íŒŒì¼ ì—ëŸ¬
// - ëŒ€ì‹  AsyncGpuTrace ì‚¬ìš© í•„ìš”
```

---

## ğŸ“Š ì„±ëŠ¥ ìµœì í™” (Performance Optimization)

### ì»´íŒŒì¼ ì‹œê°„ ìµœì í™”

**1. Incremental Compilation (ì¦ë¶„ ì»´íŒŒì¼):**

```cpp
// âœ… ChangeId ê¸°ë°˜ ì¦ë¶„ ì»´íŒŒì¼
void CheckIfRecompileNeeded(UNiagaraScript* Script)
{
    FGuid CurrentChangeId = Script->GetSource()->GetChangeID();
    FGuid CachedChangeId = Script->GetVMExecutableDataCompilationId().ScriptVersionID;

    if (CurrentChangeId == CachedChangeId)
    {
        // âœ… ë³€ê²½ ì—†ìŒ â†’ ì»´íŒŒì¼ ìŠ¤í‚µ
        UE_LOG(LogNiagara, Log, TEXT("Script up to date, skipping compile"));
        return;
    }

    // âŒ ë³€ê²½ ê°ì§€ â†’ ì¬ì»´íŒŒì¼ í•„ìš”
    Script->RequestCompile(FGuid(), false);
}
```

**2. DDC í™œìš©:**

```cpp
// âœ… DDC ìºì‹œ í™•ì¸
bool TryLoadFromDDC(UNiagaraScript* Script)
{
    FString DDCKey = UNiagaraScript::BuildNiagaraDDCKeyString(
        Script->GetVMExecutableDataCompilationId(),
        Script->GetPathName()
    );

    TArray<uint8> CachedData;
    bool bCacheHit = GetDerivedDataCacheRef().GetSynchronous(*DDCKey, CachedData);

    if (bCacheHit)
    {
        // âœ… ìºì‹œ íˆíŠ¸ â†’ ì¦‰ì‹œ ë¡œë“œ (<100ms)
        FMemoryReader Ar(CachedData);
        Script->GetVMExecutableData().SerializeData(Ar);

        UE_LOG(LogNiagara, Log, TEXT("DDC HIT - Loaded cached compile result"));
        return true;
    }

    // âŒ ìºì‹œ ë¯¸ìŠ¤ â†’ ì¬ì»´íŒŒì¼ í•„ìš” (~1000ms)
    UE_LOG(LogNiagara, Warning, TEXT("DDC MISS - Recompile needed"));
    return false;
}
```

**3. ë³‘ë ¬ ì»´íŒŒì¼:**

```cpp
// âœ… ë‹¤ìˆ˜ ìŠ¤í¬ë¦½íŠ¸ ë³‘ë ¬ ì»´íŒŒì¼
void CompileMultipleScriptsInParallel(TArray<UNiagaraScript*> Scripts)
{
    // ë¹„ë™ê¸° ì»´íŒŒì¼ ìš”ì²­
    TArray<int32> JobIDs;

    for (UNiagaraScript* Script : Scripts)
    {
        int32 JobID = Script->RequestExternallyManagedAsyncCompile(...);
        JobIDs.Add(JobID);
    }

    // ëª¨ë“  ì»´íŒŒì¼ ì™„ë£Œ ëŒ€ê¸°
    for (int32 JobID : JobIDs)
    {
        while (true)
        {
            TOptional<FNiagaraCompileResults> Result =
                Compiler->GetCompileResult(JobID, /*bWait=*/ false);

            if (Result.IsSet())
                break;

            FPlatformProcess::Sleep(0.01f);
        }
    }

    // ì„±ëŠ¥:
    // - ìˆœì°¨ ì»´íŒŒì¼: 10ê°œ Ã— 1000ms = 10,000ms
    // - ë³‘ë ¬ ì»´íŒŒì¼: ~2,000ms (5ë°° ë¹ ë¦„, CPU ì½”ì–´ í™œìš©)
}
```

### ëŸ°íƒ€ì„ ì„±ëŠ¥ ìµœì í™”

**1. SIMD ì¹œí™”ì  ì½”ë“œ ì‘ì„±:**

```cpp
// âœ… SIMD ìµœì í™” ê°€ëŠ¥í•œ ì½”ë“œ
/*
// ë²¡í„° ì—°ì‚° ì‚¬ìš© (SIMD í™œìš©)
Particles.Position += Particles.Velocity * DeltaTime;
Particles.Velocity += Gravity * DeltaTime;

// VectorVMì´ 4ê°œ íŒŒí‹°í´ì„ ë™ì‹œ ì²˜ë¦¬:
// PositionX[0..3] = PositionX[0..3] + VelocityX[0..3] * DeltaTime (SIMD)
*/

// âŒ SIMD ìµœì í™” ì–´ë ¤ìš´ ì½”ë“œ
/*
// ìŠ¤ì¹¼ë¼ ì—°ì‚° ë¶„ë¦¬ (SIMD í™œìš© ë¶ˆê°€)
Particles.Position.X += Particles.Velocity.X * DeltaTime;
Particles.Position.Y += Particles.Velocity.Y * DeltaTime;
Particles.Position.Z += Particles.Velocity.Z * DeltaTime;

// VectorVMì´ ê°ê° ë³„ë„ë¡œ ì²˜ë¦¬í•´ì•¼ í•¨ (ëŠë¦¼)
*/
```

**2. ë¶„ê¸°ë¬¸ ìµœì†Œí™” (GPU):**

```cpp
// âŒ GPUì—ì„œ ëŠë¦° ì½”ë“œ (ë¶„ê¸°ê°€ ë§ìŒ)
/*
if (Particles.Age < 1.0)
{
    Particles.Color = LerpColor(StartColor, MidColor, Particles.Age);
}
else if (Particles.Age < 2.0)
{
    Particles.Color = LerpColor(MidColor, EndColor, Particles.Age - 1.0);
}
else
{
    Particles.Color = EndColor;
}
*/

// âœ… GPU ìµœì í™” ì½”ë“œ (ë¶„ê¸° ì œê±°)
/*
// Curve ì‚¬ìš©ìœ¼ë¡œ ë¶„ê¸° ì œê±°
Particles.Color = SampleCurve(ColorCurve, Particles.NormalizedAge);

// GPUì—ì„œ warp divergence ì—†ìŒ â†’ ë¹ ë¦„
*/
```

---

## ğŸ”§ ë””ë²„ê¹… ë° íŠ¸ëŸ¬ë¸”ìŠˆíŒ… (Debugging & Troubleshooting)

### í”í•œ ì—ëŸ¬ì™€ í•´ê²° ë°©ë²•

**1. \"Compilation failed - type mismatch\"**

```
ì›ì¸: ë…¸ë“œ ì—°ê²° íƒ€ì… ë¶ˆì¼ì¹˜

í•´ê²°ì±…:
1. ì—ë””í„°ì—ì„œ ë¹¨ê°„ìƒ‰ ë…¸ë“œ ì°¾ê¸°
2. ì—°ê²°ëœ í•€ì˜ íƒ€ì… í™•ì¸
3. íƒ€ì… ë³€í™˜ ë…¸ë“œ ì¶”ê°€ ë˜ëŠ” ì˜¬ë°”ë¥¸ íƒ€ì…ìœ¼ë¡œ ìˆ˜ì •
```

**2. \"Failed to compile shader for platform\"**

```
ì›ì¸: GPU Shader ì»´íŒŒì¼ ì‹¤íŒ¨

í•´ê²°ì±…:
1. LastHlslTranslationGPU í™•ì¸ (ìƒì„±ëœ HLSL ì½”ë“œ)
2. HLSL ë¬¸ë²• ì˜¤ë¥˜ í™•ì¸
3. DataInterface GPU ì§€ì› ì—¬ë¶€ í™•ì¸
4. í”Œë«í¼ë³„ Shader Model ì§€ì› í™•ì¸
```

**3. \"DDC cache miss - compilation slow\"**

```
ì›ì¸: DDC ìºì‹œ ì—†ìŒ

í•´ê²°ì±…:
1. DDC ê²½ë¡œ í™•ì¸ (Engine.ini)
2. ë„¤íŠ¸ì›Œí¬ DDC ì„¤ì • (íŒ€ í™˜ê²½)
3. ë¡œì»¬ DDC ì‚­ì œ í›„ ì¬ìƒì„±
```

### ì»´íŒŒì¼ ë¡œê·¸ í™•ì¸

```cpp
// âœ… ì»´íŒŒì¼ ê²°ê³¼ í™•ì¸
#if WITH_EDITOR
void CheckCompilationResult(UNiagaraScript* Script)
{
    const FNiagaraVMExecutableData& VMData = Script->GetVMExecutableData();

    // ì»´íŒŒì¼ ìƒíƒœ í™•ì¸
    ENiagaraScriptCompileStatus Status = VMData.LastCompileStatus;

    switch (Status)
    {
        case ENiagaraScriptCompileStatus::NCS_UpToDate:
            UE_LOG(LogNiagara, Log, TEXT("Compilation successful"));
            break;

        case ENiagaraScriptCompileStatus::NCS_Error:
            UE_LOG(LogNiagara, Error, TEXT("Compilation failed!"));

            // ì—ëŸ¬ ë©”ì‹œì§€ ì¶œë ¥
            for (const FNiagaraCompileEvent& Event : VMData.LastCompileEvents)
            {
                if (Event.Severity == FNiagaraCompileEventSeverity::Error)
                {
                    UE_LOG(LogNiagara, Error, TEXT("  Error: %s"), *Event.Message);
                    UE_LOG(LogNiagara, Error, TEXT("  Node: %s"), *Event.NodeGuid.ToString());
                }
            }
            break;

        case ENiagaraScriptCompileStatus::NCS_Unknown:
            UE_LOG(LogNiagara, Warning, TEXT("Compilation status unknown"));
            break;
    }

    // HLSL ì½”ë“œ ì¶œë ¥ (ë””ë²„ê¹…)
    if (!VMData.LastHlslTranslationGPU.IsEmpty())
    {
        UE_LOG(LogNiagara, Log, TEXT("Generated HLSL:"));
        UE_LOG(LogNiagara, Log, TEXT("%s"), *VMData.LastHlslTranslationGPU);
    }
}
#endif
```

---

## ğŸ“¦ ì»´íŒŒì¼ ê²°ê³¼ë¬¼ ìƒì„¸ (Compilation Output Details)

### UNiagaraScript - Script Asset Container

**ğŸ“‚ ìœ„ì¹˜:** `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraScript.h:781`

**ì—­í• :** Script Assetì˜ ìµœìƒìœ„ ì»¨í…Œì´ë„ˆ. ì»´íŒŒì¼ ê²°ê³¼ë¬¼(VMExecutableData)ê³¼ Source Graphë¥¼ ì†Œìœ .

**í•µì‹¬ ë©¤ë²„:**
```cpp
UCLASS(MinimalAPI)
class UNiagaraScript : public UNiagaraScriptBase
{
    // Script íƒ€ì… (Module, DynamicInput, Function, Emitter, System, Particle)
    UPROPERTY()
    ENiagaraScriptUsage Usage;

    // ì»´íŒŒì¼ëœ ë°”ì´íŠ¸ì½”ë“œ + ë©”íƒ€ë°ì´í„°
    UPROPERTY()
    TArray<FVersionedNiagaraScript> VersionData;

    // ì†ŒìŠ¤ ê·¸ë˜í”„ (Editor Only)
    UNiagaraScriptSourceBase* Source;
};
```

**ì œê³µ ê¸°ëŠ¥:**
- **ë²„ì „ ê´€ë¦¬:** ì—¬ëŸ¬ ë²„ì „ì˜ ìŠ¤í¬ë¦½íŠ¸ ë°ì´í„° ì €ì¥ ê°€ëŠ¥
- **DDC í‚¤ ìƒì„±:** CompileHash ê¸°ë°˜ ìºì‹±
- **Rapid Iteration Parameters:** ëŸ°íƒ€ì„ì— ë³€ê²½ ê°€ëŠ¥í•œ íŒŒë¼ë¯¸í„°

**ì†ŒìŠ¤ ê²€ì¦:**
```cpp
// NiagaraScript.h:239
struct FNiagaraVMExecutableDataId
{
    FGuid CompilerVersionID;
    ENiagaraInterpolatedSpawnMode InterpolatedSpawnMode;
    FNiagaraCompileHash BaseScriptCompileHash;  // ì£¼ìš” ìºì‹œ í‚¤
    TArray<FNiagaraCompileHash> ReferencedCompileHashes;
};
```

### FNiagaraVMExecutableData - ì»´íŒŒì¼ ê²°ê³¼ë¬¼ êµ¬ì¡°ì²´

**ğŸ“‚ ìœ„ì¹˜:** `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraScript.h:397`

**ì—­í• :** ì»´íŒŒì¼ëœ ìŠ¤í¬ë¦½íŠ¸ì˜ ì‹¤í–‰ ê°€ëŠ¥í•œ ëª¨ë“  ë°ì´í„°ë¥¼ ì €ì¥.

**í•µì‹¬ êµ¬ì¡°:**
```cpp
USTRUCT()
struct FNiagaraVMExecutableData
{
    // VM ë°”ì´íŠ¸ì½”ë“œ (ì••ì¶• ê°€ëŠ¥)
    UPROPERTY()
    FNiagaraVMExecutableByteCode ByteCode;

    // VM ì‹¤í–‰ ì •ë³´
    UPROPERTY()
    int32 NumTempRegisters;      // ì„ì‹œ ë ˆì§€ìŠ¤í„° ê°œìˆ˜

    UPROPERTY()
    int32 NumUserPtrs;           // UserPtr (DI Instance Data) ê°œìˆ˜

    // Script Literals (ìƒìˆ˜ ë°ì´í„°)
    UPROPERTY()
    TArray<uint8> ScriptLiterals;

    // Attribute ì •ë³´
    UPROPERTY()
    TArray<FNiagaraVariableBase> Attributes;

    // DataInterface ì •ë³´
    UPROPERTY()
    TArray<FNiagaraScriptDataInterfaceCompileInfo> DataInterfaceInfo;

    // External Function ë°”ì¸ë”©
    UPROPERTY()
    TArray<FVMExternalFunctionBindingInfo> CalledVMExternalFunctions;

    // GPUìš© ì…°ì´ë” íŒŒë¼ë¯¸í„° ë©”íƒ€ë°ì´í„°
    UPROPERTY()
    FNiagaraShaderScriptParametersMetadata ShaderScriptParametersMetadata;

    // ì»´íŒŒì¼ ìƒíƒœ
    UPROPERTY()
    ENiagaraScriptCompileStatus LastCompileStatus;
};
```

**ByteCode ì••ì¶•:**
```cpp
// NiagaraScript.h:354
struct FNiagaraVMExecutableByteCode
{
private:
    UPROPERTY()
    TArray<uint8> Data;          // ì‹¤ì œ ë°”ì´íŠ¸ì½”ë“œ

    UPROPERTY()
    int32 UncompressedSize;      // ì›ë³¸ í¬ê¸° (ì••ì¶•ì‹œ)

public:
    bool HasByteCode() const;
    bool IsCompressed() const;
    bool Compress();             // Oodle ì••ì¶•
    bool Uncompress();           // ì••ì¶• í•´ì œ
};
```

### FNiagaraCompilerJob - ì»´íŒŒì¼ ì‘ì—… êµ¬ì¡°ì²´

```cpp
// NiagaraCompiler.h:19
struct FNiagaraCompilerJob
{
    TRefCountPtr<FShaderCompileJob> ShaderCompileJob;  // GPUìš©
    FNiagaraCompileResults CompileResults;
    double StartTime;
    FNiagaraTranslatorOutput TranslatorOutput;  // VM ë°”ì´íŠ¸ì½”ë“œ í¬í•¨
};
```

---

## ğŸ”¬ ê³ ê¸‰ ì»´íŒŒì¼ ì˜ˆì‹œ (Advanced Compilation Examples)

### Simulation Stage ì»´íŒŒì¼

**Simulation Stage (Grid Write):**
```
FNiagaraHlslTranslationStage:
- ScriptUsage: ParticleSimulationStageScript
- IterationSource: DataInterface (Grid3D)
- IterationDirectBinding: "Grid3D"
- NumIterations: 1
- SimulationStageIndex: 0
```

**ìƒì„±ëœ HLSL:**
```hlsl
[numthreads(64, 1, 1)]
void SimulationStage_0(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    FNiagaraDataInterfaceContext Context;

    // Iteration Index from Grid
    int GridIndex = DispatchThreadId.x;

    // Read from Grid3D
    float Density = DIGrid3D_SampleGrid(GridIndex);

    // Update density
    Density += ComputeDensityContribution();

    // Write back to Grid3D
    DIGrid3D_WriteGrid(GridIndex, Density);
}
```

### Multi-Stage Script ì»´íŒŒì¼

**Emitter with Multiple Stages:**
```
System Spawn/Update
Emitter Spawn/Update
Particle Spawn
Particle Update
Simulation Stage 0 (Grid Write)
Simulation Stage 1 (Grid Read + Particle Update)
```

**ì»´íŒŒì¼ ì¶œë ¥:**
```cpp
// FNiagaraVMExecutableDataëŠ” Single Script
// Multi-StageëŠ” ë³„ë„ Scriptë¡œ ì»´íŒŒì¼ë¨

EmitterInstance:
  - SpawnScript: FNiagaraVMExecutableData (ParticleSpawn)
  - UpdateScript: FNiagaraVMExecutableData (ParticleUpdate)
  - SimulationStages[0]: FNiagaraVMExecutableData (SimStage_GridWrite)
  - SimulationStages[1]: FNiagaraVMExecutableData (SimStage_GridReadUpdate)
```

**ê° Stageë³„ ë…ë¦½ì  ì»´íŒŒì¼:**
```
Stage 0 HLSL:
void SimStage_0() {
    // Grid Write Logic
    DIGrid3D_WriteGrid(Index, Value);
}

Stage 1 HLSL:
void SimStage_1() {
    // Grid Read + Particle Update
    float GridValue = DIGrid3D_SampleGrid(Index);
    Context.Map.Particles_CustomData = GridValue;
}
```

### Rapid Iteration Parameter Baking

```cpp
// Moduleì—ì„œ ì •ì˜í•œ íŒŒë¼ë¯¸í„°
UPROPERTY(EditAnywhere, Category = "Module")
float MySpeed = 10.0f;  // Rapid Iteration ê°€ëŠ¥

// ë‘ ê°€ì§€ ì»´íŒŒì¼ ëª¨ë“œ:

// Mode 1: Rapid Iteration Enabled (ê¸°ë³¸)
// - MySpeedëŠ” ParameterStoreì—ì„œ ë™ì ìœ¼ë¡œ ì½ìŒ
// - ëŸ°íƒ€ì„ì— ê°’ ë³€ê²½ ê°€ëŠ¥
void Simulate() {
    float Speed = Parameters.Module_MySpeed;  // Dynamic Read
    Particles.Velocity += Speed;
}

// Mode 2: Baked (Shipping Build)
// - MySpeedê°€ HLSLì— ì§ì ‘ ë² ì´í‚¹ë¨
// - ë” ë¹ ë¥´ì§€ë§Œ ë³€ê²½ ë¶ˆê°€
void Simulate() {
    Particles.Velocity += 10.0f;  // Baked Constant
}
```

**ì»´íŒŒì¼ DataId ì°¨ì´:**
```cpp
FNiagaraVMExecutableDataId DataId;
DataId.bUsesRapidIterationParams = true;   // Rapid Iteration
// vs
DataId.bUsesRapidIterationParams = false;  // Baked

// ë‹¤ë¥¸ Hash â†’ ë³„ë„ ì»´íŒŒì¼ ê²°ê³¼
```

### Compile Hash ìƒì„± ë° DDC ì¡°íšŒ

**Compile Hash ê³„ì‚°:**
```cpp
// NiagaraScript.cpp
FNiagaraVMExecutableDataId DataId;
DataId.CompilerVersionID = GetNiagaraCompilerVersion();
DataId.ScriptUsageType = ENiagaraScriptUsage::ParticleUpdateScript;
DataId.ScriptUsageTypeID = UsageId;
DataId.BaseScriptCompileHash = ComputeScriptCompileHash();
DataId.ReferencedCompileHashes = GetReferencedScripts();

// Hashì— ì˜í–¥ì„ ì£¼ëŠ” ìš”ì†Œ:
// - Script Graph Topology
// - Module Stack Order
// - DataInterface Types
// - Script Version
// - Compiler Version
```

**DDC ì¡°íšŒ:**
```cpp
// Compileì´ í•„ìš”í•œì§€ í™•ì¸
UNiagaraScript* Script = GetScript();
FNiagaraVMExecutableDataId CurrentDataId = Script->ComputeVMCompilationId();

if (CachedDataId != CurrentDataId)
{
    // DDCì—ì„œ ìºì‹œ ì¡°íšŒ
    TArray<uint8> DDCData;
    if (GetDerivedDataCacheRef().GetSynchronous(*CurrentDataId.ToString(), DDCData))
    {
        // ìºì‹œ íˆíŠ¸: ì—­ì§ë ¬í™”ë§Œ
        FMemoryReader Ar(DDCData);
        ScriptData.SerializeData(Ar, true);
    }
    else
    {
        // ìºì‹œ ë¯¸ìŠ¤: ì¬ì»´íŒŒì¼ í•„ìš”
        CompileScript(Script, CurrentDataId);

        // DDCì— ì €ì¥
        FMemoryWriter Ar(DDCData);
        ScriptData.SerializeData(Ar, true);
        GetDerivedDataCacheRef().Put(*CurrentDataId.ToString(), DDCData);
    }
}
```

---

## ğŸ› ê³ ê¸‰ ë””ë²„ê¹… ê°€ì´ë“œ (Advanced Debugging Guide)

### Compile Hash Mismatch

```cpp
// ë¬¸ì œ: ê°™ì€ ê·¸ë˜í”„ì¸ë° ê³„ì† ì¬ì»´íŒŒì¼
// ì›ì¸: Module Versionì´ ë‹¤ë¦„

// í•´ê²°:
void FixVersionMismatch()
{
    // ëª¨ë“  Moduleì„ ìµœì‹  ë²„ì „ìœ¼ë¡œ ì—…ë°ì´íŠ¸
    for (UNiagaraStackModuleItem* Module : GetAllModules())
    {
        Module->ChangeScriptVersion(Module->GetScript()->GetLatestScriptData()->Version);
    }
}
```

### DDC Corruption

```bash
# ì¦ìƒ: ì»´íŒŒì¼ì€ ì„±ê³µí•˜ì§€ë§Œ ì‹¤í–‰ ì‹œ í¬ë˜ì‹œ
# í•´ê²°: DDC ì‚­ì œ í›„ ì¬ì»´íŒŒì¼
rm -rf DerivedDataCache/NIAGARA
```

### ByteCode Decompression ì‹¤íŒ¨

```cpp
// ì¦ìƒ: ëŸ°íƒ€ì„ì— "Failed to uncompress bytecode" ì—ëŸ¬
// ì›ì¸: ì••ì¶•ëœ ByteCodeê°€ ì†ìƒë¨

// ë””ë²„ê¹…:
void DebugByteCodeIssue()
{
    if (VMExecutableData.ByteCode.IsCompressed())
    {
        bool bSuccess = VMExecutableData.ByteCode.Uncompress();
        if (!bSuccess)
        {
            UE_LOG(LogNiagara, Error, TEXT("ByteCode corruption detected!"));
            // Script ì¬ì»´íŒŒì¼ ê°•ì œ
            Script->InvalidateCompileResults();
        }
    }
}
```

### HLSL ì¶œë ¥ íŒŒì¼ë¡œ ë¤í”„

```cpp
// NiagaraScript.hì— ì €ì¥ë¨
FString GeneratedHLSL = VMExecutableData.LastHlslTranslation;
FString GPUComputeHLSL = VMExecutableData.LastHlslTranslationGPU;

// íŒŒì¼ë¡œ ë¤í”„
FFileHelper::SaveStringToFile(GeneratedHLSL, TEXT("D:/Debug_Script.hlsl"));
```

### ByteCode Assembly í™•ì¸

```cpp
// VM Assembly í™•ì¸
FString Assembly = VMExecutableData.LastAssemblyTranslation;

// ì˜ˆì‹œ ì¶œë ¥:
// 0: inputdata_float R0, Offset=0
// 1: inputdata_float R1, Offset=16
// 2: add R2, R0, R1
// 3: outputdata_float R2, Offset=32
// 4: done
```

### Compile Time Profiling

```cpp
// NiagaraCompiler.cppì—ì„œ
double StartTime = FPlatformTime::Seconds();
CompileScript(Script);
double EndTime = FPlatformTime::Seconds();
UE_LOG(LogNiagara, Log, TEXT("Compilation took %.2f seconds"), EndTime - StartTime);

// ë³‘ëª© ì§€ì :
// - Graph Traversal: ~5-10%
// - HLSL Translation: ~20-30%
// - VM Compilation: ~30-40%
// - GPU Shader Compilation: ~30-50% (ê°€ì¥ ëŠë¦¼)
```

### ì—ë””í„°ì—ì„œ Compile Log í™•ì¸

```
1. Niagara System ë”ë¸”í´ë¦­
2. "Compile" ë²„íŠ¼ ì˜† ë“œë¡­ë‹¤ìš´ â†’ "Show Compile Log"
3. ëª¨ë“  Warning/Error í™•ì¸
```

---

## ğŸ¯ ì»´íŒŒì¼ íŒŒì´í”„ë¼ì¸ ìš”ì•½ (Pipeline Summary)

| ë‹¨ê³„ | ì…ë ¥ | ì¶œë ¥ | ë‹´ë‹¹ í´ë˜ìŠ¤ |
|------|------|------|------------|
| **Graph Traversal** | UNiagaraNodeGraph | Node ìˆœíšŒ ìˆœì„œ | FNiagaraHlslTranslator |
| **HLSL Translation** | Node Graph | HLSL String | FNiagaraHlslTranslator |
| **VM Compilation** | HLSL String | VM ByteCode | FHlslNiagaraCompiler |
| **GPU Compilation** | HLSL String | Compute Shader | FNiagaraShaderMapCompiler |
| **DDC Cache** | CompileHash | Cached Data | FDerivedDataCacheInterface |

### í•µì‹¬ ì„¤ê³„ ì² í•™

> **"Compile Once, Run Everywhere"**
> - CPU/GPU ì–‘ìª½ì—ì„œ ì‹¤í–‰ ê°€ëŠ¥í•œ ë‹¨ì¼ HLSL ì†ŒìŠ¤
> - DDCë¥¼ í†µí•œ ë¹ ë¥¸ ë°˜ë³µ ê°œë°œ
> - Rapid Iteration Parameterë¡œ ì¬ì»´íŒŒì¼ ì—†ëŠ” ì¡°ì •

### ì£¼ìš” ìµœì í™” í¬ì¸íŠ¸

1. **Compile Hash ìµœì†Œí™”** - ë¶ˆí•„ìš”í•œ ì¬ì»´íŒŒì¼ ë°©ì§€
2. **DDC í™œìš©** - ìºì‹œëœ ê²°ê³¼ ì¬ì‚¬ìš©
3. **Module ì¬ì‚¬ìš©** - ê°™ì€ Asset ì°¸ì¡°ë¡œ Hash ê³µìœ 
4. **Rapid Iteration** - íŒŒë¼ë¯¸í„°ë§Œ ë³€ê²½í•˜ì—¬ ì»´íŒŒì¼ ìŠ¤í‚µ

---

## ğŸ”— ê´€ë ¨ ë¬¸ì„œ (Related Documents)

- **[Overview.md](Overview.md)** - Niagara ì‹œìŠ¤í…œ ì „ì²´ ê°œìš”
- **[Core/NiagaraScript.md](Core/NiagaraScript.md)** - ìŠ¤í¬ë¦½íŠ¸ ì—ì…‹ (ì»´íŒŒì¼ ê²°ê³¼ ì €ì¥)
- **[Core/Simulation.md](Core/Simulation.md)** - ëŸ°íƒ€ì„ ì‹¤í–‰ (ì»´íŒŒì¼ëœ ì½”ë“œ ì‹¤í–‰)
- **[Editor.md](Editor.md)** - Niagara ì—ë””í„° (ê·¸ë˜í”„ í¸ì§‘)

---

## ğŸ“š ì°¸ê³  ìë£Œ (References)

### ì†ŒìŠ¤ íŒŒì¼

- `Engine/Plugins/FX/Niagara/Source/NiagaraEditor/Private/NiagaraCompiler.h`
- `Engine/Plugins/FX/Niagara/Source/NiagaraEditor/Private/NiagaraHlslTranslator.h`
- `Engine/Plugins/FX/Niagara/Source/NiagaraEditor/Public/NiagaraGraph.h`
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraScript.h`
- `Engine/Source/Runtime/VectorVM/Public/VectorVM.h`
- `Engine/Plugins/FX/Niagara/Source/NiagaraEditor/Private/NiagaraHlslTranslator.cpp`
- `Engine/Source/Developer/DerivedDataCache/`

### ê³µì‹ ë¬¸ì„œ

- [Niagara Visual Effects](https://docs.unrealengine.com/5.7/en-US/niagara-visual-effects/)
- [Creating Niagara Scripts](https://docs.unrealengine.com/5.7/en-US/creating-niagara-scripts/)

### ì£¼ìš” API

```cpp
// UNiagaraGraph (ê·¸ë˜í”„)
class UNiagaraNodeOutput* FindOutputNode(ENiagaraScriptUsage TargetUsageType, FGuid TargetUsageId) const;
void BuildTraversal(TArray<UNiagaraNode*>& OutNodesTraversed, ENiagaraScriptUsage TargetUsage, FGuid TargetUsageId, bool bEvaluateStaticSwitches) const;
void NotifyGraphNeedsRecompile();

// FNiagaraHlslTranslator (ë³€í™˜ê¸°)
FNiagaraTranslateResults Translate(const FNiagaraCompileRequestData* CompileData, const FNiagaraCompileOptions& Options);
int32 AddBodyChunk(FStringView SymbolName, FStringView Definition, const FNiagaraTypeDefinition& Type);
FString GetFunctionDefinitions();
void DefineMain(FString& HLSLOutput, ...);

// FHlslNiagaraCompiler (ì»´íŒŒì¼ëŸ¬)
int32 CompileScript(const FStringView GroupName, const FNiagaraCompileOptions& InOptions, const FNiagaraTranslateResults& InTranslateResults, const FNiagaraTranslatorOutput& TranslatorOutput, const FString& TranslatedHLSL);
uint32 CompileScriptVM(const FStringView GroupName, const FNiagaraCompileOptions& InOptions, ...);
int32 CreateShaderIntermediateData(const FStringView GroupName, const FNiagaraCompileOptions& InOptions, ...);
TOptional<FNiagaraCompileResults> GetCompileResult(int32 JobID, bool bWait);
```

---

> ğŸ”„ **ì‘ì„±ì¼**: 2025-11-10 | **ìµœì¢… ì—…ë°ì´íŠ¸**: 2026-02-18
> ğŸ“ **ë¬¸ì„œ ë²„ì „**: v1.1 (Script_Compilation.md í†µí•©)
> âœ… **ì†ŒìŠ¤ ê²€ì¦**: UE 5.7.0
> ğŸ“‚ **ë‹¤ìŒ ë¬¸ì„œ**: [Editor.md](Editor.md)

## Merged Notes (from Niagara/Script_Optimization.md)

### Script Optimization and Rapid Iteration (ìŠ¤í¬ë¦½íŠ¸ ìµœì í™” ë° ë¹ ë¥¸ ë°˜ë³µ ê°œë°œ)
#### ğŸ§­ ê°œìš”
Niagara Script Optimization Systemì€ **ì»´íŒŒì¼ ì‹œê°„ ë‹¨ì¶•, ì‹¤í–‰ ì„±ëŠ¥ í–¥ìƒ, ë¹ ë¥¸ ë°˜ë³µ ê°œë°œ**ì„ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

**í•µì‹¬ ì—­í• :**
- Compile Hash ê¸°ë°˜ DDC (Derived Data Cache) í™œìš©
- Rapid Iteration Parameters (ì¬ì»´íŒŒì¼ ì—†ëŠ” íŒŒë¼ë¯¸í„° ì¡°ì •)
- Static Switchë¡œ ì»´íŒŒì¼ íƒ€ì„ ë¶„ê¸° ì œê±°
- Module Merging ë° Dead Code Elimination

**ğŸ“‚ ì£¼ìš” ìœ„ì¹˜:**
- `Engine/Plugins/FX/Niagara/Source/NiagaraCore/Public/NiagaraCompileHash.h`
- `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraScript.h`
- `Engine/Plugins/FX/Niagara/Source/NiagaraEditor/Private/NiagaraHlslTranslator.cpp`

---

#### ğŸ§± ìµœì í™” ê³„ì¸µ êµ¬ì¡°
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Optimization Layers                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                      â”‚
â”‚  Layer 1: Compile-Time Optimization (ì»´íŒŒì¼ ì‹œì )                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚  â”‚ â€¢ DDC Caching (Compile Hash)           â”‚                         â”‚
â”‚  â”‚ â€¢ Static Switch Elimination            â”‚                         â”‚
â”‚  â”‚ â€¢ Dead Code Removal                    â”‚                         â”‚
â”‚  â”‚ â€¢ Constant Folding                     â”‚                         â”‚
â”‚  â”‚ â€¢ Module Inlining                      â”‚                         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚                   â†“                                                  â”‚
â”‚  Layer 2: Translation Optimization (HLSL ìƒì„±)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚  â”‚ â€¢ Code Chunk Deduplication             â”‚                         â”‚
â”‚  â”‚ â€¢ Register Reuse                       â”‚                         â”‚
â”‚  â”‚ â€¢ Merged OpCode Generation             â”‚                         â”‚
â”‚  â”‚ â€¢ SIMD-friendly Code Generation        â”‚                         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚                   â†“                                                  â”‚
â”‚  Layer 3: Runtime Optimization (ì‹¤í–‰ ì‹œì )                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚  â”‚ â€¢ Rapid Iteration Parameters           â”‚                         â”‚
â”‚  â”‚ â€¢ Parameter Store Binding              â”‚                         â”‚
â”‚  â”‚ â€¢ DataInterface Caching                â”‚                         â”‚
â”‚  â”‚ â€¢ Parallel Emitter Execution           â”‚                         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

#### ğŸ”§ ê³„ì¸µë³„ ìƒì„¸ ë¶„ì„
##### 1. **DDC (Derived Data Cache) ë° Compile Hash**
**ğŸ“‚ ìœ„ì¹˜:** `Engine/Plugins/FX/Niagara/Source/NiagaraCore/Public/NiagaraCompileHash.h`

**ì—­í• :** ì»´íŒŒì¼ ê²°ê³¼ë¬¼ì„ ìºì‹±í•˜ì—¬ ë¶ˆí•„ìš”í•œ ì¬ì»´íŒŒì¼ ë°©ì§€.

**FNiagaraCompileHash êµ¬ì¡°:**
```cpp
// NiagaraCompileHash.h:14
struct FNiagaraCompileHash
{
private:
    // 160-bit SHA1 Hash
    uint8 Hash[20];

public:
    // ì´ˆê¸°í™”
    void Initialize();

    // Hash ê³„ì‚°
    void AppendData(const void* Data, int32 DataSize);
    void AppendString(const FString& String);

    // ë¹„êµ
    bool operator==(const FNiagaraCompileHash& Other) const;
    bool IsValid() const;

    // ë³€í™˜
    FString ToString() const;
    uint32 GetTypeHash() const;
};
```

**Compile Hashì— í¬í•¨ë˜ëŠ” ìš”ì†Œ:**
```cpp
// FNiagaraVMExecutableDataId::AppendKeyString()
void ComputeCompileHash(FNiagaraCompileHash& OutHash)
{
    FNiagaraCompileHashVisitor Visitor;

    // 1. Compiler Version
    Visitor.UpdateHash(GetNiagaraCompilerVersion());

    // 2. Script Usage Type
    Visitor.UpdateHash(ScriptUsageType);

    // 3. Script Graph Topology
    for (UEdGraphNode* Node : SourceGraph->Nodes)
    {
        Visitor.UpdateHash(Node->GetClass()->GetName());
        Visitor.UpdateHash(Node->NodeGuid);
    }

    // 4. Module Stack Order
    for (UNiagaraStackModuleItem* Module : ModuleStack)
    {
        Visitor.UpdateHash(Module->GetModuleScript()->GetVersionData().Version);
    }

    // 5. DataInterface Types
    for (UNiagaraDataInterface* DI : DataInterfaces)
    {
        Visitor.UpdateHash(DI->GetClass()->GetName());
    }

    // 6. Static Switch Values
    for (const FNiagaraVariable& StaticSwitch : StaticSwitches)
    {
        Visitor.UpdateHash(StaticSwitch.GetName());
        Visitor.UpdateHash(StaticSwitch.GetValue());
    }

    OutHash = Visitor.GetHash();
}
```

**DDC ì¡°íšŒ ë° ì €ì¥:**
```cpp
bool GetCachedScript(const FNiagaraVMExecutableDataId& DataId, FNiagaraVMExecutableData& OutData)
{
    // 1. DDC Key ìƒì„±
    FString DDCKey = DataId.BaseScriptCompileHash.ToString();

    // 2. DDC ì¡°íšŒ
    TArray<uint8> DDCData;
    if (GetDerivedDataCacheRef().GetSynchronous(*DDCKey, DDCData))
    {
        // Cache Hit: ì—­ì§ë ¬í™”
        FMemoryReader Ar(DDCData);
        OutData.SerializeData(Ar, true);
        return true;
    }

    // Cache Miss: ì»´íŒŒì¼ í•„ìš”
    return false;
}

void SaveCompiledScript(const FNiagaraVMExecutableDataId& DataId, const FNiagaraVMExecutableData& Data)
{
    // 1. ì§ë ¬í™”
    TArray<uint8> DDCData;
    FMemoryWriter Ar(DDCData);
    Data.SerializeData(Ar, true);

    // 2. DDC ì €ì¥
    FString DDCKey = DataId.BaseScriptCompileHash.ToString();
    GetDerivedDataCacheRef().Put(*DDCKey, DDCData);
}
```

---

##### 2. **Rapid Iteration Parameters**
**ğŸ“‚ ìœ„ì¹˜:** `Engine/Plugins/FX/Niagara/Source/Niagara/Classes/NiagaraScript.h:429`

**ì—­í• :** **ì¬ì»´íŒŒì¼ ì—†ì´** Module íŒŒë¼ë¯¸í„°ë¥¼ ëŸ°íƒ€ì„ì— ë³€ê²½ ê°€ëŠ¥.

**Rapid Iteration ë©”ì»¤ë‹ˆì¦˜:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Rapid Iteration Workflow                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  Compile-Time:                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ Module Graph ë¶„ì„                      â”‚                 â”‚
â”‚  â”‚  â†’ "Speed" Parameter ë°œê²¬ (default=10) â”‚                 â”‚
â”‚  â”‚  â†’ Rapid Iterationìœ¼ë¡œ í‘œì‹œ            â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                   â†“                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ HLSL ìƒì„±:                                            â”‚ â”‚
â”‚  â”‚  float Speed = RapidIterationParams[3]; // Dynamic   â”‚ â”‚
â”‚  â”‚  // NOT:                                              â”‚ â”‚
â”‚  â”‚  // float Speed = 10.0f; // Baked Constant           â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                   â†“                                          â”‚
â”‚  Runtime:                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ Userê°€ Editorì—ì„œ Speed = 20 ë³€ê²½      â”‚                 â”‚
â”‚  â”‚  â†’ RapidIterationParameterStore ì—…ë°ì´íŠ¸â”‚                 â”‚
â”‚  â”‚  â†’ ì¦‰ì‹œ ì ìš© (ì¬ì»´íŒŒì¼ ë¶ˆí•„ìš”!)        â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Compiled Data êµ¬ì¡°:**
```cpp
// NiagaraScript.h:429
struct FNiagaraVMExecutableData
{
#if WITH_EDITORONLY_DATA
    // Rapid Iteration Parameter ê¸°ë³¸ê°’
    UPROPERTY()
    TArray<FNiagaraVariable> BakedRapidIterationParameters;
    // Example: [("Module.Speed", 10.0f), ("Module.Mass", 5.0f)]
#endif
};

// DataIdì—ë„ Rapid Iteration Flag í¬í•¨
struct FNiagaraVMExecutableDataId
{
#if WITH_EDITORONLY_DATA
    UPROPERTY()
    uint32 bUsesRapidIterationParams : 1;
#endif
};
```

**Runtime ì ìš©:**
```cpp
void FNiagaraScriptExecutionContext::Init(...)
{
    // Rapid Iteration Parameter Store ì´ˆê¸°í™”
    if (VMExecutableData.BakedRapidIterationParameters.Num() > 0)
    {
        for (const FNiagaraVariable& RIParam : VMExecutableData.BakedRapidIterationParameters)
        {
            // Default ê°’ìœ¼ë¡œ ì´ˆê¸°í™”
            Parameters.AddParameter(RIParam, true);
            Parameters.SetParameterValue(RIParam.GetValue(), RIParam);
        }
    }
}

// Editorì—ì„œ ë³€ê²½ ì‹œ
void OnRapidIterationParameterChanged(const FNiagaraVariable& Param, const FNiagaraVariableBase& NewValue)
{
    // ì¬ì»´íŒŒì¼ ì—†ì´ ì¦‰ì‹œ ì ìš©!
    EmitterInstance->GetRapidIterationParameterStore().SetParameterValue(NewValue, Param);

    // ë‹¤ìŒ Tickì—ì„œ ìë™ìœ¼ë¡œ ë°˜ì˜ë¨
}
```

---

##### 3. **Static Switch (ì»´íŒŒì¼ íƒ€ì„ ë¶„ê¸° ì œê±°)**
**ì—­í• :** ëŸ°íƒ€ì„ ë¶„ê¸°ë¥¼ ì»´íŒŒì¼ íƒ€ì„ì— ì œê±°í•˜ì—¬ ì„±ëŠ¥ í–¥ìƒ.

**Static Switch vs Runtime Branch:**
```hlsl
// Runtime Branch (ë‚˜ìœ ì˜ˆ):
void MyModule(bool UseGravity)
{
    if (UseGravity)  // â† Runtime ë¶„ê¸°, SIMD ë°©í•´
    {
        Particles.Velocity += Gravity * DeltaTime;
    }
}

// Static Switch (ì¢‹ì€ ì˜ˆ):
[Static Switch] bool UseGravity = true;

void MyModule()
{
    #if USE_GRAVITY  // â† Compile-time ë¶„ê¸°
        Particles.Velocity += Gravity * DeltaTime;
    #endif
}
```

**Compile Hash ì˜í–¥:**
```cpp
// Static Switch ê°’ì´ ë³€ê²½ë˜ë©´ ë‹¤ë¥¸ Compile Hash ìƒì„±
FNiagaraCompileHash HashWithGravity = ComputeHash(UseGravity = true);
FNiagaraCompileHash HashWithoutGravity = ComputeHash(UseGravity = false);

// ë‘ HashëŠ” ë‹¤ë¦„ â†’ ë³„ë„ ì»´íŒŒì¼ ê²°ê³¼ë¬¼
check(HashWithGravity != HashWithoutGravity);
```

**Generated Code:**
```hlsl
// UseGravity = true:
void SimulateParticleUpdate()
{
    Particles.Velocity += float3(0, 0, -980) * DeltaTime;
    // ë¶„ê¸° ì—†ìŒ, SIMD ì¹œí™”ì 
}

// UseGravity = false:
void SimulateParticleUpdate()
{
    // Gravity ì½”ë“œ ì™„ì „íˆ ì œê±°ë¨
    // ìµœì ì˜ ì„±ëŠ¥
}
```

---

##### 4. **Dead Code Elimination (ì£½ì€ ì½”ë“œ ì œê±°)**
**ì—­í• :** ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” Module/Parameterë¥¼ ì»´íŒŒì¼ì—ì„œ ì œê±°.

**Dead Code ê°ì§€:**
```cpp
// Graph Traversal ì¤‘
void FNiagaraHlslTranslator::TraverseGraph()
{
    TSet<UEdGraphNode*> VisitedNodes;
    TArray<UEdGraphNode*> NodesToVisit;

    // Output Nodeë¶€í„° ì—­ë°©í–¥ ìˆœíšŒ
    NodesToVisit.Add(OutputNode);

    while (NodesToVisit.Num() > 0)
    {
        UEdGraphNode* Node = NodesToVisit.Pop();
        if (VisitedNodes.Contains(Node))
            continue;

        VisitedNodes.Add(Node);

        // Input Pin ì—°ê²° ì¶”ì 
        for (UEdGraphPin* InputPin : Node->GetInputPins())
        {
            if (InputPin->LinkedTo.Num() > 0)
            {
                UEdGraphNode* LinkedNode = InputPin->LinkedTo[0]->GetOwningNode();
                NodesToVisit.Add(LinkedNode);
            }
        }
    }

    // VisitedNodesì— ì—†ëŠ” NodeëŠ” Dead Code
    for (UEdGraphNode* Node : SourceGraph->Nodes)
    {
        if (!VisitedNodes.Contains(Node))
        {
            UE_LOG(LogNiagara, Log, TEXT("Dead Code Removed: %s"), *Node->GetNodeTitle(ENodeTitleType::ListView).ToString());
        }
    }
}
```

**ì œê±° ì˜ˆì‹œ:**
```
Module Stack:
1. Spawn Burst Instantaneous    â† Used
2. Add Velocity                 â† Used
3. Scale Color (Disabled)       â† NOT USED â†’ ì œê±°
4. Drag Force                   â† Used
```

**ê²°ê³¼:**
```cpp
// Compiled ByteCode:
// Module 1, 2, 4ë§Œ í¬í•¨ë¨
// Module 3ëŠ” ì™„ì „íˆ ì œê±°ë˜ì–´ ByteCodeì— ì—†ìŒ
// â†’ ë” ì‘ì€ Script, ë” ë¹ ë¥¸ ì‹¤í–‰
```

---

##### 5. **Module Inlining ë° Merging**
**ì—­í• :** Function Call Overhead ì œê±° ë° ì½”ë“œ ìµœì í™”.

**Module Inlining:**
```hlsl
// Source (Module Call):
void ParticleUpdate()
{
    AddVelocity(Particles, DeltaTime);  // Function call
}

void AddVelocity(inout Particles p, float dt)
{
    p.Velocity += Gravity * dt;
}

// Inlined (Optimized):
void ParticleUpdate()
{
    // AddVelocity í•¨ìˆ˜ê°€ ì¸ë¼ì¸ë¨
    Particles.Velocity += Gravity * DeltaTime;
    // Function call overhead ì œê±°!
}
```

**Module Merging (Shared Code):**
```hlsl
// Module A:
float3 Force1 = ComputeForce(Particles.Position);
Particles.Velocity += Force1 * DeltaTime;

// Module B:
float3 Force2 = ComputeWind(Particles.Position);
Particles.Velocity += Force2 * DeltaTime;

// Merged (Optimized):
float3 Position = Particles.Position;  // ê³µí†µ ë¡œë“œ 1íšŒ
float3 TotalForce = ComputeForce(Position) + ComputeWind(Position);
Particles.Velocity += TotalForce * DeltaTime;  // ë‹¨ì¼ Write
```

---

##### 6. **Constant Folding (ìƒìˆ˜ í´ë”©)**
**ì—­í• :** ì»´íŒŒì¼ íƒ€ì„ì— ê³„ì‚° ê°€ëŠ¥í•œ í‘œí˜„ì‹ì„ ë¯¸ë¦¬ ê³„ì‚°.

**Constant Folding ì˜ˆì‹œ:**
```hlsl
// Source:
float HalfPI = 3.14159 * 0.5;
float Angle = Particles.Time * HalfPI;

// Folded (Compile-time):
float HalfPI = 1.5708;  // ë¯¸ë¦¬ ê³„ì‚°ë¨
float Angle = Particles.Time * 1.5708;

// ByteCode:
inputdata_float R0, [Particles.Time]
mul R1, R0, ConstantIndex=5  // ConstantTable[5] = 1.5708
```

**Complex Expression Folding:**
```hlsl
// Source:
float Value = (A + B) * (C + D) / (E * F);
// A, B, C, D, E, Fê°€ ëª¨ë‘ constantë©´

// Folded:
float Value = 42.0;  // ì»´íŒŒì¼ íƒ€ì„ì— ê³„ì‚°ë¨
```

---

#### ğŸ’¡ ì‹¤ì „ ì˜ˆì‹œ
##### ì˜ˆì‹œ 1: DDCë¥¼ í†µí•œ ë¹ ë¥¸ ì¬ì»´íŒŒì¼
**Scenario: Module Stack ìˆ˜ì •**
```cpp
// Initial Compilation:
Emitter->AddModule(AddVelocityModule);
Emitter->AddModule(ColorOverLifeModule);
// â†’ Compile Hash: ABC123
// â†’ Compile Time: 5ì´ˆ
// â†’ DDCì— ì €ì¥

// ë‹¤ë¥¸ Emitterì—ì„œ ê°™ì€ Module Stack ì‚¬ìš©:
Emitter2->AddModule(AddVelocityModule);
Emitter2->AddModule(ColorOverLifeModule);
// â†’ Compile Hash: ABC123 (ë™ì¼!)
// â†’ DDC Hit: 0.1ì´ˆ (50ë°° ë¹ ë¦„!)
```

**Compile Hash ë™ì¼ ì¡°ê±´:**
- ê°™ì€ Module Assets ì‚¬ìš©
- ê°™ì€ ìˆœì„œë¡œ ë°°ì¹˜
- ê°™ì€ Static Switch ê°’
- ê°™ì€ Compiler Version

---

##### ì˜ˆì‹œ 2: Rapid Iteration Parameter ì‹¤ì „
**Module Setup:**
```hlsl
// My Custom Module
void MyCustomForce(
    float Strength,  // Rapid Iteration Parameter
    inout float3 Velocity)
{
    Velocity += float3(0, 0, Strength);
}
```

**Editor Workflow:**
```cpp
// 1. Initial Compile:
// - Strength = 10.0 (default)
// - Compile Time: 5ì´ˆ

// 2. Userê°€ Editorì—ì„œ Strength ì¡°ì •:
Strength = 15.0;  // UI Slider
// â†’ ì¦‰ì‹œ ì ìš© (0.001ì´ˆ)
// â†’ ì¬ì»´íŒŒì¼ ë¶ˆí•„ìš”!

Strength = 20.0;  // Again
// â†’ ì¦‰ì‹œ ì ìš© (0.001ì´ˆ)

// 3. Shipping Build:
// - Strengthë¥¼ Constantë¡œ Bake
// - Compiled HLSL: Velocity += float3(0, 0, 20.0);
// - ë” ë¹ ë¥¸ ì‹¤í–‰ (ParameterStore ì¡°íšŒ ë¶ˆí•„ìš”)
```

**Rapid Iteration vs Baked ì„±ëŠ¥ ë¹„êµ:**
```
| Mode             | Compile Time | Parameter Change | Runtime Performance |
|------------------|--------------|------------------|---------------------|
| Rapid Iteration  | 5ì´ˆ          | 0.001ì´ˆ (ì¦‰ì‹œ)   | 100% (baseline)     |
| Baked Constant   | 5ì´ˆ          | 5ì´ˆ (ì¬ì»´íŒŒì¼)   | 105% (5% ë¹ ë¦„)      |
```

---

##### ì˜ˆì‹œ 3: Static Switchë¡œ Variant ìƒì„±
**Scenario: Quality Settings**
```cpp
// Static Switch ì •ì˜
[Static Switch] enum QualityLevel
{
    Low,
    Medium,
    High
};

// Module Logic:
void UpdateParticles(QualityLevel Quality)
{
    #if QUALITY_LEVEL == Low
        // Simplified physics
        SimpleUpdate();
    #elif QUALITY_LEVEL == Medium
        // Moderate physics
        MediumUpdate();
    #elif QUALITY_LEVEL == High
        // Full physics + collision
        HighQualityUpdate();
    #endif
}
```

**Compiled Variants:**
```cpp
// Low Quality:
FNiagaraCompileHash HashLow = ComputeHash(Quality = Low);
// â†’ Simple ByteCode, 1000 OpCodes

// Medium Quality:
FNiagaraCompileHash HashMedium = ComputeHash(Quality = Medium);
// â†’ Moderate ByteCode, 2000 OpCodes

// High Quality:
FNiagaraCompileHash HashHigh = ComputeHash(Quality = High);
// â†’ Complex ByteCode, 5000 OpCodes

// 3ê°œ Variantê°€ ëª¨ë‘ DDCì— ìºì‹±ë¨
// Runtimeì— Quality Settingë§Œ ë³€ê²½í•˜ë©´ ì¦‰ì‹œ ì „í™˜
```

---

##### ì˜ˆì‹œ 4: Dead Code Elimination ì‹¤ì „
**Module Stack:**
```cpp
// Particle Update:
1. Add Velocity (Enabled)
2. Drag Force (Enabled)
3. Curl Noise Force (DISABLED)  // â† Dead Code
4. Scale Color (Enabled)
5. Kill Particles (DISABLED)    // â† Dead Code
```

**Compiled Result:**
```hlsl
// Only Modules 1, 2, 4 compiled:
void ParticleUpdate()
{
    // Module 1: Add Velocity
    Particles.Velocity += Force * DeltaTime;

    // Module 2: Drag Force
    Particles.Velocity *= (1.0 - Drag * DeltaTime);

    // Module 3: REMOVED (Dead Code)

    // Module 4: Scale Color
    Particles.Color *= ColorScale;

    // Module 5: REMOVED (Dead Code)
}

// ByteCode Size: 50% reduction
// Execution Time: 40% faster
```

---

##### ì˜ˆì‹œ 5: Register Reuse ìµœì í™”
**Source (Naive):**
```hlsl
void ParticleUpdate()
{
    float3 Pos = Particles.Position;    // R0, R1, R2
    float3 Vel = Particles.Velocity;    // R3, R4, R5
    float3 Acc = ComputeAcceleration(); // R6, R7, R8
    Vel += Acc * DeltaTime;             // R9, R10, R11
    Pos += Vel * DeltaTime;             // R12, R13, R14
    Particles.Position = Pos;
    Particles.Velocity = Vel;
}
// Total: 15 registers
```

**Optimized (Register Reuse):**
```hlsl
void ParticleUpdate()
{
    float3 Pos = Particles.Position;    // R0, R1, R2
    float3 Acc = ComputeAcceleration(); // R3, R4, R5 (Vel ë¡œë“œ ì „ì— ê³„ì‚°)
    float3 Vel = Particles.Velocity;    // R3, R4, R5 (Acc ì¬ì‚¬ìš©!)
    Vel += Acc * DeltaTime;             // R3, R4, R5 (in-place)
    Pos += Vel * DeltaTime;             // R0, R1, R2 (in-place)
    Particles.Position = Pos;
    Particles.Velocity = Vel;
}
// Total: 6 registers (60% reduction!)
```

---

##### ì˜ˆì‹œ 6: Merged OpCode ìƒì„±
**Source (Multiple Operations):**
```hlsl
float3 A = Particles.Velocity;
float3 B = Gravity;
float C = DeltaTime;
float3 D = B * C;        // mul
float3 E = A + D;        // add
Particles.Velocity = E;
```

**Unoptimized ByteCode:**
```
inputdata_float R0, [Particles.Velocity.X]
inputdata_float R1, [Gravity.X]
inputdata_float R2, [DeltaTime]
mul R3, R1, R2              // D = B * C
add R4, R0, R3              // E = A + D
outputdata_float R4, [Particles.Velocity.X]
// 6 OpCodes
```

**Optimized ByteCode (Merged):**
```
inputdata_float R0, [Particles.Velocity.X]
inputdata_float R1, [Gravity.X]
inputdata_float R2, [DeltaTime]
mad R3, R1, R2, R0          // mad (fused multiply-add)
outputdata_float R3, [Particles.Velocity.X]
// 4 OpCodes (33% reduction!)
```

---

#### âš¡ ìµœì í™” Best Practices
##### âœ… Compile-Time ìµœì í™”
**1. Module ì¬ì‚¬ìš©:**
```cpp
// ì¢‹ì€ ì˜ˆ: ê³µí†µ Module Asset ì¬ì‚¬ìš©
TObjectPtr<UNiagaraScript> AddVelocityModule = LoadModule("AddVelocity");

Emitter1->AddModule(AddVelocityModule);  // Compile Hash: ABC
Emitter2->AddModule(AddVelocityModule);  // Same Hash! DDC Hit
Emitter3->AddModule(AddVelocityModule);  // Same Hash! DDC Hit

// ë‚˜ìœ ì˜ˆ: ë§¤ë²ˆ ìƒˆ Module ìƒì„±
Emitter1->AddModule(CreateNewAddVelocityModule());  // Compile Hash: ABC
Emitter2->AddModule(CreateNewAddVelocityModule());  // Compile Hash: DEF (ë‹¤ë¦„!)
// â†’ ë¶ˆí•„ìš”í•œ ì¬ì»´íŒŒì¼
```

**2. Static Switch ì ê·¹ í™œìš©:**
```hlsl
// ì¢‹ì€ ì˜ˆ: Static Switchë¡œ ë¶„ê¸° ì œê±°
[Static Switch] bool UseComplexPhysics = false;

void Update()
{
    #if USE_COMPLEX_PHYSICS
        ComplexPhysicsUpdate();
    #else
        SimpleUpdate();  // ì»´íŒŒì¼ íƒ€ì„ì— ì„ íƒë¨
    #endif
}

// ë‚˜ìœ ì˜ˆ: Runtime ë¶„ê¸°
void Update(bool UseComplexPhysics)
{
    if (UseComplexPhysics)  // SIMD ë°©í•´
    {
        ComplexPhysicsUpdate();
    }
    else
    {
        SimpleUpdate();
    }
}
```

**3. ë¶ˆí•„ìš”í•œ Module ë¹„í™œì„±í™”:**
```cpp
// í…ŒìŠ¤íŠ¸ìš© Moduleì€ ë¹„í™œì„±í™”
Module->SetEnabled(false);  // Dead Codeë¡œ ì œê±°ë¨

// Shipping Buildì—ì„œëŠ” ì•„ì˜ˆ ì œê±°
#if !UE_BUILD_SHIPPING
    Emitter->AddModule(DebugVisualizationModule);
#endif
```

---

##### âœ… Runtime ìµœì í™”
**1. Rapid Iteration Parameter í™œìš©:**
```cpp
// ì¢‹ì€ ì˜ˆ: ìì£¼ ë³€ê²½ë˜ëŠ” ê°’ì€ Rapid Iteration
UPROPERTY(EditAnywhere, Category = "Rapid Iteration")
float SpawnRate = 100.0f;  // UIì—ì„œ ì‹¤ì‹œê°„ ì¡°ì • ê°€ëŠ¥

// ë‚˜ìœ ì˜ˆ: Static Constantë¡œ Baking
static const float SpawnRate = 100.0f;  // ë³€ê²½í•˜ë ¤ë©´ ì¬ì»´íŒŒì¼
```

**2. Parameter Store Binding ìµœì†Œí™”:**
```cpp
// ì¢‹ì€ ì˜ˆ: í•„ìš”í•œ Parameterë§Œ ë°”ì¸ë”©
FNiagaraBoundParameterArray BoundParams;
BoundParams.Add(FNiagaraBoundParameter("System.DeltaTime", 0, 0));
EmitterStore.Bind(&SystemStore, &BoundParams);

// ë‚˜ìœ ì˜ˆ: ëª¨ë“  Parameter ë°”ì¸ë”©
EmitterStore.Bind(&SystemStore);  // ìˆ˜ë°± ê°œ ë³µì‚¬
```

**3. DataInterface ê³µìœ :**
```cpp
// ì¢‹ì€ ì˜ˆ: System Levelì—ì„œ DI ê³µìœ 
UNiagaraDataInterfaceStaticMesh* SharedMeshDI = NewObject<>(...);
SystemParameterStore.AddDataInterface(SharedMeshDI);
// ëª¨ë“  Emitterê°€ ê³µìœ  â†’ 1ê°œ Instance

// ë‚˜ìœ ì˜ˆ: ê° Emitterë§ˆë‹¤ DI ìƒì„±
Emitter1->AddDataInterface(NewObject<UNiagaraDataInterfaceStaticMesh>());
Emitter2->AddDataInterface(NewObject<UNiagaraDataInterfaceStaticMesh>());
// â†’ Nê°œ Instances, Në°° ë©”ëª¨ë¦¬
```

---

##### âŒ í”¼í•´ì•¼ í•  ì•ˆí‹°íŒ¨í„´
**1. Module ê³¼ë‹¤ ì‚¬ìš©:**
```cpp
// ë‚˜ìœ ì˜ˆ: ë„ˆë¬´ ë§ì€ Module
Emitter->AddModule(Module1);
Emitter->AddModule(Module2);
// ... 50ê°œ Module
Emitter->AddModule(Module50);
// â†’ ì»´íŒŒì¼ ì‹œê°„: 60ì´ˆ
// â†’ ByteCode í¬ê¸°: 1MB

// ì¢‹ì€ ì˜ˆ: Module Merging
Emitter->AddModule(MergedPhysicsModule);  // Module 1-20 í•©ì¹¨
Emitter->AddModule(MergedRenderingModule); // Module 21-50 í•©ì¹¨
// â†’ ì»´íŒŒì¼ ì‹œê°„: 10ì´ˆ
// â†’ ByteCode í¬ê¸°: 200KB
```

**2. ë³µì¡í•œ Function Call Chain:**
```hlsl
// ë‚˜ìœ ì˜ˆ: ê¹Šì€ í˜¸ì¶œ ì²´ì¸
float FinalValue = FuncA(FuncB(FuncC(FuncD(Input))));
// â†’ 4ë²ˆ Function Call
// â†’ ë§ì€ Register Pressure

// ì¢‹ì€ ì˜ˆ: Inline ë˜ëŠ” Flatten
float Temp1 = Input * ScaleD;
float Temp2 = Temp1 + OffsetC;
float Temp3 = Temp2 * ScaleB;
float FinalValue = Temp3 + OffsetA;
// â†’ 0ë²ˆ Function Call
// â†’ Better Performance
```

**3. ë¶ˆí•„ìš”í•œ Precision:**
```hlsl
// ë‚˜ìœ ì˜ˆ: ëª¨ë“  ê²ƒì„ float
float TinyValue = 0.01;
float HugeValue = 10000.0;

// ì¢‹ì€ ì˜ˆ: ì ì ˆí•œ Precision
half TinyValue = 0.01;  // half precision ì¶©ë¶„
float HugeValue = 10000.0;
```

---

#### ğŸ› ë””ë²„ê¹… ë° Profiling
##### Compile Time Profiling
**1. Compile Log ë¶„ì„:**
```cpp
// Editor Console:
// Niagara.LogCompileTimes 1
// â†’ ê° Moduleë³„ ì»´íŒŒì¼ ì‹œê°„ ì¶œë ¥

// Output:
// Module "Add Velocity": 0.5s
// Module "Color Over Life": 0.3s
// Module "Custom Force": 5.0s  â† Bottleneck!
// Total: 10.2s
```

**2. DDC Hit Rate í™•ì¸:**
```cpp
// Stat DDC
// â†’ DDC Cache Hit/Miss ë¹„ìœ¨ í™•ì¸

// Good:
// Cache Hit: 95%, Miss: 5%

// Bad (ë¶ˆí•„ìš”í•œ ì¬ì»´íŒŒì¼):
// Cache Hit: 10%, Miss: 90%
// â†’ Compile Hashê°€ ìì£¼ ë³€ê²½ë˜ëŠ” ë¬¸ì œ
```

---

##### Runtime Performance Profiling
**1. Script Execution Time:**
```cpp
// stat Niagara
// â†’ Scriptë³„ ì‹¤í–‰ ì‹œê°„

// Output:
// ParticleSpawn: 0.5ms
// ParticleUpdate: 2.0ms  â† ë³‘ëª©
// SimStage_0: 0.3ms
```

**2. VM OpCode Profiling:**
```cpp
// stat NiagaraDetailed
// â†’ OpCodeë³„ ì‹¤í–‰ ì‹œê°„

// Output:
// add: 10% (0.2ms)
// mul: 15% (0.3ms)
// external_func_call: 60% (1.2ms)  â† Bottleneck!
// â†’ External Functionì´ ëŠë¦¼
```

**3. Parameter Store Overhead:**
```cpp
// stat NiagaraParameterStore
// â†’ Parameter Store Tick ì‹œê°„

// Output:
// SystemStore.Tick(): 0.1ms
// EmitterStore.Tick(): 0.5ms  â† ë§ì€ Binding
// ScriptStore.Tick(): 0.05ms
```

---

#### ğŸ¯ í•µì‹¬ ì •ë¦¬
##### ìµœì í™” ì „ëµ ìš”ì•½
| ìµœì í™” ë ˆë²¨ | ê¸°ë²• | íš¨ê³¼ |
|-------------|------|------|
| **Compile-Time** | DDC Caching | ì»´íŒŒì¼ ì‹œê°„ 50-100ë°° ë‹¨ì¶• |
| **Compile-Time** | Static Switch | Runtime ë¶„ê¸° ì œê±°, 5-10% ì„±ëŠ¥ í–¥ìƒ |
| **Compile-Time** | Dead Code Elimination | ByteCode í¬ê¸° 30-50% ê°ì†Œ |
| **Compile-Time** | Module Inlining | Function Call Overhead ì œê±° |
| **Translation** | Register Reuse | Register ì‚¬ìš©ëŸ‰ 40-60% ê°ì†Œ |
| **Translation** | Merged OpCode | OpCode ê°œìˆ˜ 20-30% ê°ì†Œ |
| **Runtime** | Rapid Iteration | Parameter ë³€ê²½ ì¦‰ì‹œ ì ìš© |
| **Runtime** | Parameter Binding | ë¶ˆí•„ìš”í•œ ë³µì‚¬ ì œê±° |

##### ì„¤ê³„ ì² í•™
> **"Optimize Compile Time, Not Just Runtime"**
> - DDCë¡œ ë°˜ë³µ ì»´íŒŒì¼ ì œê±°
> - Rapid Iterationìœ¼ë¡œ ê°œë°œ ì†ë„ í–¥ìƒ
> - Static Switchë¡œ Runtime ë¶„ê¸° ì œê±°
> - Dead Code Eliminationìœ¼ë¡œ ì½”ë“œ ì •ë¦¬

##### ê°œë°œ Workflow
```
1. Initial Development:
   - Rapid Iteration Parameters í™œìš©
   - ë¹ ë¥¸ ë°˜ë³µ í…ŒìŠ¤íŠ¸ (ì¬ì»´íŒŒì¼ ë¶ˆí•„ìš”)

2. Optimization Phase:
   - Static Switchë¡œ Variant ìƒì„±
   - Dead Module ì œê±°
   - Module Merging ê³ ë ¤

3. Shipping Build:
   - Rapid Iteration Parameters Baking
   - ìµœì¢… ìµœì í™” Pass
   - DDC Warm-up (ì£¼ìš” System ë¯¸ë¦¬ ì»´íŒŒì¼)
```

---

#### ğŸ”— ì°¸ì¡° ìë£Œ
- **Compile Hash êµ¬í˜„:** `Engine/Plugins/FX/Niagara/Source/NiagaraCore/Private/NiagaraCompileHash.cpp`
- **DDC Integration:** `Engine/Source/Developer/DerivedDataCache/`
- **Rapid Iteration:** `Engine/Plugins/FX/Niagara/Source/Niagara/Private/NiagaraScript.cpp`
- **HLSL Translator ìµœì í™”:** `Engine/Plugins/FX/Niagara/Source/NiagaraEditor/Private/NiagaraHlslTranslator.cpp`
- **Epic ê³µì‹ ë¬¸ì„œ:** [Niagara Performance Guide](https://docs.unrealengine.com/niagara-performance)

