---
title: "ì»¨í…Œì´ë„ˆ ì‹œìŠ¤í…œ (Container System)"
date: "2025-11-21"
status: "stable"
project: "UnrealEngine"
lang: "ko"
category: "unreal-summary"
track: "Core"
tags: ["unreal", "Core"]
---
# ì»¨í…Œì´ë„ˆ ì‹œìŠ¤í…œ (Container System)

## ğŸ§­ ê°œìš”

**ì–¸ë¦¬ì–¼ ì—”ì§„ì˜ ì»¨í…Œì´ë„ˆ ì‹œìŠ¤í…œ**ì€ í‘œì¤€ C++ STL ì»¨í…Œì´ë„ˆë¥¼ ëŒ€ì²´í•˜ëŠ” ê³ ì„±ëŠ¥, í”Œë«í¼ ë…ë¦½ì  ìë£Œêµ¬ì¡° ëª¨ìŒì…ë‹ˆë‹¤. TArray, TMap, TSet ë“± ê²Œì„ ê°œë°œì— ìµœì í™”ëœ ë©”ëª¨ë¦¬ ê´€ë¦¬ì™€ ì„±ëŠ¥ íŠ¹ì„±ì„ ì œê³µí•˜ë©°, ì—”ì§„ì˜ ë¦¬í”Œë ‰ì…˜ ì‹œìŠ¤í…œê³¼ ì™„ë²½í•˜ê²Œ í†µí•©ë©ë‹ˆë‹¤.

**í•µì‹¬ êµ¬ì„± ìš”ì†Œ:**
- **TArray** - ë™ì  ë°°ì—´ (std::vector ëŒ€ì²´)
- **TMap** - í•´ì‹œ ê¸°ë°˜ ë”•ì…”ë„ˆë¦¬ (std::unordered_map ëŒ€ì²´)
- **TSet** - ê³ ìœ  ìš”ì†Œ ì§‘í•© (std::unordered_set ëŒ€ì²´)
- **TSparseArray** - í¬ì†Œ ë°°ì—´ (í™€ì´ ìˆëŠ” ë°°ì—´)
- **TLinkedList / TDoubleLinkedList** - ì—°ê²° ë¦¬ìŠ¤íŠ¸
- **TCircularBuffer / TRingBuffer** - ì›í˜• ë²„í¼
- **TQueue** - í (Lock-free)
- **TStaticArray** - ê³ ì • í¬ê¸° ë°°ì—´

**ì£¼ìš” íŠ¹ì§•:**
- **í”Œë«í¼ ë…ë¦½ì„±** - ëª¨ë“  í”Œë«í¼ì—ì„œ ë™ì¼í•œ ë™ì‘
- **ë©”ëª¨ë¦¬ ìµœì í™”** - ìŠ¬ë™(Slack) ê´€ë¦¬, í™ í• ë‹¹ ìµœì†Œí™”
- **ë¦¬í”Œë ‰ì…˜ í†µí•©** - UPROPERTYì™€ ìë™ ì§ë ¬í™”
- **ë²”ìœ„ ê¸°ë°˜ for** - C++11 ranged-for ì§€ì›
- **í• ë‹¹ ì •ì±…** - ì»¤ìŠ¤í„°ë§ˆì´ì§• ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬ í• ë‹¹ì
- **íƒ€ì… ì•ˆì „ì„±** - ì»´íŒŒì¼ íƒ€ì„ íƒ€ì… ì²´í¬

**ì„±ëŠ¥ íŠ¹ì„±:**
| ì—°ì‚° | TArray | TMap | TSet |
|------|--------|------|------|
| **ì¸ë±ìŠ¤ ì ‘ê·¼** | O(1) | N/A | N/A |
| **ê²€ìƒ‰** | O(n) | O(1) í‰ê·  | O(1) í‰ê·  |
| **ì‚½ì… (ë)** | O(1) ë¶„í• ìƒí™˜ | O(1) í‰ê·  | O(1) í‰ê·  |
| **ì‚½ì… (ì¤‘ê°„)** | O(n) | O(1) í‰ê·  | O(1) í‰ê·  |
| **ì‚­ì œ** | O(n) | O(1) í‰ê·  | O(1) í‰ê·  |
| **ë©”ëª¨ë¦¬** | ì—°ì† | í¬ì†Œ | í¬ì†Œ |

**ëª¨ë“ˆ ìœ„ì¹˜:**
- `Engine/Source/Runtime/Core/Public/Containers/Array.h`
- `Engine/Source/Runtime/Core/Public/Containers/Map.h`
- `Engine/Source/Runtime/Core/Public/Containers/Set.h`
- `Engine/Source/Runtime/Core/Public/Containers/SparseArray.h`
- `Engine/Source/Runtime/Core/Public/Containers/ContainerAllocationPolicies.h`

**ì—”ì§„ ë²„ì „:** Unreal Engine 5.7 (2025ë…„ ê¸°ì¤€)

---

## ğŸ§± êµ¬ì¡°

### ì»¨í…Œì´ë„ˆ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Unreal Container System                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  [ë ˆë²¨ 1: í• ë‹¹ ì •ì±… (Allocation Policies)]                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  FDefaultAllocator                                               â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ ê¸°ë³¸ í™ í• ë‹¹ì                                                 â”‚  â”‚
â”‚  â”‚  â€¢ 64ë¹„íŠ¸: ë¬´ì œí•œ í¬ê¸°, 32ë¹„íŠ¸: ~2GB ì œí•œ                          â”‚  â”‚
â”‚  â”‚  â€¢ FMemory::Malloc / FMemory::Free ì‚¬ìš©                          â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  FHeapAllocator                                                  â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ í™ ì „ìš© í• ë‹¹ì (ì¸ë¼ì¸ ìŠ¤í† ë¦¬ì§€ ì—†ìŒ)                           â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  TInlineAllocator<NumInlineElements>                             â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ ì‘ì€ ë°°ì—´ ì¸ë¼ì¸ ì €ì¥ (SSO - Small Size Optimization)         â”‚  â”‚
â”‚  â”‚  â€¢ NumInlineElementsê¹Œì§€ ìŠ¤íƒì— ì €ì¥                              â”‚  â”‚
â”‚  â”‚  â€¢ ì´ˆê³¼ ì‹œ í™ í• ë‹¹                                                â”‚  â”‚
â”‚  â”‚  â€¢ ì˜ˆì‹œ: TArray<int32, TInlineAllocator<8>> (32 bytes ì¸ë¼ì¸)   â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  TFixedAllocator<NumElements>                                    â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ ê³ ì • í¬ê¸° ë°°ì—´ (ìŠ¤íƒ ì „ìš©)                                     â”‚  â”‚
â”‚  â”‚  â€¢ í™ í• ë‹¹ ì—†ìŒ                                                  â”‚  â”‚
â”‚  â”‚  â€¢ ì»´íŒŒì¼ íƒ€ì„ í¬ê¸°                                               â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  TSparseArrayAllocator                                           â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ TSet/TMap ë‚´ë¶€ ì‚¬ìš©                                           â”‚  â”‚
â”‚  â”‚  â€¢ í™€(holes) ê´€ë¦¬                                                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                             â†‘                                           â”‚
â”‚                             â”‚ í• ë‹¹ ì •ì±… ì‚¬ìš©                              â”‚
â”‚                             â”‚                                           â”‚
â”‚  [ë ˆë²¨ 2: ê¸°ë³¸ ì»¨í…Œì´ë„ˆ]                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  TArray<T, Allocator>                                            â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  ğŸ“‚ ìœ„ì¹˜: Containers/Array.h:1026                                â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ:                                                 â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚  â”‚
â”‚  â”‚  â”‚ AllocatorInstance (FScriptContainerElement*)           â”‚     â”‚  â”‚
â”‚  â”‚  â”‚   â†“                                                    â”‚     â”‚  â”‚
â”‚  â”‚  â”‚ [0][1][2][3][4][5][ ][ ][ ]                            â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  ^            ^  ^                                     â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  ArrayNum=6   â”‚  ArrayMax=9 (í• ë‹¹ëœ ìš©ëŸ‰)              â”‚     â”‚  â”‚
â”‚  â”‚  â”‚               SlackElements=3 (ì—¬ìœ  ê³µê°„)              â”‚     â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  Public Members:                                                 â”‚  â”‚
â”‚  â”‚    - AllocatorInstance : Allocator                              â”‚  â”‚
â”‚  â”‚    - ArrayNum : int32            // í˜„ì¬ ìš”ì†Œ ê°œìˆ˜               â”‚  â”‚
â”‚  â”‚    - ArrayMax : int32            // í• ë‹¹ëœ ìš©ëŸ‰                  â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  Methods:                                                        â”‚  â”‚
â”‚  â”‚    + Add(Item) : int32           // ëì— ì¶”ê°€                    â”‚  â”‚
â”‚  â”‚    + Insert(Index, Item)         // ì¤‘ê°„ ì‚½ì…                    â”‚  â”‚
â”‚  â”‚    + Remove(Item) : int32        // ìš”ì†Œ ì œê±°                    â”‚  â”‚
â”‚  â”‚    + RemoveAt(Index, Count)      // ì¸ë±ìŠ¤ ì œê±°                  â”‚  â”‚
â”‚  â”‚    + Find(Item) : int32          // ê²€ìƒ‰ (ì„ í˜•)                  â”‚  â”‚
â”‚  â”‚    + Contains(Item) : bool       // í¬í•¨ ì—¬ë¶€                    â”‚  â”‚
â”‚  â”‚    + Reserve(Number)             // ìš©ëŸ‰ ì˜ˆì•½                    â”‚  â”‚
â”‚  â”‚    + SetNum(Number)              // í¬ê¸° ì„¤ì •                    â”‚  â”‚
â”‚  â”‚    + Empty(Slack=0)              // ë¹„ìš°ê¸°                       â”‚  â”‚
â”‚  â”‚    + Shrink()                    // ìŠ¬ë™ ì œê±°                    â”‚  â”‚
â”‚  â”‚    + Sort(Predicate)             // ì •ë ¬                         â”‚  â”‚
â”‚  â”‚    + Append(Other)               // ë³‘í•©                         â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  Iterator:                                                       â”‚  â”‚
â”‚  â”‚    + begin() / end()             // ë²”ìœ„ ê¸°ë°˜ for                â”‚  â”‚
â”‚  â”‚    + CreateIterator()            // ëª…ì‹œì  iterator             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  TSparseArray<T, Allocator>                                      â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ í¬ì†Œ ë°°ì—´ (í™€ì´ ìˆëŠ” ë°°ì—´)                                     â”‚  â”‚
â”‚  â”‚  â€¢ TSet/TMapì˜ ê¸°ë°˜                                              â”‚  â”‚
â”‚  â”‚  â€¢ RemoveAt() ì‹œ í™€ ìƒì„±                                          â”‚  â”‚
â”‚  â”‚  â€¢ Add() ì‹œ í™€ ì¬ì‚¬ìš©                                             â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  ë©”ëª¨ë¦¬ ë ˆì´ì•„ì›ƒ:                                                 â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚  â”‚
â”‚  â”‚  â”‚ Data: [0][1][-][3][4][-][6]                            â”‚     â”‚  â”‚
â”‚  â”‚  â”‚                 â†‘        â†‘                             â”‚     â”‚  â”‚
â”‚  â”‚  â”‚                 í™€       í™€                             â”‚     â”‚  â”‚
â”‚  â”‚  â”‚                                                        â”‚     â”‚  â”‚
â”‚  â”‚  â”‚ AllocationFlags: [1][1][0][1][1][0][1]                â”‚     â”‚  â”‚
â”‚  â”‚  â”‚                      â†‘        â†‘                        â”‚     â”‚  â”‚
â”‚  â”‚  â”‚                      0=í™€     0=í™€                      â”‚     â”‚  â”‚
â”‚  â”‚  â”‚                                                        â”‚     â”‚  â”‚
â”‚  â”‚  â”‚ FirstFreeIndex: 2 (ë‹¤ìŒ í™€)                            â”‚     â”‚  â”‚
â”‚  â”‚  â”‚ NumFreeIndices: 2                                      â”‚     â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â”‚  [ë ˆë²¨ 3: í•´ì‹œ ê¸°ë°˜ ì»¨í…Œì´ë„ˆ]                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  TSet<T, KeyFuncs, Allocator>                                    â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  ğŸ“‚ ìœ„ì¹˜: Containers/Set.h:148                                   â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  ë‚´ë¶€ êµ¬ì¡°:                                                       â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚  â”‚
â”‚  â”‚  â”‚  Elements : TSparseArray<TSetElement<T>>               â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  [0] Element: "Apple"                                  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚      HashNextId: 3    (ë‹¤ìŒ ì¶©ëŒ ìš”ì†Œ)                  â”‚     â”‚  â”‚
â”‚  â”‚  â”‚      HashIndex: 1     (í•´ì‹œ ë²„í‚·)                       â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  [1] Element: "Banana"                                 â”‚     â”‚  â”‚
â”‚  â”‚  â”‚      HashNextId: -1   (ì¶©ëŒ ì—†ìŒ)                       â”‚     â”‚  â”‚
â”‚  â”‚  â”‚      HashIndex: 2                                      â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  [2] í™€ (ì œê±°ë¨)                                        â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  [3] Element: "Apple2" (í•´ì‹œ ì¶©ëŒ)                      â”‚     â”‚  â”‚
â”‚  â”‚  â”‚      HashNextId: -1                                    â”‚     â”‚  â”‚
â”‚  â”‚  â”‚      HashIndex: 1                                      â”‚     â”‚  â”‚
â”‚  â”‚  â”‚                                                        â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  Hash : TInlineAllocator<int32> (í•´ì‹œ ë²„í‚·)            â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  [0] -1       (ë¹ˆ ë²„í‚·)                                â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  [1] 0 â†’ 3    (ì¶©ëŒ ì²´ì¸: Apple â†’ Apple2)              â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  [2] 1        (Banana)                                 â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  [3] -1                                                â”‚     â”‚  â”‚
â”‚  â”‚  â”‚                                                        â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  HashSize : int32                                      â”‚     â”‚  â”‚
â”‚  â”‚  â”‚    - í•´ì‹œ í…Œì´ë¸” í¬ê¸° (ë³´í†µ ìš”ì†Œ ê°œìˆ˜ Ã— 2)              â”‚     â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  Methods:                                                        â”‚  â”‚
â”‚  â”‚    + Add(Element) : FSetElementId                               â”‚  â”‚
â”‚  â”‚    + Remove(Element) : int32                                    â”‚  â”‚
â”‚  â”‚    + Find(Element) : FSetElementId*                             â”‚  â”‚
â”‚  â”‚    + Contains(Element) : bool                                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                             â†‘                                           â”‚
â”‚                             â”‚ TSet ê¸°ë°˜                                  â”‚
â”‚                             â”‚                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  TMapBase<KeyType, ValueType, SetAllocator, KeyFuncs>           â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  ğŸ“‚ ìœ„ì¹˜: Containers/Map.h:130                                   â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  ë‚´ë¶€ êµ¬ì¡°:                                                       â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚  â”‚
â”‚  â”‚  â”‚  Pairs : TSet<TPair<KeyType, ValueType>>               â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  TSetì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©! (í‚¤-ê°’ ìŒ ì €ì¥)                    â”‚     â”‚  â”‚
â”‚  â”‚  â”‚                                                        â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  [0] {"Health", 100}                                   â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  [1] {"Mana", 50}                                      â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  [2] {"Stamina", 80}                                   â”‚     â”‚  â”‚
â”‚  â”‚  â”‚                                                        â”‚     â”‚  â”‚
â”‚  â”‚  â”‚  KeyFuncs ì»¤ìŠ¤í„°ë§ˆì´ì§•:                                â”‚     â”‚  â”‚
â”‚  â”‚  â”‚    - GetSetKey(Pair) â†’ Key                            â”‚     â”‚  â”‚
â”‚  â”‚  â”‚    - Matches(KeyA, KeyB) â†’ bool                        â”‚     â”‚  â”‚
â”‚  â”‚  â”‚    - GetKeyHash(Key) â†’ uint32                          â”‚     â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  Methods:                                                        â”‚  â”‚
â”‚  â”‚    + Add(Key, Value) : ValueType&                               â”‚  â”‚
â”‚  â”‚    + Emplace(Key, Value) : ValueType&                           â”‚  â”‚
â”‚  â”‚    + Remove(Key) : bool                                         â”‚  â”‚
â”‚  â”‚    + Find(Key) : ValueType*                                     â”‚  â”‚
â”‚  â”‚    + FindRef(Key) : const ValueType&                            â”‚  â”‚
â”‚  â”‚    + Contains(Key) : bool                                       â”‚  â”‚
â”‚  â”‚    + operator[](Key) : ValueType&                               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### TArray ë©”ëª¨ë¦¬ í• ë‹¹ ì „ëµ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TArray ë©”ëª¨ë¦¬ í• ë‹¹ ì „ëµ                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  [í• ë‹¹ ì„±ì¥ ì •ì±…]                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  CalculateSlackGrow(NumElements, CurrentNumAllocated) â†’ NewNumAllocatedâ”‚
â”‚                                                                         â”‚
â”‚  ì„±ì¥ ê³µì‹:                                                              â”‚
â”‚  - FirstGrowth = 4                                                     â”‚
â”‚  - ConstantGrowth = 16                                                 â”‚
â”‚  - LinearGrowth = CurrentNum + 3*CurrentNum/8 + 16                     â”‚
â”‚                                                                         â”‚
â”‚  í¬ê¸°ì— ë”°ë¥¸ ì „ëµ:                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  í˜„ì¬ í¬ê¸°    â”‚  ì„±ì¥ ì „ëµ          â”‚  ì˜ˆì‹œ                     â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  0            â”‚  FirstGrowth        â”‚  0 â†’ 4                   â”‚   â”‚
â”‚  â”‚  1-3          â”‚  FirstGrowth        â”‚  3 â†’ 4                   â”‚   â”‚
â”‚  â”‚  4-16         â”‚  ConstantGrowth     â”‚  10 â†’ 16                 â”‚   â”‚
â”‚  â”‚  16+          â”‚  LinearGrowth       â”‚  16 â†’ 22                 â”‚   â”‚
â”‚  â”‚                                      â”‚  32 â†’ 44                 â”‚   â”‚
â”‚  â”‚                                      â”‚  64 â†’ 88                 â”‚   â”‚
â”‚  â”‚                                      â”‚  128 â†’ 176               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â”‚  [ìŠ¬ë™ ê´€ë¦¬]                                                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  ìŠ¬ë™(Slack) = ArrayMax - ArrayNum                                     â”‚
â”‚                                                                         â”‚
â”‚  TArray<int32> Array;                                                  â”‚
â”‚  Array.Add(1);                                                         â”‚
â”‚  Array.Add(2);                                                         â”‚
â”‚  Array.Add(3);                                                         â”‚
â”‚  Array.Add(4);                                                         â”‚
â”‚  Array.Add(5);  // í• ë‹¹ ë°œìƒ!                                           â”‚
â”‚                                                                         â”‚
â”‚  ë©”ëª¨ë¦¬ ìƒíƒœ ë³€í™”:                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Add(1):  [1][ ][ ][ ]       ArrayNum=1, ArrayMax=4, Slack=3  â”‚   â”‚
â”‚  â”‚  Add(2):  [1][2][ ][ ]       ArrayNum=2, ArrayMax=4, Slack=2  â”‚   â”‚
â”‚  â”‚  Add(3):  [1][2][3][ ]       ArrayNum=3, ArrayMax=4, Slack=1  â”‚   â”‚
â”‚  â”‚  Add(4):  [1][2][3][4]       ArrayNum=4, ArrayMax=4, Slack=0  â”‚   â”‚
â”‚  â”‚  Add(5):  [1][2][3][4][5][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ][ ]    â”‚   â”‚
â”‚  â”‚           ArrayNum=5, ArrayMax=16, Slack=11                    â”‚   â”‚
â”‚  â”‚           (ConstantGrowth ì ìš©: 4 â†’ 16)                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â”‚  [ìŠ¬ë™ ì œê±°]                                                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Array.Shrink();  // ìŠ¬ë™ ì œê±°                                          â”‚
â”‚  [1][2][3][4][5]  // ArrayNum=5, ArrayMax=5, Slack=0                  â”‚
â”‚                                                                         â”‚
â”‚  [ìš©ëŸ‰ ì˜ˆì•½]                                                             â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Array.Reserve(100);  // 100ê°œ ê³µê°„ ë¯¸ë¦¬ í• ë‹¹                            â”‚
â”‚  // Add() 100ë²ˆê¹Œì§€ ì¬í• ë‹¹ ì—†ìŒ                                          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”¬ ì„¤ê³„ ì² í•™: ì™œ STLì´ ì•„ë‹Œê°€?

### STL vs Unreal Containers

```cpp
// âŒ STL - í”Œë«í¼ ì˜ì¡´ì , ì—”ì§„ í†µí•© ë¶€ì¡±

#include <vector>
#include <unordered_map>
#include <unordered_set>

std::vector<int32> StdVector;
std::unordered_map<FString, int32> StdMap;

// ë¬¸ì œì :
// 1. í”Œë«í¼ë§ˆë‹¤ ë‹¤ë¥¸ êµ¬í˜„ (MSVC, Clang, GCC)
// 2. ì§ë ¬í™” ë¶ˆê°€ëŠ¥ (UPROPERTY ì§€ì› ì—†ìŒ)
// 3. ë©”ëª¨ë¦¬ í• ë‹¹ì ì»¤ìŠ¤í„°ë§ˆì´ì§• ì–´ë ¤ì›€
// 4. ë””ë²„ê¹… ì–´ë ¤ì›€ (ë‚´ë¶€ êµ¬ì¡° í”Œë«í¼ ì˜ì¡´)
// 5. ê²Œì„ ê°œë°œì— ìµœì í™” ì•ˆ ë¨
```

```cpp
// âœ… Unreal Containers - ê²Œì„ ê°œë°œ ìµœì í™”

#include "Containers/Array.h"
#include "Containers/Map.h"

TArray<int32> UnrealArray;
TMap<FString, int32> UnrealMap;

// ì¥ì :
// 1. ëª¨ë“  í”Œë«í¼ì—ì„œ ë™ì¼í•œ ë™ì‘
// 2. UPROPERTY ìë™ ì§ë ¬í™”
//    UPROPERTY()
//    TArray<int32> MyArray;
// 3. ì»¤ìŠ¤í…€ í• ë‹¹ì (TInlineAllocator, TFixedAllocator)
// 4. ìŠ¬ë™ ê´€ë¦¬ë¡œ ì¬í• ë‹¹ ìµœì†Œí™”
// 5. ê²Œì„ í”„ë¡œíŒŒì¼ë§ ë„êµ¬ì™€ í†µí•©
// 6. ë¹ ë¥¸ ë°˜ë³µ (Reserveë¡œ ì¬í• ë‹¹ ì œê±°)
```

### ì»¨í…Œì´ë„ˆ ë¹„êµ í…Œì´ë¸”

| íŠ¹ì§• | **std::vector** | **std::unordered_map** | **TArray** | **TMap** |
|------|-----------------|------------------------|------------|----------|
| **í”Œë«í¼ ë…ë¦½ì„±** | âŒ í”Œë«í¼ ì˜ì¡´ | âŒ í”Œë«í¼ ì˜ì¡´ | âœ… ì™„ì „ ë…ë¦½ | âœ… ì™„ì „ ë…ë¦½ |
| **ì§ë ¬í™”** | âŒ ì—†ìŒ | âŒ ì—†ìŒ | âœ… UPROPERTY | âœ… UPROPERTY |
| **ë©”ëª¨ë¦¬ í• ë‹¹** | std::allocator | std::allocator | FDefaultAllocator | FDefaultSetAllocator |
| **ì¸ë¼ì¸ ìµœì í™”** | âŒ ì—†ìŒ | âŒ ì—†ìŒ | âœ… TInlineAllocator | âœ… TInlineSetAllocator |
| **ìŠ¬ë™ ê´€ë¦¬** | âŒ ì—†ìŒ | âŒ ì—†ìŒ | âœ… Shrink() | âœ… Shrink() |
| **ë²”ìœ„ ê¸°ë°˜ for** | âœ… ì§€ì› | âœ… ì§€ì› | âœ… ì§€ì› | âœ… ì§€ì› |
| **ë°˜ë³µ ì¤‘ ìˆ˜ì •** | âŒ UB | âŒ UB | âš ï¸ TCheckedPointerIterator | âš ï¸ í—ˆìš© (ì•ˆì „) |
| **ë””ë²„ê¹…** | âš ï¸ í”Œë«í¼ ì˜ì¡´ | âš ï¸ í”Œë«í¼ ì˜ì¡´ | âœ… ì¼ê´€ëœ êµ¬ì¡° | âœ… ì¼ê´€ëœ êµ¬ì¡° |

---

## ğŸ§© ì£¼ìš” API

### 1. TArray - ë™ì  ë°°ì—´

```cpp
#include "Containers/Array.h"

// [1-1] ìƒì„± ë° ì´ˆê¸°í™”
TArray<int32> Array1;                          // ë¹ˆ ë°°ì—´
TArray<int32> Array2 = {1, 2, 3, 4, 5};        // ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸
TArray<int32> Array3(Array2);                  // ë³µì‚¬ ìƒì„±ì
TArray<int32> Array4(MoveTemp(Array2));        // ì´ë™ ìƒì„±ì

// ì¸ë¼ì¸ í• ë‹¹ì (8ê°œê¹Œì§€ ìŠ¤íƒì— ì €ì¥)
TArray<int32, TInlineAllocator<8>> InlineArray;

// [1-2] ìš”ì†Œ ì¶”ê°€
int32 Index1 = Array1.Add(10);                 // ëì— ì¶”ê°€ â†’ 0
int32 Index2 = Array1.Add(20);                 // â†’ 1
Array1.Emplace(30);                            // ìƒì„±ì ì§ì ‘ í˜¸ì¶œ
Array1.Insert(15, 1);                          // ì¸ë±ìŠ¤ 1ì— ì‚½ì…
Array1.Append({40, 50, 60});                   // ì—¬ëŸ¬ ìš”ì†Œ ì¶”ê°€

// [1-3] ìš”ì†Œ ì œê±°
Array1.Remove(20);                             // ê°’ìœ¼ë¡œ ì œê±°
Array1.RemoveAt(0);                            // ì¸ë±ìŠ¤ë¡œ ì œê±°
Array1.RemoveAt(0, 2);                         // ì¸ë±ìŠ¤ 0ë¶€í„° 2ê°œ ì œê±°
Array1.RemoveSwap(0);                          // ì œê±° í›„ ë§ˆì§€ë§‰ ìš”ì†Œë¡œ ì±„ì›€ (O(1))
Array1.RemoveAll([](int32 Item) { return Item < 30; }); // ì¡°ê±´ ì œê±°
Array1.Empty();                                // ëª¨ë‘ ì œê±°
Array1.Reset();                                // ëª¨ë‘ ì œê±° (ë©”ëª¨ë¦¬ ìœ ì§€)

// [1-4] ì ‘ê·¼
int32 First = Array1[0];                       // ì¸ë±ìŠ¤ ì ‘ê·¼
int32 Last = Array1.Last();                    // ë§ˆì§€ë§‰ ìš”ì†Œ
int32* Ptr = Array1.GetData();                 // í¬ì¸í„° ì ‘ê·¼
int32 Num = Array1.Num();                      // ê°œìˆ˜
bool bEmpty = Array1.IsEmpty();                // ë¹ˆ ë°°ì—´ ì—¬ë¶€

// [1-5] ê²€ìƒ‰
int32 Index = Array1.Find(30);                 // ì„ í˜• ê²€ìƒ‰ (O(n))
if (Index != INDEX_NONE)
{
    // ì°¾ìŒ
}

bool bContains = Array1.Contains(30);          // í¬í•¨ ì—¬ë¶€
int32* Found = Array1.FindByPredicate([](int32 Item) { return Item > 25; });

// [1-6] ì •ë ¬
Array1.Sort();                                 // ì˜¤ë¦„ì°¨ìˆœ
Array1.Sort([](int32 A, int32 B) { return A > B; }); // ë‚´ë¦¼ì°¨ìˆœ
Array1.StableSort();                           // ì•ˆì • ì •ë ¬

// [1-7] ë©”ëª¨ë¦¬ ê´€ë¦¬
Array1.Reserve(100);                           // 100ê°œ ê³µê°„ ì˜ˆì•½
Array1.SetNum(50);                             // í¬ê¸° ì„¤ì • (í™•ì¥ ë˜ëŠ” ì¶•ì†Œ)
Array1.SetNumZeroed(50);                       // 0ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ë©° ì„¤ì •
Array1.Shrink();                               // ìŠ¬ë™ ì œê±°
int32 Slack = Array1.GetSlack();               // ì—¬ìœ  ê³µê°„

// [1-8] ë°˜ë³µ
for (int32 Item : Array1)                      // ë²”ìœ„ ê¸°ë°˜ for
{
    UE_LOG(LogTemp, Log, TEXT("%d"), Item);
}

for (int32 i = 0; i < Array1.Num(); ++i)       // ì¸ë±ìŠ¤ ê¸°ë°˜
{
    int32 Item = Array1[i];
}

for (auto It = Array1.CreateIterator(); It; ++It) // Iterator
{
    int32& Item = *It;
    It.RemoveCurrent();  // ë°˜ë³µ ì¤‘ ì•ˆì „í•˜ê²Œ ì œê±°
}

// [1-9] ì•Œê³ ë¦¬ì¦˜
int32 Sum = Algo::Accumulate(Array1, 0);      // í•©ê³„
Algo::Reverse(Array1);                         // ì—­ìˆœ
Array1.RemoveDuplicates();                     // ì¤‘ë³µ ì œê±° (ì •ë ¬ í›„)
```

### 2. TMap - í•´ì‹œ ê¸°ë°˜ ë”•ì…”ë„ˆë¦¬

```cpp
#include "Containers/Map.h"

// [2-1] ìƒì„± ë° ì´ˆê¸°í™”
TMap<FString, int32> Map1;
TMap<FString, int32> Map2 = {
    {TEXT("Health"), 100},
    {TEXT("Mana"), 50},
    {TEXT("Stamina"), 80}
};

// [2-2] ìš”ì†Œ ì¶”ê°€
Map1.Add(TEXT("Health"), 100);                 // í‚¤-ê°’ ì¶”ê°€
Map1.Emplace(TEXT("Mana"), 50);                // ìƒì„±ì ì§ì ‘ í˜¸ì¶œ
int32& Value = Map1.FindOrAdd(TEXT("Stamina")); // ì—†ìœ¼ë©´ ì¶”ê°€ í›„ ì°¸ì¡° ë°˜í™˜
Value = 80;

// [2-3] ìš”ì†Œ ì œê±°
Map1.Remove(TEXT("Mana"));                     // í‚¤ë¡œ ì œê±°
int32 NumRemoved = Map1.RemoveAll([](const TPair<FString, int32>& Pair)
{
    return Pair.Value < 50;                    // ì¡°ê±´ ì œê±°
});
Map1.Empty();                                  // ëª¨ë‘ ì œê±°
Map1.Reset();                                  // ëª¨ë‘ ì œê±° (ë©”ëª¨ë¦¬ ìœ ì§€)

// [2-4] ì ‘ê·¼
int32* FoundPtr = Map1.Find(TEXT("Health"));   // ê²€ìƒ‰ (O(1) í‰ê· )
if (FoundPtr)
{
    int32 Health = *FoundPtr;
}

int32 Health = Map1[TEXT("Health")];           // operator[] (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’)
int32 Mana = Map1.FindRef(TEXT("Mana"));       // FindRef (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’)
bool bContains = Map1.Contains(TEXT("Health")); // í¬í•¨ ì—¬ë¶€

// [2-5] ë°˜ë³µ
for (const TPair<FString, int32>& Pair : Map1) // ë²”ìœ„ ê¸°ë°˜ for
{
    UE_LOG(LogTemp, Log, TEXT("%s: %d"), *Pair.Key, Pair.Value);
}

for (auto It = Map1.CreateIterator(); It; ++It) // Iterator
{
    FString Key = It.Key();
    int32& Value = It.Value();
    It.RemoveCurrent();  // ë°˜ë³µ ì¤‘ ì•ˆì „í•˜ê²Œ ì œê±°
}

// [2-6] í‚¤/ê°’ ë°°ì—´ ì¶”ì¶œ
TArray<FString> Keys;
Map1.GetKeys(Keys);                            // ëª¨ë“  í‚¤

TArray<int32> Values;
Map1.GenerateValueArray(Values);               // ëª¨ë“  ê°’

// [2-7] ë©”ëª¨ë¦¬ ê´€ë¦¬
Map1.Reserve(100);                             // 100ê°œ ê³µê°„ ì˜ˆì•½
Map1.Shrink();                                 // ìŠ¬ë™ ì œê±°
int32 Num = Map1.Num();                        // ê°œìˆ˜

// [2-8] ByHash - ê³ ê¸‰ ì‚¬ìš©ë²•
uint32 Hash = GetTypeHash(TEXT("Health"));
int32* FoundByHash = Map1.FindByHash(Hash, TEXT("Health"));

// ì´ì¢… ê²€ìƒ‰ (FString ìƒì„± ì—†ì´ const TCHAR* ì‚¬ìš©)
int32* FoundHeterogeneous = Map1.FindByHash(
    GetTypeHash(TEXT("Health")),
    TEXT("Health")
);
```

### 3. TSet - ê³ ìœ  ìš”ì†Œ ì§‘í•©

```cpp
#include "Containers/Set.h"

// [3-1] ìƒì„± ë° ì´ˆê¸°í™”
TSet<FString> Set1;
TSet<FString> Set2 = {TEXT("Apple"), TEXT("Banana"), TEXT("Cherry")};

// [3-2] ìš”ì†Œ ì¶”ê°€
FSetElementId Id1 = Set1.Add(TEXT("Apple"));   // ì¶”ê°€ (ì¤‘ë³µ ì‹œ ê¸°ì¡´ ID ë°˜í™˜)
FSetElementId Id2 = Set1.Emplace(TEXT("Banana"));

// [3-3] ìš”ì†Œ ì œê±°
Set1.Remove(TEXT("Apple"));                    // ê°’ìœ¼ë¡œ ì œê±°
int32 NumRemoved = Set1.RemoveAll([](const FString& Item)
{
    return Item.StartsWith(TEXT("B"));         // ì¡°ê±´ ì œê±°
});
Set1.Empty();                                  // ëª¨ë‘ ì œê±°

// [3-4] ê²€ìƒ‰
FSetElementId* FoundId = Set1.Find(TEXT("Apple")); // ê²€ìƒ‰ (O(1) í‰ê· )
if (FoundId && FoundId->IsValidId())
{
    // ì°¾ìŒ
}

bool bContains = Set1.Contains(TEXT("Apple")); // í¬í•¨ ì—¬ë¶€

// [3-5] ì§‘í•© ì—°ì‚°
TSet<FString> SetA = {TEXT("A"), TEXT("B"), TEXT("C")};
TSet<FString> SetB = {TEXT("B"), TEXT("C"), TEXT("D")};

TSet<FString> Union = SetA.Union(SetB);        // í•©ì§‘í•©: {A, B, C, D}
TSet<FString> Intersect = SetA.Intersect(SetB); // êµì§‘í•©: {B, C}
TSet<FString> Difference = SetA.Difference(SetB); // ì°¨ì§‘í•©: {A}

// [3-6] ë°˜ë³µ
for (const FString& Item : Set1)               // ë²”ìœ„ ê¸°ë°˜ for
{
    UE_LOG(LogTemp, Log, TEXT("%s"), *Item);
}

for (auto It = Set1.CreateIterator(); It; ++It) // Iterator
{
    const FString& Item = *It;
    It.RemoveCurrent();  // ë°˜ë³µ ì¤‘ ì•ˆì „í•˜ê²Œ ì œê±°
}

// [3-7] ë©”ëª¨ë¦¬ ê´€ë¦¬
Set1.Reserve(100);                             // 100ê°œ ê³µê°„ ì˜ˆì•½
Set1.Shrink();                                 // ìŠ¬ë™ ì œê±°
int32 Num = Set1.Num();                        // ê°œìˆ˜

// [3-8] ë°°ì—´ ë³€í™˜
TArray<FString> Array;
Set1.Array(Array);                             // TSet â†’ TArray
```

### 4. TSparseArray - í¬ì†Œ ë°°ì—´

```cpp
#include "Containers/SparseArray.h"

// [4-1] ìƒì„±
TSparseArray<FMyObject> SparseArray;

// [4-2] ìš”ì†Œ ì¶”ê°€
int32 Index1 = SparseArray.Add(FMyObject());   // ì¶”ê°€ (í™€ì´ ìˆìœ¼ë©´ ì¬ì‚¬ìš©)
int32 Index2 = SparseArray.Add(FMyObject());
int32 Index3 = SparseArray.Add(FMyObject());

// [4-3] ìš”ì†Œ ì œê±° (í™€ ìƒì„±)
SparseArray.RemoveAt(1);                       // Index 1 ì œê±° â†’ í™€ ìƒì„±

// [4-4] ìƒíƒœ í™•ì¸
// SparseArray: [0][-][2]
// IsAllocated: [1][0][1]

bool bAllocated = SparseArray.IsAllocated(1);  // false (í™€)
int32 Num = SparseArray.Num();                 // 2 (í™€ ì œì™¸)
int32 MaxIndex = SparseArray.GetMaxIndex();    // 3 (ì „ì²´ ë²”ìœ„)

// [4-5] ì•ˆì „í•œ ë°˜ë³µ
for (auto It = SparseArray.CreateIterator(); It; ++It)
{
    FMyObject& Obj = *It;
    int32 Index = It.GetIndex();
    // í™€ì€ ìë™ìœ¼ë¡œ ìŠ¤í‚µ
}
```

### 5. TInlineAllocator - ì¸ë¼ì¸ ìµœì í™”

```cpp
// [5-1] ì‘ì€ ë°°ì—´ ìµœì í™”
TArray<int32, TInlineAllocator<8>> SmallArray;

// 8ê°œê¹Œì§€ëŠ” ìŠ¤íƒì— ì €ì¥ (í™ í• ë‹¹ ì—†ìŒ)
SmallArray.Add(1);
SmallArray.Add(2);
SmallArray.Add(3);
// ... 8ê°œê¹Œì§€ í™ í• ë‹¹ ì—†ìŒ

// 9ë²ˆì§¸ë¶€í„° í™ í• ë‹¹
SmallArray.Add(9);  // í™ í• ë‹¹ ë°œìƒ

// [5-2] ê³ ì • í¬ê¸° ë°°ì—´ (ìŠ¤íƒ ì „ìš©)
TArray<int32, TFixedAllocator<16>> FixedArray;

// 16ê°œê¹Œì§€ë§Œ ê°€ëŠ¥ (ì´ˆê³¼ ì‹œ check ì‹¤íŒ¨)
FixedArray.SetNum(16);  // âœ… ê°€ëŠ¥
// FixedArray.SetNum(17);  // âŒ check ì‹¤íŒ¨!

// [5-3] ì„±ëŠ¥ ë¹„êµ
TArray<int32> HeapArray;                       // í•­ìƒ í™ í• ë‹¹
TArray<int32, TInlineAllocator<32>> InlineArray; // 32ê°œê¹Œì§€ ìŠ¤íƒ

// HeapArray: Add(1) â†’ í™ í• ë‹¹
// InlineArray: Add(1) â†’ ìŠ¤íƒ (ë¹ ë¦„!)
```

---

## ğŸ’¡ ìµœì í™” íŒ¨í„´

### 1. Reserveë¡œ ì¬í• ë‹¹ ìµœì†Œí™”

```cpp
// âŒ ë‚˜ì¨: ì¬í• ë‹¹ ì—¬ëŸ¬ ë²ˆ
void BadAppend()
{
    TArray<int32> Array;

    for (int32 i = 0; i < 1000; ++i)
    {
        Array.Add(i);  // ì¬í• ë‹¹ ì—¬ëŸ¬ ë²ˆ ë°œìƒ
    }
    // ì¬í• ë‹¹ íšŸìˆ˜: ~10ë²ˆ (ì„±ì¥ ì •ì±…ì— ë”°ë¦„)
}

// âœ… ì¢‹ìŒ: Reserveë¡œ í•œ ë²ˆë§Œ í• ë‹¹
void GoodAppend()
{
    TArray<int32> Array;
    Array.Reserve(1000);  // 1000ê°œ ê³µê°„ ë¯¸ë¦¬ í• ë‹¹

    for (int32 i = 0; i < 1000; ++i)
    {
        Array.Add(i);  // ì¬í• ë‹¹ ì—†ìŒ
    }
    // ì¬í• ë‹¹ íšŸìˆ˜: 1ë²ˆ
}
```

### 2. TInlineAllocatorë¡œ ì‘ì€ ë°°ì—´ ìµœì í™”

```cpp
// âŒ ë‚˜ì¨: ì‘ì€ ë°°ì—´ë„ í•­ìƒ í™ í• ë‹¹
void ProcessSmallData()
{
    TArray<FVector> Vertices;  // í™ í• ë‹¹

    Vertices.Add(FVector::ZeroVector);
    Vertices.Add(FVector::UpVector);
    Vertices.Add(FVector::ForwardVector);

    // 3ê°œ ì •ë„ì¸ë° í™ í• ë‹¹ ë¹„ìš© ë°œìƒ
}

// âœ… ì¢‹ìŒ: ì¸ë¼ì¸ í• ë‹¹ì ì‚¬ìš©
void ProcessSmallDataOptimized()
{
    TArray<FVector, TInlineAllocator<16>> Vertices;  // ìŠ¤íƒ í• ë‹¹

    Vertices.Add(FVector::ZeroVector);
    Vertices.Add(FVector::UpVector);
    Vertices.Add(FVector::ForwardVector);

    // 16ê°œê¹Œì§€ëŠ” í™ í• ë‹¹ ì—†ìŒ (ë¹ ë¦„!)
}
```

### 3. RemoveSwapìœ¼ë¡œ ë¹ ë¥¸ ì œê±°

```cpp
// âŒ ë‚˜ì¨: ì¼ë°˜ ì œê±° (O(n))
void SlowRemove(TArray<int32>& Array, int32 Index)
{
    Array.RemoveAt(Index);  // ì´í›„ ìš”ì†Œë“¤ ëª¨ë‘ ì´ë™
}

// âœ… ì¢‹ìŒ: RemoveSwap (O(1))
void FastRemove(TArray<int32>& Array, int32 Index)
{
    Array.RemoveAtSwap(Index);  // ë§ˆì§€ë§‰ ìš”ì†Œë¡œ ì±„ì›€ (ìˆœì„œ ë°”ë€œ)
}

// ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤:
// - ìˆœì„œê°€ ì¤‘ìš”í•˜ì§€ ì•Šì€ ê²½ìš°
// - ëŒ€ëŸ‰ ì œê±° ì‹œ ì„±ëŠ¥ ì¤‘ìš”
```

### 4. TMap FindOrAddë¡œ ì¤‘ë³µ ê²€ìƒ‰ ì œê±°

```cpp
// âŒ ë‚˜ì¨: Contains + Add (ì¤‘ë³µ ê²€ìƒ‰)
void BadIncrement(TMap<FString, int32>& Map, const FString& Key)
{
    if (Map.Contains(Key))
    {
        (*Map.Find(Key))++;  // ë‘ ë²ˆì§¸ ê²€ìƒ‰
    }
    else
    {
        Map.Add(Key, 1);
    }
}

// âœ… ì¢‹ìŒ: FindOrAdd (í•œ ë²ˆë§Œ ê²€ìƒ‰)
void GoodIncrement(TMap<FString, int32>& Map, const FString& Key)
{
    int32& Value = Map.FindOrAdd(Key, 0);
    Value++;
}
```

---

## ğŸš¨ ì¼ë°˜ì ì¸ í•¨ì •

### âŒ ë°˜ë³µ ì¤‘ ìˆ˜ì •

```cpp
// âŒ ìœ„í—˜: ë²”ìœ„ ê¸°ë°˜ for ì¤‘ ìˆ˜ì •
void DangerousIteration(TArray<int32>& Array)
{
    for (int32 Item : Array)
    {
        if (Item < 0)
        {
            Array.Remove(Item);  // âŒ í¬ë˜ì‹œ! (iterator ë¬´íš¨í™”)
        }
    }
}

// âœ… ì•ˆì „: Iterator ì‚¬ìš©
void SafeIteration(TArray<int32>& Array)
{
    for (auto It = Array.CreateIterator(); It; ++It)
    {
        if (*It < 0)
        {
            It.RemoveCurrent();  // âœ… ì•ˆì „
        }
    }
}

// âœ… ë˜ëŠ”: ì—­ìˆœ ë°˜ë³µ
void SafeReverseIteration(TArray<int32>& Array)
{
    for (int32 i = Array.Num() - 1; i >= 0; --i)
    {
        if (Array[i] < 0)
        {
            Array.RemoveAt(i);  // âœ… ì•ˆì „ (ì—­ìˆœì´ë¼ iterator ìœ íš¨)
        }
    }
}
```

### âŒ TMap ê¸°ë³¸ê°’ í•¨ì •

```cpp
// âŒ ìœ„í—˜: operator[] ì‚¬ìš© (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì¶”ê°€)
void DangerousMapAccess(TMap<FString, int32>& Map)
{
    int32 Value = Map[TEXT("Health")];  // Healthê°€ ì—†ìœ¼ë©´ {Health, 0} ì¶”ê°€!

    // Mapì´ ì˜ë„ì¹˜ ì•Šê²Œ ë³€ê²½ë¨
}

// âœ… ì•ˆì „: Find ì‚¬ìš©
void SafeMapAccess(TMap<FString, int32>& Map)
{
    int32* ValuePtr = Map.Find(TEXT("Health"));
    if (ValuePtr)
    {
        int32 Value = *ValuePtr;
    }
    else
    {
        // ì—†ìŒ
    }
}

// âœ… ë˜ëŠ”: FindRef (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ë°˜í™˜, Mapì€ ë³€ê²½ ì•ˆ ë¨)
void SafeMapAccess2(TMap<FString, int32>& Map)
{
    int32 Value = Map.FindRef(TEXT("Health"));  // ì—†ìœ¼ë©´ 0 ë°˜í™˜
}
```

### âŒ í¬ì¸í„° ë¬´íš¨í™”

```cpp
// âŒ ìœ„í—˜: í¬ì¸í„° ì €ì¥ í›„ ì¬í• ë‹¹
void DangerousPointer()
{
    TArray<int32> Array = {1, 2, 3};
    int32* Ptr = &Array[0];  // í¬ì¸í„° ì €ì¥

    Array.Add(4);  // ì¬í• ë‹¹ ë°œìƒ! Ptr ë¬´íš¨í™”ë¨

    int32 Value = *Ptr;  // âŒ ëŒ•ê¸€ë§ í¬ì¸í„°!
}

// âœ… ì•ˆì „: ì¸ë±ìŠ¤ ì‚¬ìš©
void SafeIndex()
{
    TArray<int32> Array = {1, 2, 3};
    int32 Index = 0;  // ì¸ë±ìŠ¤ ì €ì¥

    Array.Add(4);  // ì¬í• ë‹¹ ë°œìƒí•´ë„ ì¸ë±ìŠ¤ëŠ” ìœ íš¨

    int32 Value = Array[Index];  // âœ… ì•ˆì „
}
```

### âŒ ì¤‘ì²© ì»¨í…Œì´ë„ˆ (UPROPERTY ë¶ˆê°€)

```cpp
// âŒ ì»´íŒŒì¼ ì—ëŸ¬: ì¤‘ì²© ì»¨í…Œì´ë„ˆ ì‚¬ìš© ë¶ˆê°€
UCLASS()
class UMyClass : public UObject
{
    GENERATED_BODY()

    UPROPERTY()
    TArray<TArray<int32>> Grid2D;  // Error: Nested containers not supported

    UPROPERTY()
    TMap<FString, TArray<int32>> PlayerScores;  // Error!
};

// ì—ëŸ¬ ì´ìœ :
// - C++ ì»´íŒŒì¼ëŸ¬ëŠ” íƒ€ì…/í¬ê¸°ë¥¼ ì™„ë²½íˆ ì•Œì§€ë§Œ
// - ì–¸ë¦¬ì–¼ ë¦¬í”Œë ‰ì…˜ ì‹œìŠ¤í…œ(UPROPERTY)ì´ ì¤‘ì²© ë©”íƒ€ë°ì´í„° ìƒì„± ë¶ˆê°€
// - FArrayProperty::Innerê°€ ë‹¨ì¼ í¬ì¸í„°ë¼ Innerì˜ Innerë¥¼ í‘œí˜„ ëª»í•¨

// âœ… í•´ê²° ë°©ë²• 1: êµ¬ì¡°ì²´ ë˜í•‘ (ê¶Œì¥)
USTRUCT()
struct FIntArray
{
    GENERATED_BODY()

    UPROPERTY()
    TArray<int32> Values;
};

UCLASS()
class UMyClass : public UObject
{
    GENERATED_BODY()

    UPROPERTY()
    TArray<FIntArray> Grid2D;  // âœ… ì‘ë™!

    // ë¦¬í”Œë ‰ì…˜ êµ¬ì¡°:
    // FArrayProperty (Grid2D)
    //   â†“
    // FStructProperty (FIntArray) â† ì¤‘ê°„ ë ˆì´ì–´
    //   â†“
    // FArrayProperty (Values)
    //   â†“
    // FIntProperty (int32)
};

// âœ… í•´ê²° ë°©ë²• 2: 1D ë°°ì—´ë¡œ í‰íƒ„í™”
UCLASS()
class UMyClass2 : public UObject
{
    GENERATED_BODY()

    UPROPERTY()
    TArray<int32> GridData;  // 1D ë°°ì—´

    UPROPERTY()
    int32 Width;

    UPROPERTY()
    int32 Height;

    // 2D ì ‘ê·¼ í—¬í¼
    int32& Get(int32 X, int32 Y)
    {
        return GridData[Y * Width + X];
    }
};

// âœ… í•´ê²° ë°©ë²• 3: UPROPERTY ì œê±° (ìˆ˜ë™ ì§ë ¬í™”)
UCLASS()
class UMyClass3 : public UObject
{
    GENERATED_BODY()

    // UPROPERTY ì—†ìŒ - ì§ë ¬í™”/ì—ë””í„° ë…¸ì¶œ ì•ˆ ë¨
    TArray<TArray<int32>> Grid2D;

    virtual void Serialize(FArchive& Ar) override
    {
        Super::Serialize(Ar);

        // ìˆ˜ë™ ì§ë ¬í™”
        int32 OuterNum = Grid2D.Num();
        Ar << OuterNum;

        if (Ar.IsLoading())
            Grid2D.SetNum(OuterNum);

        for (int32 i = 0; i < OuterNum; ++i)
        {
            Ar << Grid2D[i];  // TArrayëŠ” operator<< ì§€ì›
        }
    }
};
```

---

## ğŸ” ë””ë²„ê¹… íŒ

### ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í™•ì¸

```cpp
// TArray ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
TArray<int32> Array;
Array.Reserve(100);

SIZE_T AllocatedSize = Array.GetAllocatedSize();  // í• ë‹¹ëœ ë©”ëª¨ë¦¬ (bytes)
UE_LOG(LogTemp, Log, TEXT("Allocated: %llu bytes"), AllocatedSize);

// TMap ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
TMap<FString, int32> Map;
Map.Reserve(100);

SIZE_T MapSize = Map.GetAllocatedSize();
UE_LOG(LogTemp, Log, TEXT("Map Allocated: %llu bytes"), MapSize);
```

### ì½˜ì†” ëª…ë ¹ì–´

```bash
# ë©”ëª¨ë¦¬ í†µê³„
stat memory

# ì»¨í…Œì´ë„ˆ ëˆ„ìˆ˜ ì¶”ì 
-LogContainerAllocations

# í”„ë¡œíŒŒì¼ë§
stat startfile
stat stopfile
# UnrealInsightsë¡œ ì—´ê¸°
```

---

## ğŸ”— ì°¸ê³ ìë£Œ

- [TArray API](https://docs.unrealengine.com/en-US/API/Runtime/Core/Containers/TArray/index.html)
- [TMap API](https://docs.unrealengine.com/en-US/API/Runtime/Core/Containers/TMap/index.html)
- [TSet API](https://docs.unrealengine.com/en-US/API/Runtime/Core/Containers/TSet/index.html)
- [Container Overview](https://docs.unrealengine.com/containers-in-unreal-engine/)
- [Array.h Source](Engine/Source/Runtime/Core/Public/Containers/Array.h)
- [Map.h Source](Engine/Source/Runtime/Core/Public/Containers/Map.h)
- [Set.h Source](Engine/Source/Runtime/Core/Public/Containers/Set.h)

**ì—°ê´€ ë¬¸ì„œ:**
- [Core/Memory.md](./Memory.md) - ë©”ëª¨ë¦¬ í• ë‹¹ì ë° í• ë‹¹ ì •ì±…
- [Core/Delegates.md](./Delegates.md) - TMulticastDelegate (ë‚´ë¶€ì ìœ¼ë¡œ TArray ì‚¬ìš©)
- [CoreUObject/Serialization.md](../CoreUObject/Serialization.md) - ì»¨í…Œì´ë„ˆ ì§ë ¬í™”

---

> ğŸ“… ìƒì„±: 2025-10-21 â€” ì»¨í…Œì´ë„ˆ ì‹œìŠ¤í…œ ë¬¸ì„œí™” (UE 5.7 ê²€ì¦ ì™„ë£Œ)
