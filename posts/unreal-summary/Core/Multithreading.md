---
title: "ë©€í‹°ìŠ¤ë ˆë”© ì‹œìŠ¤í…œ (Multithreading System)"
date: "2025-11-21"
status: "stable"
project: "UnrealEngine"
lang: "ko"
category: "unreal-summary"
track: "Core"
tags: ["unreal", "Core"]
---
# ë©€í‹°ìŠ¤ë ˆë”© ì‹œìŠ¤í…œ (Multithreading System)

## ğŸ§­ ê°œìš”

**ì–¸ë¦¬ì–¼ ì—”ì§„ì˜ ë©€í‹°ìŠ¤ë ˆë”© ì‹œìŠ¤í…œ**ì€ ê²Œì„ ë¡œì§, ë Œë”ë§, ë¬¼ë¦¬, ì˜¤ë””ì˜¤ ë“± ëª¨ë“  ì„œë¸Œì‹œìŠ¤í…œì„ ë³‘ë ¬ë¡œ ì‹¤í–‰í•˜ì—¬ ë©€í‹°ì½”ì–´ CPU ì„±ëŠ¥ì„ ìµœëŒ€í•œ í™œìš©í•©ë‹ˆë‹¤. Task Graph, FRunnable, ParallelFor ë“± ë‹¤ì–‘í•œ ì¶”ìƒí™” ë ˆë²¨ì˜ APIë¥¼ ì œê³µí•˜ì—¬ ê°œë°œìê°€ ì•ˆì „í•˜ê³  íš¨ìœ¨ì ì¸ ë©€í‹°ìŠ¤ë ˆë“œ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë„ë¡ ë•ìŠµë‹ˆë‹¤.

**í•µì‹¬ êµ¬ì„± ìš”ì†Œ:**
- **FRunnable / FRunnableThread** - ì €ìˆ˜ì¤€ ìŠ¤ë ˆë“œ ìƒì„±
- **Task Graph** - ì‘ì—… ê¸°ë°˜ ë³‘ë ¬ ì²˜ë¦¬ (ì˜ì¡´ì„± ê´€ë¦¬, DAG ìŠ¤ì¼€ì¤„ë§)
- **AsyncTask / Async** - ê³ ìˆ˜ì¤€ ë¹„ë™ê¸° ì‘ì—…
- **ParallelFor** - ë³‘ë ¬ ë£¨í”„ (ë°ì´í„° ë³‘ë ¬ì„±, Fork-Join ëª¨ë¸)
- **FCriticalSection** - ë®¤í…ìŠ¤ (ìƒí˜¸ ë°°ì œ)
- **FRWLock** - ì½ê¸°/ì“°ê¸° ì ê¸ˆ
- **TAtomic** - ì›ìì  ì—°ì‚° (Lock-free)
- **FThreadSafeCounter** - ìŠ¤ë ˆë“œ ì•ˆì „ ì¹´ìš´í„°
- **FPlatformAtomics** - ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´ (Memory Barrier)
- **Thread-safe ì»¨í…Œì´ë„ˆ** - TQueue, TCircularQueue (Lock-free)

**ì£¼ìš” ìŠ¤ë ˆë“œ:**
- **Game Thread** - ê²Œì„ ë¡œì§ (AActor::Tick, UActorComponent::TickComponent)
- **Render Thread** - ë Œë”ë§ ì»¤ë§¨ë“œ ìƒì„± (DrawCalls ì¤€ë¹„)
- **RHI Thread** - GPU ì»¤ë§¨ë“œ ì „ì†¡ (D3D, Vulkan)
- **Audio Thread** - ì˜¤ë””ì˜¤ ë¯¹ì‹±
- **Worker Threads** - Task Graph ì›Œì»¤ (ì¼ë°˜ ì‘ì—…)
- **IO Thread Pool** - ë¹„ë™ê¸° íŒŒì¼ I/O (AsyncLoadingThread)
- **Stats Thread** - í”„ë¡œíŒŒì¼ë§ í†µê³„ ìˆ˜ì§‘ (ì˜µì…˜)

**ì„±ëŠ¥ íŠ¹ì„±:**
- **FRunnable:** ì „ìš© ìŠ¤ë ˆë“œ ìƒì„± (ì˜¤ë²„í—¤ë“œ ë†’ìŒ, ì¥ê¸° ì‹¤í–‰ ì‘ì—…)
- **Task Graph:** ì›Œì»¤ í’€ ì¬ì‚¬ìš© (ì˜¤ë²„í—¤ë“œ ë‚®ìŒ, ë‹¨ê¸° ì‘ì—…)
- **ParallelFor:** ìë™ ì‘ì—… ë¶„í•  (ë°ì´í„° ë³‘ë ¬ì„± ìµœì í™”)

**ëª¨ë“ˆ ìœ„ì¹˜:**
- `Engine/Source/Runtime/Core/Public/HAL/Runnable.h`
- `Engine/Source/Runtime/Core/Public/HAL/RunnableThread.h`
- `Engine/Source/Runtime/Core/Public/Async/TaskGraphInterfaces.h`
- `Engine/Source/Runtime/Core/Public/Async/Async.h`
- `Engine/Source/Runtime/Core/Public/Async/ParallelFor.h`
- `Engine/Source/Runtime/Core/Public/HAL/CriticalSection.h`

**ì—”ì§„ ë²„ì „:** Unreal Engine 5.7 (2025ë…„ ê¸°ì¤€)

---

## ğŸ§± êµ¬ì¡°

### ë©€í‹°ìŠ¤ë ˆë”© ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Unreal Multithreading Architecture                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  [ë ˆë²¨ 1: ì €ìˆ˜ì¤€ - Platform Layer]                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  FPlatformProcess                                                â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ CreateThread() - OS ìŠ¤ë ˆë“œ ìƒì„±                                â”‚  â”‚
â”‚  â”‚  â€¢ Sleep(), SleepNoStats()                                       â”‚  â”‚
â”‚  â”‚  â€¢ SupportsMultithreading() : bool                               â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  FPlatformMutex, FPlatformRecursiveMutex                         â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ Lock(), Unlock()                                              â”‚  â”‚
â”‚  â”‚  â€¢ TryLock() : bool                                              â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  FPlatformEvent (Win32: Event, Unix: pthread_cond)               â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ Wait(), Trigger()                                             â”‚  â”‚
â”‚  â”‚  â€¢ ìŠ¤ë ˆë“œ ë™ê¸°í™”                                                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                             â†‘                                           â”‚
â”‚                             â”‚ í”Œë«í¼ ì¶”ìƒí™”                               â”‚
â”‚                             â”‚                                           â”‚
â”‚  [ë ˆë²¨ 2: ì¤‘ìˆ˜ì¤€ - HAL (Hardware Abstraction Layer)]                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  FRunnable / FRunnableThread                                     â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ Init() â†’ Run() â†’ Exit() ìƒëª…ì£¼ê¸°                              â”‚  â”‚
â”‚  â”‚  â€¢ ì „ìš© ìŠ¤ë ˆë“œ ìƒì„±                                               â”‚  â”‚
â”‚  â”‚  â€¢ ì¥ê¸° ì‹¤í–‰ ì‘ì—… (ë°±ê·¸ë¼ìš´ë“œ ì„œë¹„ìŠ¤)                             â”‚  â”‚
â”‚  â”‚  â€¢ ì˜ˆì‹œ: íŒŒì¼ ë¡œë”© ìŠ¤ë ˆë“œ, ë„¤íŠ¸ì›Œí¬ ìŠ¤ë ˆë“œ                         â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  FCriticalSection (ë®¤í…ìŠ¤)                                        â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ FScopeLock Guard(CriticalSection);                            â”‚  â”‚
â”‚  â”‚  â€¢ ì¬ì§„ì… ê°€ëŠ¥ (Recursive)                                        â”‚  â”‚
â”‚  â”‚  â€¢ ì„±ëŠ¥: ~25ns (ë¹„ê²½ìŸ ì‹œ), ~50-100ns (ê²½ìŸ ì‹œ)                   â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  FRWLock (ì½ê¸°/ì“°ê¸° ì ê¸ˆ)                                         â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ FReadScopeLock Guard(RWLock);  // ë‹¤ì¤‘ ì½ê¸°                   â”‚  â”‚
â”‚  â”‚  â€¢ FWriteScopeLock Guard(RWLock); // ë°°íƒ€ì  ì“°ê¸°                 â”‚  â”‚
â”‚  â”‚  â€¢ ì½ê¸° ë¹ˆë²ˆ ì‹œ ìœ ë¦¬                                              â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  FEvent (ë™ê¸°í™” ì´ë²¤íŠ¸)                                           â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ Wait(), Trigger()                                             â”‚  â”‚
â”‚  â”‚  â€¢ ìŠ¤ë ˆë“œ ê°„ ì‹ í˜¸ ì „ë‹¬                                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                             â†‘                                           â”‚
â”‚                             â”‚ ì‘ì—… ê¸°ë°˜ ì¶”ìƒí™”                            â”‚
â”‚                             â”‚                                           â”‚
â”‚  [ë ˆë²¨ 3: ê³ ìˆ˜ì¤€ - Task Graph System]                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  FTaskGraphInterface                                             â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ QueueTask() - ì‘ì—… íì‰                                        â”‚  â”‚
â”‚  â”‚  â€¢ Worker Pool ê´€ë¦¬ (Nê°œ ì›Œì»¤ ìŠ¤ë ˆë“œ)                             â”‚  â”‚
â”‚  â”‚  â€¢ ì˜ì¡´ì„± ê·¸ë˜í”„ (Task A â†’ Task B â†’ Task C)                      â”‚  â”‚
â”‚  â”‚  â€¢ Named Threads: GameThread, RenderThread, RHIThread           â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  FGraphEventRef (Task Handle)                                    â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ Wait() - ì‘ì—… ì™„ë£Œ ëŒ€ê¸°                                        â”‚  â”‚
â”‚  â”‚  â€¢ IsComplete() : bool                                           â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  AsyncTask() / Async()                                           â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ EAsyncExecution::TaskGraph (ë‹¨ê¸° ì‘ì—…)                         â”‚  â”‚
â”‚  â”‚  â€¢ EAsyncExecution::Thread (ì¥ê¸° ì‘ì—… - ë³„ë„ ìŠ¤ë ˆë“œ)              â”‚  â”‚
â”‚  â”‚  â€¢ EAsyncExecution::ThreadPool (ì›Œì»¤ í’€ ì‚¬ìš©)                     â”‚  â”‚
â”‚  â”‚  â€¢ TFuture / TPromise íŒ¨í„´                                       â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  ParallelFor()                                                   â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ ë³‘ë ¬ ë£¨í”„ (ë°ì´í„° ë³‘ë ¬ì„±)                                      â”‚  â”‚
â”‚  â”‚  â€¢ ìë™ ì‘ì—… ë¶„í•  (Work Stealing)                                 â”‚  â”‚
â”‚  â”‚  â€¢ ë°°ì¹˜ í¬ê¸° ìµœì í™”                                               â”‚  â”‚
â”‚  â”‚  â€¢ ì˜ˆì‹œ: ìˆ˜ì²œ ê°œ ì˜¤ë¸Œì íŠ¸ ë³‘ë ¬ ì²˜ë¦¬                                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â”‚  [ë ˆë²¨ 4: ì—”ì§„ ì „ìš© ìŠ¤ë ˆë“œ]                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Game Thread (FEngineLoop::Tick)                                 â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ UWorld::Tick()                                                â”‚  â”‚
â”‚  â”‚  â€¢ AActor::Tick()                                                â”‚  â”‚
â”‚  â”‚  â€¢ UActorComponent::TickComponent()                              â”‚  â”‚
â”‚  â”‚  â€¢ ê²Œì„ ë¡œì§, ìŠ¤í¬ë¦½íŠ¸, ë¸”ë£¨í”„ë¦°íŠ¸                                 â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  Render Thread (FRenderingThread::Run)                           â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ ë Œë”ë§ ì»¤ë§¨ë“œ ìƒì„± (DrawCalls)                                 â”‚  â”‚
â”‚  â”‚  â€¢ Scene Proxy ì—…ë°ì´íŠ¸                                          â”‚  â”‚
â”‚  â”‚  â€¢ ì»¬ë§, LOD ê³„ì‚°                                                â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  RHI Thread (FRHIThread::Run)                                    â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ GPU ì»¤ë§¨ë“œ ì „ì†¡ (D3D12, Vulkan)                               â”‚  â”‚
â”‚  â”‚  â€¢ CommandList ì œì¶œ                                              â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  Audio Thread (FAudioDevice::UpdateAudio)                        â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€     â”‚  â”‚
â”‚  â”‚  â€¢ ì˜¤ë””ì˜¤ ë¯¹ì‹±, DSP                                              â”‚  â”‚
â”‚  â”‚  â€¢ ì‚¬ìš´ë“œ ì†ŒìŠ¤ ì—…ë°ì´íŠ¸                                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### FRunnable / FRunnableThread êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     FRunnable / FRunnableThread                         â”‚
â”‚  (ì €ìˆ˜ì¤€ ìŠ¤ë ˆë“œ ìƒì„± - ì „ìš© ìŠ¤ë ˆë“œ)                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ“‚ ìœ„ì¹˜: Core/Public/HAL/Runnable.h:19                                 â”‚
â”‚                                                                         â”‚
â”‚  [FRunnable - ì¸í„°í˜ì´ìŠ¤]                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  class FRunnable                                                 â”‚  â”‚
â”‚  â”‚  {                                                               â”‚  â”‚
â”‚  â”‚  public:                                                         â”‚  â”‚
â”‚  â”‚      virtual bool Init()     { return true; }                   â”‚  â”‚
â”‚  â”‚      virtual uint32 Run() = 0;  // ìˆœìˆ˜ ê°€ìƒ                     â”‚  â”‚
â”‚  â”‚      virtual void Stop()     { }                                â”‚  â”‚
â”‚  â”‚      virtual void Exit()     { }                                â”‚  â”‚
â”‚  â”‚      virtual ~FRunnable()    { }                                â”‚  â”‚
â”‚  â”‚  };                                                              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â”‚  [FRunnableThread - ìŠ¤ë ˆë“œ ê´€ë¦¬]                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  ğŸ“‚ ìœ„ì¹˜: Core/Public/HAL/RunnableThread.h:19                    â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  class FRunnableThread                                           â”‚  â”‚
â”‚  â”‚  {                                                               â”‚  â”‚
â”‚  â”‚  public:                                                         â”‚  â”‚
â”‚  â”‚      static FRunnableThread* Create(                             â”‚  â”‚
â”‚  â”‚          FRunnable* InRunnable,                                  â”‚  â”‚
â”‚  â”‚          const TCHAR* ThreadName,                                â”‚  â”‚
â”‚  â”‚          uint32 InStackSize = 0,                                 â”‚  â”‚
â”‚  â”‚          EThreadPriority InThreadPri = TPri_Normal               â”‚  â”‚
â”‚  â”‚      );                                                          â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚      virtual void SetThreadPriority(EThreadPriority) = 0;       â”‚  â”‚
â”‚  â”‚      virtual void Suspend(bool bShouldPause) = 0;               â”‚  â”‚
â”‚  â”‚      virtual bool Kill(bool bShouldWait = true) = 0;            â”‚  â”‚
â”‚  â”‚      virtual void WaitForCompletion() = 0;                       â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚      uint32 GetThreadID() const;                                â”‚  â”‚
â”‚  â”‚      const FString& GetThreadName() const;                      â”‚  â”‚
â”‚  â”‚  };                                                              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â”‚  [ìƒëª…ì£¼ê¸°]                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  1. FRunnableThread::Create() í˜¸ì¶œ                               â”‚  â”‚
â”‚  â”‚     â†“                                                            â”‚  â”‚
â”‚  â”‚  2. ìƒˆ OS ìŠ¤ë ˆë“œ ìƒì„±                                             â”‚  â”‚
â”‚  â”‚     â†“                                                            â”‚  â”‚
â”‚  â”‚  3. FRunnable::Init() í˜¸ì¶œ (ìŠ¤ë ˆë“œ ì»¨í…ìŠ¤íŠ¸)                      â”‚  â”‚
â”‚  â”‚     - ì´ˆê¸°í™” ì„±ê³µ ì‹œ Run() ì§„í–‰                                   â”‚  â”‚
â”‚  â”‚     - ì‹¤íŒ¨ ì‹œ ìŠ¤ë ˆë“œ ì¢…ë£Œ                                         â”‚  â”‚
â”‚  â”‚     â†“                                                            â”‚  â”‚
â”‚  â”‚  4. FRunnable::Run() ì‹¤í–‰ (ë©”ì¸ ë¡œì§)                            â”‚  â”‚
â”‚  â”‚     - ë¬´í•œ ë£¨í”„ ë˜ëŠ” ì‘ì—… ì™„ë£Œê¹Œì§€ ì‹¤í–‰                            â”‚  â”‚
â”‚  â”‚     - Stop() í˜¸ì¶œ ì‹œ ì¢…ë£Œ ì¤€ë¹„                                    â”‚  â”‚
â”‚  â”‚     â†“                                                            â”‚  â”‚
â”‚  â”‚  5. FRunnable::Exit() í˜¸ì¶œ (ì •ë¦¬)                                â”‚  â”‚
â”‚  â”‚     â†“                                                            â”‚  â”‚
â”‚  â”‚  6. ìŠ¤ë ˆë“œ ì¢…ë£Œ                                                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Task Graph êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Task Graph System                                 â”‚
â”‚  (ì‘ì—… ê¸°ë°˜ ë³‘ë ¬ ì²˜ë¦¬ - ì›Œì»¤ í’€ ì¬ì‚¬ìš©)                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ“‚ ìœ„ì¹˜: Core/Public/Async/TaskGraphInterfaces.h:274                   â”‚
â”‚                                                                         â”‚
â”‚  [ì•„í‚¤í…ì²˜]                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  [Worker Thread Pool]                                            â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚  â”‚
â”‚  â”‚  â”‚Worker 1â”‚ â”‚Worker 2â”‚ â”‚Worker 3â”‚ â”‚Worker Nâ”‚                    â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚  â”‚
â”‚  â”‚       â†‘          â†‘          â†‘          â†‘                         â”‚  â”‚
â”‚  â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚  â”‚
â”‚  â”‚                      â”‚                                            â”‚  â”‚
â”‚  â”‚            [Task Queue (Lock-free)]                              â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚ Task A â†’ Task B â†’ Task C â†’ Task D ...                    â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â”‚                      â†‘                                            â”‚  â”‚
â”‚  â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚  â”‚
â”‚  â”‚         â”‚   QueueTask()           â”‚                              â”‚  â”‚
â”‚  â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                              â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚  [Named Threads]                                                 â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚  â”‚
â”‚  â”‚  â”‚ Game Thread  â”‚  â”‚Render Thread â”‚  â”‚  RHI Thread  â”‚          â”‚  â”‚
â”‚  â”‚  â”‚ (ì „ìš© í)    â”‚  â”‚ (ì „ìš© í)    â”‚  â”‚  (ì „ìš© í)   â”‚          â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â”‚  [ìŠ¤ë ˆë“œ íƒ€ì…]                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  enum ENamedThreads::Type                                        â”‚  â”‚
â”‚  â”‚  {                                                               â”‚  â”‚
â”‚  â”‚      GameThread              = 0,  // ê²Œì„ ë¡œì§                  â”‚  â”‚
â”‚  â”‚      ActualRenderingThread   = 1,  // ë Œë”ë§                    â”‚  â”‚
â”‚  â”‚      RHIThread               = 2,  // RHI (GPU ì»¤ë§¨ë“œ)           â”‚  â”‚
â”‚  â”‚      AnyThread               = 0xff, // ì›Œì»¤ ìŠ¤ë ˆë“œ              â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚      // í íƒ€ì…                                                  â”‚  â”‚
â”‚  â”‚      MainQueue               = 0x000, // ë©”ì¸ í                â”‚  â”‚
â”‚  â”‚      LocalQueue              = 0x100, // ë¡œì»¬ í (ìŠ¤ë ˆë“œ ì „ìš©)   â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚      // ìš°ì„ ìˆœìœ„                                                 â”‚  â”‚
â”‚  â”‚      NormalTaskPriority      = 0x000,                           â”‚  â”‚
â”‚  â”‚      HighTaskPriority        = 0x200,                           â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚      NormalThreadPriority    = 0x000,                           â”‚  â”‚
â”‚  â”‚      HighThreadPriority      = 0x400,                           â”‚  â”‚
â”‚  â”‚      BackgroundThreadPriority = 0x800,                          â”‚  â”‚
â”‚  â”‚  };                                                              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â”‚  [Task ì •ì˜ íŒ¨í„´]                                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  class FMyTask                                                   â”‚  â”‚
â”‚  â”‚  {                                                               â”‚  â”‚
â”‚  â”‚  public:                                                         â”‚  â”‚
â”‚  â”‚      FORCEINLINE TStatId GetStatId() const                       â”‚  â”‚
â”‚  â”‚      {                                                           â”‚  â”‚
â”‚  â”‚          RETURN_QUICK_DECLARE_CYCLE_STAT(FMyTask, STATGROUP_...);â”‚ â”‚
â”‚  â”‚      }                                                           â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚      static ENamedThreads::Type GetDesiredThread()               â”‚  â”‚
â”‚  â”‚      {                                                           â”‚  â”‚
â”‚  â”‚          return ENamedThreads::AnyThread; // ì›Œì»¤ ìŠ¤ë ˆë“œ         â”‚  â”‚
â”‚  â”‚      }                                                           â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚      static ESubsequentsMode::Type GetSubsequentsMode()          â”‚  â”‚
â”‚  â”‚      {                                                           â”‚  â”‚
â”‚  â”‚          return ESubsequentsMode::TrackSubsequents;              â”‚  â”‚
â”‚  â”‚      }                                                           â”‚  â”‚
â”‚  â”‚                                                                  â”‚  â”‚
â”‚  â”‚      void DoTask(ENamedThreads::Type CurrentThread,              â”‚  â”‚
â”‚  â”‚                  const FGraphEventRef& MyCompletionGraphEvent)   â”‚  â”‚
â”‚  â”‚      {                                                           â”‚  â”‚
â”‚  â”‚          // ì‘ì—… ì‹¤í–‰                                            â”‚  â”‚
â”‚  â”‚      }                                                           â”‚  â”‚
â”‚  â”‚  };                                                              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”¬ ì„¤ê³„ ì² í•™: ì™œ Task Graphì¸ê°€?

### FRunnable vs Task Graph

```cpp
// âŒ FRunnable - ì €ìˆ˜ì¤€ ìŠ¤ë ˆë“œ ìƒì„± (ì˜¤ë²„í—¤ë“œ ë†’ìŒ)

class FMyBackgroundWorker : public FRunnable
{
public:
    virtual uint32 Run() override
    {
        while (!bStopRequested)
        {
            // ì¥ê¸° ì‹¤í–‰ ì‘ì—…
            ProcessBackgroundData();
            FPlatformProcess::Sleep(0.1f);
        }
        return 0;
    }

private:
    bool bStopRequested = false;
};

// ì „ìš© ìŠ¤ë ˆë“œ ìƒì„± (1ê°œ ì‘ì—… = 1ê°œ ìŠ¤ë ˆë“œ)
FRunnableThread* Thread = FRunnableThread::Create(
    new FMyBackgroundWorker(),
    TEXT("BackgroundWorker")
);

// ë¬¸ì œì :
// 1. ìŠ¤ë ˆë“œ ìƒì„± ë¹„ìš© ë†’ìŒ (~1ms)
// 2. ìŠ¤ë ˆë“œ ì „í™˜ ì˜¤ë²„í—¤ë“œ
// 3. ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ (ìŠ¤íƒ í¬ê¸°: 1-8MB)
// 4. ì§§ì€ ì‘ì—…ì— ë¹„íš¨ìœ¨ì 
```

```cpp
// âœ… Task Graph - ì‘ì—… ê¸°ë°˜ (ì˜¤ë²„í—¤ë“œ ë‚®ìŒ)

class FMyTask
{
public:
    static ENamedThreads::Type GetDesiredThread()
    {
        return ENamedThreads::AnyThread;
    }

    void DoTask(ENamedThreads::Type CurrentThread,
                const FGraphEventRef& MyCompletionGraphEvent)
    {
        // ì‘ì—… ì‹¤í–‰ (ì›Œì»¤ í’€ ì¬ì‚¬ìš©)
        ProcessData();
    }
};

// Task íì‰ (ì›Œì»¤ í’€ì—ì„œ ì‹¤í–‰)
TGraphTask<FMyTask>::CreateTask().ConstructAndDispatchWhenReady();

// ì¥ì :
// 1. ì›Œì»¤ í’€ ì¬ì‚¬ìš© (ìŠ¤ë ˆë“œ ìƒì„± ì—†ìŒ)
// 2. ì‘ì—… íì‰ ë¹„ìš© ë‚®ìŒ (~50ns)
// 3. ë©”ëª¨ë¦¬ íš¨ìœ¨ì 
// 4. ì§§ì€ ì‘ì—…ì— ìµœì í™”
```

### ì¶”ìƒí™” ë ˆë²¨ ë¹„êµ

| ì ‘ê·¼ë²• | ì˜¤ë²„í—¤ë“œ | ì‚¬ìš© ì‚¬ë¡€ | ì˜ì¡´ì„± ê´€ë¦¬ |
|--------|----------|-----------|------------|
| **FRunnable** | ë†’ìŒ (ìŠ¤ë ˆë“œ ìƒì„±) | ì¥ê¸° ì‹¤í–‰ ì„œë¹„ìŠ¤ (íŒŒì¼ ë¡œë”©, ë„¤íŠ¸ì›Œí¬) | âŒ ìˆ˜ë™ ê´€ë¦¬ |
| **Task Graph** | ë‚®ìŒ (ì›Œì»¤ ì¬ì‚¬ìš©) | ë‹¨ê¸° ì‘ì—…, ì˜ì¡´ì„± ì²´ì¸ | âœ… ìë™ ê´€ë¦¬ (FGraphEvent) |
| **AsyncTask / Async** | ë‚®ìŒ | ë¹„ë™ê¸° í•¨ìˆ˜ í˜¸ì¶œ | âœ… TFuture / TPromise |
| **ParallelFor** | ë‚®ìŒ | ë°ì´í„° ë³‘ë ¬ ë£¨í”„ | âœ… ìë™ ë™ê¸°í™” |

---

## ğŸ§© ì£¼ìš” API

### 1. FRunnable - ì „ìš© ìŠ¤ë ˆë“œ ìƒì„±

```cpp
#include "HAL/Runnable.h"
#include "HAL/RunnableThread.h"

// [1-1] FRunnable ìƒì†
class FMyBackgroundLoader : public FRunnable
{
public:
    FMyBackgroundLoader()
        : bStopRequested(false)
    {
    }

    // ì´ˆê¸°í™” (ìŠ¤ë ˆë“œ ì»¨í…ìŠ¤íŠ¸ì—ì„œ í˜¸ì¶œ)
    virtual bool Init() override
    {
        UE_LOG(LogTemp, Log, TEXT("Background loader initialized"));
        return true;
    }

    // ë©”ì¸ ë£¨í”„ (ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰)
    virtual uint32 Run() override
    {
        while (!bStopRequested)
        {
            // ì‘ì—… ìˆ˜í–‰
            if (HasPendingWork())
            {
                ProcessNextFile();
            }
            else
            {
                // ëŒ€ê¸° (CPU ì ìœ  ë°©ì§€)
                FPlatformProcess::Sleep(0.01f); // 10ms
            }
        }

        return 0; // ì¢…ë£Œ ì½”ë“œ
    }

    // ì¤‘ì§€ ìš”ì²­
    virtual void Stop() override
    {
        bStopRequested = true;
    }

    // ì •ë¦¬ (ìŠ¤ë ˆë“œ ì¢…ë£Œ í›„)
    virtual void Exit() override
    {
        UE_LOG(LogTemp, Log, TEXT("Background loader exiting"));
    }

private:
    bool bStopRequested;
    TQueue<FString> FilesToLoad;

    bool HasPendingWork() const
    {
        return !FilesToLoad.IsEmpty();
    }

    void ProcessNextFile()
    {
        FString FilePath;
        if (FilesToLoad.Dequeue(FilePath))
        {
            // íŒŒì¼ ë¡œë”© ë¡œì§
            UE_LOG(LogTemp, Log, TEXT("Loading file: %s"), *FilePath);
        }
    }
};

// [1-2] ìŠ¤ë ˆë“œ ìƒì„± ë° ì‹œì‘
FMyBackgroundLoader* Runnable = new FMyBackgroundLoader();

FRunnableThread* Thread = FRunnableThread::Create(
    Runnable,
    TEXT("BackgroundLoader"),  // ìŠ¤ë ˆë“œ ì´ë¦„
    0,                          // ìŠ¤íƒ í¬ê¸° (0 = ê¸°ë³¸ê°’)
    TPri_BelowNormal           // ìš°ì„ ìˆœìœ„
);

// [1-3] ì¢…ë£Œ
Thread->Kill(true);  // true = ì™„ë£Œ ëŒ€ê¸°
delete Runnable;
```

### 2. Task Graph - ì‘ì—… ê¸°ë°˜ ë³‘ë ¬ ì²˜ë¦¬

```cpp
#include "Async/TaskGraphInterfaces.h"

// [2-1] Task ì •ì˜
class FMyComputeTask
{
public:
    FMyComputeTask(TArray<float>& InData)
        : Data(InData)
    {
    }

    // Task Graph ìš”êµ¬ì‚¬í•­
    FORCEINLINE TStatId GetStatId() const
    {
        RETURN_QUICK_DECLARE_CYCLE_STAT(FMyComputeTask, STATGROUP_ThreadPoolAsyncTasks);
    }

    static ENamedThreads::Type GetDesiredThread()
    {
        return ENamedThreads::AnyThread;  // ì›Œì»¤ ìŠ¤ë ˆë“œ
    }

    static ESubsequentsMode::Type GetSubsequentsMode()
    {
        return ESubsequentsMode::TrackSubsequents;  // ì˜ì¡´ì„± ì¶”ì 
    }

    // ì‘ì—… ì‹¤í–‰
    void DoTask(ENamedThreads::Type CurrentThread,
                const FGraphEventRef& MyCompletionGraphEvent)
    {
        // ê³„ì‚° ìˆ˜í–‰
        for (float& Value : Data)
        {
            Value = FMath::Sqrt(Value);
        }

        UE_LOG(LogTemp, Log, TEXT("Compute task completed on thread %d"),
            FPlatformTLS::GetCurrentThreadId());
    }

private:
    TArray<float>& Data;
};

// [2-2] Task íì‰ (ë‹¨ì¼ ì‘ì—…)
TArray<float> Data = {1.0f, 4.0f, 9.0f, 16.0f};

FGraphEventRef Task = TGraphTask<FMyComputeTask>::CreateTask()
    .ConstructAndDispatchWhenReady(Data);

// [2-3] ì™„ë£Œ ëŒ€ê¸°
Task->Wait();
// ë˜ëŠ”
FTaskGraphInterface::Get().WaitUntilTaskCompletes(Task);

// [2-4] Task ì²´ì¸ (ì˜ì¡´ì„±)
FGraphEventRef TaskA = TGraphTask<FTaskA>::CreateTask()
    .ConstructAndDispatchWhenReady();

FGraphEventRef TaskB = TGraphTask<FTaskB>::CreateTask(&TaskA)  // TaskA ì˜ì¡´
    .ConstructAndDispatchWhenReady();

FGraphEventRef TaskC = TGraphTask<FTaskC>::CreateTask(&TaskB)  // TaskB ì˜ì¡´
    .ConstructAndDispatchWhenReady();

// TaskA â†’ TaskB â†’ TaskC ìˆœì°¨ ì‹¤í–‰ ë³´ì¥
TaskC->Wait();  // ëª¨ë“  ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
```

### 3. AsyncTask / Async - ê³ ìˆ˜ì¤€ ë¹„ë™ê¸° API

```cpp
#include "Async/Async.h"

// [3-1] ê¸°ë³¸ Async (ëŒë‹¤)
Async(EAsyncExecution::TaskGraph, []()
{
    // ì›Œì»¤ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰
    UE_LOG(LogTemp, Log, TEXT("Async task running"));

    // ê³„ì‚° ìˆ˜í–‰
    return 42;
});

// [3-2] Future/Promise íŒ¨í„´
TFuture<int32> Future = Async(EAsyncExecution::TaskGraph, []() -> int32
{
    // ë¬´ê±°ìš´ ê³„ì‚°
    FPlatformProcess::Sleep(1.0f);
    return 123;
});

// ë‚˜ì¤‘ì— ê²°ê³¼ ê°€ì ¸ì˜¤ê¸°
if (Future.IsReady())
{
    int32 Result = Future.Get();  // ë¸”ë¡œí‚¹
    UE_LOG(LogTemp, Log, TEXT("Result: %d"), Result);
}

// [3-3] ê²Œì„ ìŠ¤ë ˆë“œì—ì„œ ì½œë°± ì‹¤í–‰
Async(EAsyncExecution::Thread, []() -> int32
{
    // ì›Œì»¤ ìŠ¤ë ˆë“œì—ì„œ ë¬´ê±°ìš´ ì‘ì—…
    FPlatformProcess::Sleep(2.0f);
    return ComputeExpensiveValue();

}).Then([](int32 Result)
{
    // ê²Œì„ ìŠ¤ë ˆë“œì—ì„œ ê²°ê³¼ ì²˜ë¦¬
    UE_LOG(LogTemp, Log, TEXT("Result received: %d"), Result);
});

// [3-4] EAsyncExecution ì˜µì…˜
// TaskGraph - ì§§ì€ ì‘ì—… (ì›Œì»¤ í’€)
Async(EAsyncExecution::TaskGraph, []() { /* ë¹ ë¥¸ ì‘ì—… */ });

// Thread - ê¸´ ì‘ì—… (ìƒˆ ìŠ¤ë ˆë“œ ìƒì„±)
Async(EAsyncExecution::Thread, []() { /* ë¬´ê±°ìš´ ì‘ì—… */ });

// ThreadPool - ì›Œì»¤ í’€
Async(EAsyncExecution::ThreadPool, []() { /* ì¤‘ê°„ ì‘ì—… */ });

// TaskGraphMainThread - ê²Œì„ ìŠ¤ë ˆë“œ
Async(EAsyncExecution::TaskGraphMainThread, []() { /* UI ì—…ë°ì´íŠ¸ */ });
```

### 4. ParallelFor - ë³‘ë ¬ ë£¨í”„

```cpp
#include "Async/ParallelFor.h"

// [4-1] ê¸°ë³¸ ParallelFor
TArray<FVector> Positions;
Positions.SetNum(10000);

ParallelFor(Positions.Num(), [&Positions](int32 Index)
{
    // ê° ì¸ë±ìŠ¤ë¥¼ ë³‘ë ¬ë¡œ ì²˜ë¦¬
    Positions[Index] = FVector(Index, Index * 2, Index * 3);
});

// [4-2] ë°°ì¹˜ í¬ê¸° ì§€ì •
int32 TotalItems = 100000;
int32 MinBatchSize = 1000;  // ìµœì†Œ ë°°ì¹˜ í¬ê¸°

ParallelFor(TotalItems, MinBatchSize, [](int32 Index)
{
    // ë¬´ê±°ìš´ ê³„ì‚°
    ProcessItem(Index);
});

// [4-3] í”Œë˜ê·¸ ì‚¬ìš©
ParallelFor(Items.Num(), [](int32 Index)
{
    // ì‘ì—… ì‹œê°„ì´ ë¶ˆê· ë“±í•œ ê²½ìš°
    ProcessVariableTimeItem(Index);
}, EParallelForFlags::Unbalanced);  // ë™ì  ì‘ì—… ë¶„ë°°

// [4-4] Context ì‚¬ìš© (ìŠ¤ë ˆë“œë³„ ëˆ„ì‚°)
struct FContext
{
    int32 Sum = 0;
};

TArray<FContext> Contexts;
Contexts.SetNum(FTaskGraphInterface::Get().GetNumWorkerThreads());

ParallelForWithPreWork(
    TEXT("MyParallelFor"),
    Values.Num(),
    1,  // MinBatchSize
    [&Values](FContext& Context, int32 Index)
    {
        // ê° ìŠ¤ë ˆë“œê°€ Contextì— ëˆ„ì‚°
        Context.Sum += Values[Index];
    },
    []() { /* PreWork */ },
    EParallelForFlags::None,
    Contexts
);

// ê²°ê³¼ ë³‘í•©
int32 TotalSum = 0;
for (const FContext& Context : Contexts)
{
    TotalSum += Context.Sum;
}
```

### 5. FCriticalSection / FRWLock - ë™ê¸°í™”

```cpp
#include "HAL/CriticalSection.h"

// [5-1] FCriticalSection (ë®¤í…ìŠ¤)
class FMyThreadSafeCounter
{
public:
    void Increment()
    {
        FScopeLock Lock(&CriticalSection);  // ìë™ ì ê¸ˆ/í•´ì œ
        Counter++;
    }

    int32 GetValue() const
    {
        FScopeLock Lock(&CriticalSection);
        return Counter;
    }

private:
    mutable FCriticalSection CriticalSection;
    int32 Counter = 0;
};

// [5-2] FRWLock (ì½ê¸°/ì“°ê¸° ì ê¸ˆ)
class FMySharedData
{
public:
    int32 ReadValue() const
    {
        FReadScopeLock ReadLock(RWLock);  // ë‹¤ì¤‘ ì½ê¸° í—ˆìš©
        return Value;
    }

    void WriteValue(int32 NewValue)
    {
        FWriteScopeLock WriteLock(RWLock);  // ë°°íƒ€ì  ì“°ê¸°
        Value = NewValue;
    }

private:
    mutable FRWLock RWLock;
    int32 Value = 0;
};

// [5-3] Try Lock (ë°ë“œë½ ë°©ì§€)
bool TryAcquire(FCriticalSection& CS1, FCriticalSection& CS2)
{
    FScopeTryLock Lock1(&CS1);
    if (!Lock1.IsLocked())
    {
        return false;  // CS1 ì ê¸ˆ ì‹¤íŒ¨
    }

    FScopeTryLock Lock2(&CS2);
    if (!Lock2.IsLocked())
    {
        return false;  // CS2 ì ê¸ˆ ì‹¤íŒ¨
    }

    // ë‘ CS ëª¨ë‘ ì ê¸ˆ ì„±ê³µ
    // ... ì‘ì—… ìˆ˜í–‰ ...

    return true;
}
```

### 6. Thread-safe ì»¨í…Œì´ë„ˆ

```cpp
#include "Containers/Queue.h"
#include "Containers/CircularQueue.h"

// [6-1] TQueue (Lock-free)
TQueue<FString> TaskQueue;

// Producer (ì—¬ëŸ¬ ìŠ¤ë ˆë“œ)
TaskQueue.Enqueue(TEXT("Task1"));
TaskQueue.Enqueue(TEXT("Task2"));

// Consumer (ì—¬ëŸ¬ ìŠ¤ë ˆë“œ)
FString Task;
if (TaskQueue.Dequeue(Task))
{
    ProcessTask(Task);
}

// [6-2] TCircularQueue (ê³ ì • í¬ê¸°)
TCircularQueue<int32> CircularQueue(1024);  // 1024 ìŠ¬ë¡¯

// Producer
if (!CircularQueue.IsFull())
{
    CircularQueue.Enqueue(123);
}

// Consumer
int32 Value;
if (CircularQueue.Dequeue(Value))
{
    ProcessValue(Value);
}
```

### 7. TAtomic - ì›ìì  ì—°ì‚° (Lock-free)

```cpp
#include "HAL/ThreadSafeBool.h"
#include "HAL/ThreadSafeCounter.h"
#include "Templates/Atomic.h"

// [7-1] TAtomic - ê¸°ë³¸ ì›ìì  íƒ€ì…
TAtomic<int32> AtomicCounter(0);

// ì›ìì  ì¦ê°€ (Lock-free)
int32 OldValue = AtomicCounter.fetch_add(1);  // OldValue ë°˜í™˜ í›„ ì¦ê°€
int32 NewValue = ++AtomicCounter;             // ì¦ê°€ í›„ NewValue ë°˜í™˜

// ì›ìì  êµí™˜
int32 OldValue = AtomicCounter.exchange(100); // 100ìœ¼ë¡œ ì„¤ì •, ì´ì „ ê°’ ë°˜í™˜

// Compare-And-Swap (CAS)
int32 Expected = 100;
int32 Desired = 200;
bool bSuccess = AtomicCounter.compare_exchange_strong(Expected, Desired);
// Expected == AtomicCounterì´ë©´ Desiredë¡œ ì„¤ì •, true ë°˜í™˜
// ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ Expectedì— í˜„ì¬ ê°’ ì €ì¥, false ë°˜í™˜

// [7-2] FThreadSafeCounter - ê°„í¸í•œ ì¹´ìš´í„°
FThreadSafeCounter Counter;

Counter.Increment();                           // +1
Counter.Add(10);                               // +10
Counter.Decrement();                           // -1
Counter.Subtract(5);                           // -5
int32 Value = Counter.GetValue();              // í˜„ì¬ ê°’
Counter.Set(0);                                // ì„¤ì •
Counter.Reset();                               // 0ìœ¼ë¡œ ë¦¬ì…‹

// [7-3] FThreadSafeBool - ì›ìì  bool
FThreadSafeBool bIsRunning(true);

if (bIsRunning)                                // ì½ê¸°
{
    // ...
}

bIsRunning = false;                            // ì“°ê¸°
bool bPrevious = bIsRunning.AtomicSet(true);   // êµí™˜

// [7-4] ë©”ëª¨ë¦¬ ë°°ë¦¬ì–´ (Memory Barrier)
// CPU ëª…ë ¹ì–´ ì¬ë°°ì¹˜ ë°©ì§€

// Store Barrier (ì“°ê¸° ë°°ë¦¬ì–´)
MySharedData = 100;
FPlatformMisc::MemoryBarrier();  // ì´ì „ì˜ ëª¨ë“  ì“°ê¸°ê°€ ì™„ë£Œë¨ì„ ë³´ì¥
bDataReady = true;

// Load Barrier (ì½ê¸° ë°°ë¦¬ì–´)
if (bDataReady)
{
    FPlatformMisc::MemoryBarrier();  // ì´í›„ì˜ ëª¨ë“  ì½ê¸°ê°€ ìµœì‹  ê°’ì„ ì½ìŒì„ ë³´ì¥
    int32 Value = MySharedData;
}

// [7-5] Lock-free ìŠ¤íƒ (ì˜ˆì‹œ)
template<typename T>
class TLockFreeStack
{
public:
    void Push(T* NewNode)
    {
        while (true)
        {
            T* OldHead = Head.load(std::memory_order_acquire);
            NewNode->Next = OldHead;

            // CAS: Headê°€ OldHeadì´ë©´ NewNodeë¡œ ë³€ê²½
            if (Head.compare_exchange_weak(OldHead, NewNode,
                std::memory_order_release,
                std::memory_order_acquire))
            {
                break;  // ì„±ê³µ
            }
            // ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ (OldHeadê°€ ì—…ë°ì´íŠ¸ë¨)
        }
    }

    T* Pop()
    {
        while (true)
        {
            T* OldHead = Head.load(std::memory_order_acquire);
            if (!OldHead)
            {
                return nullptr;  // ë¹ˆ ìŠ¤íƒ
            }

            T* NewHead = OldHead->Next;

            // CAS: Headê°€ OldHeadì´ë©´ NewHeadë¡œ ë³€ê²½
            if (Head.compare_exchange_weak(OldHead, NewHead,
                std::memory_order_release,
                std::memory_order_acquire))
            {
                return OldHead;  // ì„±ê³µ
            }
            // ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„
        }
    }

private:
    TAtomic<T*> Head{nullptr};
};

// [7-6] ì„±ëŠ¥ ë¹„êµ: Atomic vs Mutex
// Atomic (Lock-free):
// - ë¹„ê²½ìŸ ì‹œ: ~5-10ns
// - ê²½ìŸ ì‹œ: ~20-50ns (CAS ì¬ì‹œë„)
// - ì§§ì€ ì—°ì‚°ì— ìµœì 

// Mutex (Lock-based):
// - ë¹„ê²½ìŸ ì‹œ: ~25ns
// - ê²½ìŸ ì‹œ: ~1000ns+ (ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­)
// - ë³µì¡í•œ ì—°ì‚°ì— ì í•©

// ì‚¬ìš© ì§€ì¹¨:
// âœ… Atomic: ê°„ë‹¨í•œ ì½ê¸°/ì“°ê¸°, ì¹´ìš´í„°, í”Œë˜ê·¸
// âœ… Mutex: ë³µì¡í•œ ì—°ì‚°, ì—¬ëŸ¬ ë³€ìˆ˜ ë™ì‹œ ë³´í˜¸
```

### 8. ë©”ëª¨ë¦¬ ìˆœì„œ (Memory Ordering)

```cpp
// C++11 ë©”ëª¨ë¦¬ ìˆœì„œ (std::memory_order)
// ì–¸ë¦¬ì–¼ì€ TAtomicì—ì„œ ì´ë¥¼ ì§€ì›

// [8-1] memory_order_relaxed - ê°€ì¥ ì•½í•œ ìˆœì„œ
TAtomic<int32> Counter(0);
Counter.store(1, std::memory_order_relaxed);  // ì¬ë°°ì¹˜ ê°€ëŠ¥
int32 Value = Counter.load(std::memory_order_relaxed);

// [8-2] memory_order_acquire / release - ë™ê¸°í™” ìŒ
TAtomic<bool> bDataReady(false);
int32 SharedData;

// Producer (Release)
SharedData = 123;
bDataReady.store(true, std::memory_order_release);
// Release: ì´ì „ì˜ ëª¨ë“  ì“°ê¸°ê°€ ì™„ë£Œëœ í›„ì— store

// Consumer (Acquire)
if (bDataReady.load(std::memory_order_acquire))
{
    // Acquire: ì´í›„ì˜ ëª¨ë“  ì½ê¸°ê°€ ìµœì‹  ê°’ì„ ì½ìŒ
    int32 Value = SharedData;  // 123 (ë³´ì¥ë¨)
}

// [8-3] memory_order_seq_cst - ìˆœì°¨ ì¼ê´€ì„± (ê¸°ë³¸ê°’)
TAtomic<int32> X(0), Y(0);
X.store(1);  // ê¸°ë³¸ê°’: memory_order_seq_cst
Y.store(2);  // ê¸°ë³¸ê°’: memory_order_seq_cst
// ëª¨ë“  ìŠ¤ë ˆë“œê°€ ë™ì¼í•œ ìˆœì„œë¡œ ê´€ì°°

// [8-4] ì‹¤ì „ ì˜ˆì‹œ: Double-Checked Locking
class FSingleton
{
public:
    static FSingleton* GetInstance()
    {
        // ì²« ë²ˆì§¸ ì²´í¬ (Acquire)
        FSingleton* Tmp = Instance.load(std::memory_order_acquire);
        if (!Tmp)
        {
            FScopeLock Lock(&CriticalSection);

            // ë‘ ë²ˆì§¸ ì²´í¬ (Relaxed)
            Tmp = Instance.load(std::memory_order_relaxed);
            if (!Tmp)
            {
                Tmp = new FSingleton();
                Instance.store(Tmp, std::memory_order_release);
            }
        }
        return Tmp;
    }

private:
    static TAtomic<FSingleton*> Instance;
    static FCriticalSection CriticalSection;
};
```

---

## ğŸ’¡ ìŠ¤ë ˆë“œ ì•ˆì „ íŒ¨í„´

### 1. RAII ì ê¸ˆ íŒ¨í„´

```cpp
// âœ… ì¢‹ìŒ: RAII ì ê¸ˆ (ìë™ í•´ì œ)
void SafeFunction()
{
    FScopeLock Lock(&CriticalSection);

    // ì‘ì—… ìˆ˜í–‰
    ModifySharedData();

    // ì˜ˆì™¸ ë°œìƒí•´ë„ ìë™ í•´ì œ
    if (Error)
    {
        return;  // Lock ìë™ í•´ì œ
    }

}  // ìŠ¤ì½”í”„ ì¢…ë£Œ ì‹œ ìë™ í•´ì œ

// âŒ ë‚˜ì¨: ìˆ˜ë™ ì ê¸ˆ (ì‹¤ìˆ˜ ê°€ëŠ¥)
void UnsafeFunction()
{
    CriticalSection.Lock();

    ModifySharedData();

    if (Error)
    {
        return;  // âŒ Unlock() í˜¸ì¶œ ì•ˆ ë¨! ë°ë“œë½!
    }

    CriticalSection.Unlock();
}
```

### 2. ì½ê¸° ë¹ˆë²ˆ ì‹œ FRWLock

```cpp
// ì½ê¸° 90%, ì“°ê¸° 10% íŒ¨í„´
class FGameConfig
{
public:
    FString GetSetting(const FString& Key) const
    {
        FReadScopeLock ReadLock(RWLock);  // ë‹¤ì¤‘ ì½ê¸° í—ˆìš©
        return Settings.FindRef(Key);
    }

    void SetSetting(const FString& Key, const FString& Value)
    {
        FWriteScopeLock WriteLock(RWLock);  // ë°°íƒ€ì  ì“°ê¸°
        Settings.Add(Key, Value);
    }

private:
    mutable FRWLock RWLock;
    TMap<FString, FString> Settings;
};
```

### 3. ê²Œì„ ìŠ¤ë ˆë“œë¡œ ì½œë°± ì „ë‹¬

```cpp
// âœ… ì•ˆì „: ê²Œì„ ìŠ¤ë ˆë“œì—ì„œ UObject ì ‘ê·¼
void AsyncLoadAndCallback(UMyActor* Actor)
{
    Async(EAsyncExecution::Thread, [Actor]()
    {
        // ì›Œì»¤ ìŠ¤ë ˆë“œ: UObject ì ‘ê·¼ ê¸ˆì§€!
        TArray<uint8> Data = LoadDataFromDisk();

        // ê²Œì„ ìŠ¤ë ˆë“œë¡œ ì „ë‹¬
        AsyncTask(ENamedThreads::GameThread, [Actor, Data]()
        {
            // ê²Œì„ ìŠ¤ë ˆë“œ: UObject ì ‘ê·¼ ì•ˆì „
            Actor->ProcessLoadedData(Data);
        });
    });
}

// âŒ ìœ„í—˜: ì›Œì»¤ ìŠ¤ë ˆë“œì—ì„œ UObject ì ‘ê·¼
void UnsafeAsync(UMyActor* Actor)
{
    Async(EAsyncExecution::TaskGraph, [Actor]()
    {
        Actor->MyProperty = 123;  // âŒ í¬ë˜ì‹œ ê°€ëŠ¥!
        // UObjectëŠ” ê²Œì„ ìŠ¤ë ˆë“œì—ì„œë§Œ ì•ˆì „
    });
}
```

### 4. TLS (Thread Local Storage)

```cpp
#include "HAL/ThreadSingleton.h"

// [4-1] FPlatformTLS - ì €ìˆ˜ì¤€ TLS
// ìŠ¤ë ˆë“œë³„ ê³ ìœ  ë°ì´í„° ì €ì¥

class FMyThreadData
{
public:
    int32 ThreadId;
    FString ThreadName;
};

// TLS ìŠ¬ë¡¯ í• ë‹¹
uint32 TlsSlot = FPlatformTLS::AllocTlsSlot();

// ìŠ¤ë ˆë“œë³„ ë°ì´í„° ì„¤ì •
void SetThreadData()
{
    FMyThreadData* Data = new FMyThreadData();
    Data->ThreadId = FPlatformTLS::GetCurrentThreadId();
    Data->ThreadName = TEXT("WorkerThread");

    FPlatformTLS::SetTlsValue(TlsSlot, Data);
}

// ìŠ¤ë ˆë“œë³„ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
FMyThreadData* GetThreadData()
{
    return (FMyThreadData*)FPlatformTLS::GetTlsValue(TlsSlot);
}

// TLS ìŠ¬ë¡¯ í•´ì œ
FPlatformTLS::FreeTlsSlot(TlsSlot);

// [4-2] thread_local (C++11) - ì–¸ë¦¬ì–¼ì—ì„œë„ ì‚¬ìš© ê°€ëŠ¥
thread_local int32 ThreadLocalCounter = 0;

void IncrementThreadLocal()
{
    ThreadLocalCounter++;  // ê° ìŠ¤ë ˆë“œë§ˆë‹¤ ë³„ë„ ì¹´ìš´í„°
}

// [4-3] FThreadSingleton - ìŠ¤ë ˆë“œë³„ ì‹±ê¸€í†¤
class FMyThreadSingleton : public FThreadSingleton<FMyThreadSingleton>
{
public:
    void DoWork()
    {
        // ìŠ¤ë ˆë“œë³„ ì‘ì—…
    }

private:
    int32 ThreadSpecificData;
};

// ì‚¬ìš©
FMyThreadSingleton::Get().DoWork();  // ê° ìŠ¤ë ˆë“œë§ˆë‹¤ ë³„ë„ ì¸ìŠ¤í„´ìŠ¤

// [4-4] ì‹¤ì „ ì‚¬ìš© ì˜ˆì‹œ: ìŠ¤ë ˆë“œë³„ ë©”ëª¨ë¦¬ í’€
class FThreadMemoryPool
{
public:
    static FThreadMemoryPool& Get()
    {
        static thread_local FThreadMemoryPool Instance;
        return Instance;
    }

    void* Allocate(SIZE_T Size)
    {
        // ìŠ¤ë ˆë“œë³„ ë©”ëª¨ë¦¬ í’€ì—ì„œ í• ë‹¹ (Lock-free)
        return Pool.Allocate(Size);
    }

private:
    FMemoryPool Pool;
};

// ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ë™ì‹œ í˜¸ì¶œ ê°€ëŠ¥ (ê°ì ë³„ë„ í’€ ì‚¬ìš©)
void* Ptr = FThreadMemoryPool::Get().Allocate(1024);
```

### 5. ìŠ¤ë ˆë“œ ì´ˆê¸°í™” ë° ì—”ì§„ ë¶€íŒ…

```cpp
// ì—”ì§„ ë¶€íŒ… ì‹œ ìŠ¤ë ˆë“œ ì´ˆê¸°í™” (FEngineLoop::PreInit)

// [5-1] ìŠ¤ë ˆë“œ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ìˆœì„œ
void InitializeThreadingSystem()
{
    // 1. í”Œë«í¼ TLS ì´ˆê¸°í™”
    FPlatformTLS::Init();

    // 2. ë©”ì¸ ìŠ¤ë ˆë“œ ID ì €ì¥
    GGameThreadId = FPlatformTLS::GetCurrentThreadId();
    GIsGameThreadIdInitialized = true;

    // 3. Task Graph ì´ˆê¸°í™”
    FTaskGraphInterface::Startup(FPlatformMisc::NumberOfCores());
    // - Worker ìŠ¤ë ˆë“œ ìƒì„± (ì½”ì–´ ìˆ˜ì— ë”°ë¼)
    // - ìŠ¤ë ˆë“œ í’€ ì´ˆê¸°í™”

    // 4. ë Œë”ë§ ìŠ¤ë ˆë“œ ì´ˆê¸°í™” (ì˜µì…˜)
    if (GUseThreadedRendering)
    {
        StartRenderingThread();
    }

    // 5. RHI ìŠ¤ë ˆë“œ ì´ˆê¸°í™” (ì˜µì…˜)
    if (GRHISupportsRHIThread)
    {
        StartRHIThread();
    }

    // 6. ì˜¤ë””ì˜¤ ìŠ¤ë ˆë“œ ì´ˆê¸°í™”
    if (FAudioDevice* AudioDevice = GetAudioDevice())
    {
        AudioDevice->InitAudioThread();
    }

    // 7. IO ìŠ¤ë ˆë“œ í’€ ì´ˆê¸°í™”
    FPlatformFileManager::Get().InitializeAsyncIO();
}

// [5-2] ìŠ¤ë ˆë“œ ID í™•ì¸
bool IsInGameThread()
{
    return FPlatformTLS::GetCurrentThreadId() == GGameThreadId;
}

bool IsInRenderingThread()
{
    return FPlatformTLS::GetCurrentThreadId() == GRenderThreadId;
}

// [5-3] ìŠ¤ë ˆë“œ ì´ë¦„ ì„¤ì • (ë””ë²„ê¹…)
void SetThreadName(const TCHAR* Name)
{
    FPlatformProcess::SetThreadName(Name);
    // Windows: SetThreadDescription()
    // Unix: pthread_setname_np()
}

// ì‚¬ìš© ì˜ˆì‹œ
FRunnableThread* Thread = FRunnableThread::Create(
    Runnable,
    TEXT("MyWorkerThread")  // ë””ë²„ê±°ì— í‘œì‹œë¨
);
```

### 6. AsyncLoading - ë¹„ë™ê¸° ì—ì…‹ ë¡œë”©

```cpp
#include "Engine/StreamableManager.h"
#include "UObject/PackageAsyncLoading.h"

// [6-1] AsyncLoading2 ì•„í‚¤í…ì²˜
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UE5ë¶€í„° AsyncLoading2ê°€ ê¸°ë³¸ê°’ (Event Driven Loader)
//
// ìŠ¤ë ˆë“œ êµ¬ì¡°:
// - Game Thread: ë¡œë”© ìš”ì²­ ë° ì™„ë£Œ ì½œë°±
// - AsyncLoadingThread: íŒ¨í‚¤ì§€ íŒŒì‹±, ì˜ì¡´ì„± í•´ì„
// - IO Thread Pool: ë””ìŠ¤í¬ I/O (ë¹„ë™ê¸° íŒŒì¼ ì½ê¸°)
// - Serialization Thread: ì§ë ¬í™” ë° ì˜¤ë¸Œì íŠ¸ ìƒì„±

// [6-2] StreamableManager - ê³ ìˆ˜ì¤€ API
class UMyGameInstance : public UGameInstance
{
public:
    FStreamableManager StreamableManager;

    void LoadAssetAsync()
    {
        // Soft Object Path
        FSoftObjectPath AssetPath(TEXT("/Game/Textures/MyTexture.MyTexture"));

        // ë¹„ë™ê¸° ë¡œë“œ ìš”ì²­
        TSharedPtr<FStreamableHandle> Handle = StreamableManager.RequestAsyncLoad(
            AssetPath,
            [this]()
            {
                // ê²Œì„ ìŠ¤ë ˆë“œì—ì„œ ì½œë°± ì‹¤í–‰
                UTexture2D* LoadedTexture = Cast<UTexture2D>(
                    StreamableManager.GetStreamed(AssetPath)
                );

                if (LoadedTexture)
                {
                    UE_LOG(LogTemp, Log, TEXT("Texture loaded: %s"),
                        *LoadedTexture->GetName());
                }
            }
        );

        // ì§„í–‰ë¥  í™•ì¸
        float Progress = Handle->GetProgress();
    }

    void LoadMultipleAssets()
    {
        TArray<FSoftObjectPath> AssetsToLoad;
        AssetsToLoad.Add(FSoftObjectPath(TEXT("/Game/Textures/Texture1")));
        AssetsToLoad.Add(FSoftObjectPath(TEXT("/Game/Meshes/Mesh1")));
        AssetsToLoad.Add(FSoftObjectPath(TEXT("/Game/Sounds/Sound1")));

        // ì—¬ëŸ¬ ì—ì…‹ ë™ì‹œ ë¡œë“œ
        TSharedPtr<FStreamableHandle> Handle = StreamableManager.RequestAsyncLoad(
            AssetsToLoad,
            []()
            {
                UE_LOG(LogTemp, Log, TEXT("All assets loaded!"));
            },
            FStreamableManager::AsyncLoadHighPriority  // ìš°ì„ ìˆœìœ„
        );

        // ëŒ€ê¸° (ë¸”ë¡œí‚¹)
        Handle->WaitUntilComplete();
    }
};

// [6-3] LoadPackageAsync - ì €ìˆ˜ì¤€ API
void LoadLevelAsync()
{
    int32 RequestID = LoadPackageAsync(
        TEXT("/Game/Maps/MyLevel"),
        FLoadPackageAsyncDelegate::CreateLambda(
            [](const FName& PackageName, UPackage* LoadedPackage,
               EAsyncLoadingResult::Type Result)
            {
                if (Result == EAsyncLoadingResult::Succeeded)
                {
                    UE_LOG(LogTemp, Log, TEXT("Package loaded: %s"),
                        *PackageName.ToString());
                }
                else
                {
                    UE_LOG(LogTemp, Error, TEXT("Failed to load package"));
                }
            }
        ),
        0,  // PackageFlags
        INDEX_NONE,  // PIEInstanceID
        NAME_None  // PackageNameToCreate
    );

    // ì§„í–‰ë¥  í™•ì¸
    float Progress = GetAsyncLoadPercentage(TEXT("/Game/Maps/MyLevel"));
}

// [6-4] AsyncLoading2 ë‚´ë¶€ íŒŒì´í”„ë¼ì¸
/*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  AsyncLoading2 Pipeline                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  [1] Game Thread: LoadPackageAsync() í˜¸ì¶œ                           â”‚
â”‚      â†“                                                              â”‚
â”‚  [2] AsyncLoadingThread: íŒ¨í‚¤ì§€ íŒŒì‹± ì‹œì‘                            â”‚
â”‚      - Package Summary ì½ê¸°                                         â”‚
â”‚      - Import/Export Table ì½ê¸°                                     â”‚
â”‚      - ì˜ì¡´ì„± ë¶„ì„ (ë‹¤ë¥¸ íŒ¨í‚¤ì§€ ì°¸ì¡°)                                 â”‚
â”‚      â†“                                                              â”‚
â”‚  [3] IO Thread Pool: íŒŒì¼ ì½ê¸° (ë¹„ë™ê¸°)                              â”‚
â”‚      - FPlatformFileManager::Get().AsyncRead()                      â”‚
â”‚      - ë””ìŠ¤í¬ â†’ ë©”ëª¨ë¦¬ (DMA)                                         â”‚
â”‚      â†“                                                              â”‚
â”‚  [4] Serialization Thread: ì§ë ¬í™”                                   â”‚
â”‚      - FArchive::Serialize() í˜¸ì¶œ                                   â”‚
â”‚      - UObject ìƒì„± (NewObject)                                     â”‚
â”‚      - í”„ë¡œí¼í‹° ë³µì›                                                 â”‚
â”‚      â†“                                                              â”‚
â”‚  [5] Game Thread: PostLoad() í˜¸ì¶œ                                   â”‚
â”‚      - UObject::PostLoad()                                          â”‚
â”‚      - ì´ˆê¸°í™” ì™„ë£Œ                                                   â”‚
â”‚      - ì½œë°± ì‹¤í–‰                                                     â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
*/

// [6-5] ë™ê¸° vs ë¹„ë™ê¸° ë¡œë”©
// âŒ ë™ê¸° ë¡œë”© (ê²Œì„ í”„ë¦¬ì¦ˆ)
UTexture2D* LoadTextureSync()
{
    // LoadObjectëŠ” ë™ê¸°ì‹ - ê²Œì„ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹!
    UTexture2D* Texture = LoadObject<UTexture2D>(
        nullptr,
        TEXT("/Game/Textures/MyTexture.MyTexture")
    );
    return Texture;  // ë¡œë”© ì™„ë£Œê¹Œì§€ ëŒ€ê¸° (1-2ì´ˆ ê°€ëŠ¥)
}

// âœ… ë¹„ë™ê¸° ë¡œë”© (ê²Œì„ ê³„ì† ì§„í–‰)
void LoadTextureAsync(TFunction<void(UTexture2D*)> OnComplete)
{
    FSoftObjectPath Path(TEXT("/Game/Textures/MyTexture.MyTexture"));

    FStreamableManager& Streamable = UGameInstance::Get()->StreamableManager;
    Streamable.RequestAsyncLoad(
        Path,
        [Path, OnComplete, &Streamable]()
        {
            UTexture2D* Texture = Cast<UTexture2D>(Streamable.GetStreamed(Path));
            OnComplete(Texture);
        }
    );
    // ì¦‰ì‹œ ë°˜í™˜ - ê²Œì„ ê³„ì† ì§„í–‰
}

// [6-6] ë¡œë”© ìš°ì„ ìˆœìœ„
enum class EAsyncLoadPriority
{
    AsyncLoadHighPriority = 0,      // ìµœìš°ì„  (UI í…ìŠ¤ì²˜ ë“±)
    AsyncLoadNormalPriority = 100,  // ì¼ë°˜
    AsyncLoadLowPriority = 200      // ë‚®ìŒ (ë°±ê·¸ë¼ìš´ë“œ)
};

// [6-7] Flush AsyncLoading (ë™ê¸°í™”)
void FlushAsyncLoading()
{
    // ëª¨ë“  ë¹„ë™ê¸° ë¡œë”© ì™„ë£Œê¹Œì§€ ëŒ€ê¸°
    FlushAsyncLoading();  // ê²Œì„ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹!

    // íŠ¹ì • íŒ¨í‚¤ì§€ë§Œ Flush
    FlushAsyncLoading(TEXT("/Game/Maps/MyLevel"));
}

// [6-8] AsyncLoading í†µê³„
void LogAsyncLoadingStats()
{
    // ì§„í–‰ ì¤‘ì¸ ë¡œë”© ê°œìˆ˜
    int32 NumPending = GetNumAsyncPackages();

    // ë¡œë”© ì§„í–‰ë¥ 
    float Progress = GetAsyncLoadPercentage(TEXT("/Game/Maps/MyLevel"));

    UE_LOG(LogTemp, Log, TEXT("Async Loading: %d packages, Progress: %.1f%%"),
        NumPending, Progress * 100.0f);
}
```

---

## ğŸš¨ ì¼ë°˜ì ì¸ í•¨ì •

### âŒ ë°ë“œë½ (Deadlock)

```cpp
// âŒ ë‚˜ì¨: ìˆœí™˜ ì ê¸ˆ (ë°ë“œë½)
FCriticalSection CS1, CS2;

// Thread A
void ThreadA()
{
    FScopeLock Lock1(&CS1);  // CS1 ì ê¸ˆ
    // ...
    FScopeLock Lock2(&CS2);  // CS2 ëŒ€ê¸° (Thread Bê°€ ì†Œìœ )
}

// Thread B
void ThreadB()
{
    FScopeLock Lock2(&CS2);  // CS2 ì ê¸ˆ
    // ...
    FScopeLock Lock1(&CS1);  // CS1 ëŒ€ê¸° (Thread Aê°€ ì†Œìœ )
}
// â†’ ë°ë“œë½ ë°œìƒ!

// âœ… ì¢‹ìŒ: ì ê¸ˆ ìˆœì„œ ì¼ê´€ì„±
void SafeThreadA()
{
    FScopeLock Lock1(&CS1);  // í•­ìƒ CS1 ë¨¼ì €
    FScopeLock Lock2(&CS2);  // ê·¸ ë‹¤ìŒ CS2
}

void SafeThreadB()
{
    FScopeLock Lock1(&CS1);  // í•­ìƒ CS1 ë¨¼ì €
    FScopeLock Lock2(&CS2);  // ê·¸ ë‹¤ìŒ CS2
}
```

### âŒ ì›Œì»¤ ìŠ¤ë ˆë“œì—ì„œ UObject ì ‘ê·¼

```cpp
// âŒ í¬ë˜ì‹œ: UObjectëŠ” ê²Œì„ ìŠ¤ë ˆë“œ ì „ìš©
ParallelFor(Actors.Num(), [&Actors](int32 Index)
{
    AActor* Actor = Actors[Index];
    Actor->SetActorLocation(FVector::ZeroVector);  // âŒ í¬ë˜ì‹œ!
});

// âœ… ì˜¬ë°”ë¦„: ë°ì´í„°ë§Œ ë³‘ë ¬ ì²˜ë¦¬, UObjectëŠ” ê²Œì„ ìŠ¤ë ˆë“œ
TArray<FVector> NewLocations;
NewLocations.SetNum(Actors.Num());

// [1] ë³‘ë ¬ ê³„ì‚° (ì›Œì»¤ ìŠ¤ë ˆë“œ)
ParallelFor(NewLocations.Num(), [&NewLocations](int32 Index)
{
    NewLocations[Index] = CalculateNewLocation(Index);  // âœ… ì•ˆì „
});

// [2] UObject ì ìš© (ê²Œì„ ìŠ¤ë ˆë“œ)
for (int32 i = 0; i < Actors.Num(); ++i)
{
    Actors[i]->SetActorLocation(NewLocations[i]);  // âœ… ì•ˆì „
}
```

### âŒ ì ê¸ˆ ì¤‘ ë¬´ê±°ìš´ ì‘ì—…

```cpp
// âŒ ë‚˜ì¨: ì ê¸ˆ ìƒíƒœì—ì„œ ëŠë¦° ì‘ì—…
void SlowCriticalSection()
{
    FScopeLock Lock(&CriticalSection);

    // âŒ 1ì´ˆ ë™ì•ˆ ë‹¤ë¥¸ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹!
    TArray<uint8> Data = LoadFileFromDisk();
    ProcessData(Data);
}

// âœ… ì¢‹ìŒ: ì ê¸ˆ ìµœì†Œí™”
void FastCriticalSection()
{
    // [1] íŒŒì¼ ë¡œë“œ (ì ê¸ˆ ì—†ì´)
    TArray<uint8> Data = LoadFileFromDisk();

    // [2] ì§§ì€ ì ê¸ˆ
    {
        FScopeLock Lock(&CriticalSection);
        SharedData.Add(Data);  // âœ… ë¹ ë¥¸ ì‘ì—…ë§Œ
    }

    // [3] ë¬´ê±°ìš´ ì‘ì—… (ì ê¸ˆ ì—†ì´)
    ProcessData(Data);
}
```

---

## ğŸ” ë””ë²„ê¹… íŒ

### ìŠ¤ë ˆë“œ ì¶”ì 

```cpp
// í˜„ì¬ ìŠ¤ë ˆë“œ ID í™•ì¸
uint32 ThreadId = FPlatformTLS::GetCurrentThreadId();
UE_LOG(LogTemp, Log, TEXT("Running on thread %u"), ThreadId);

// ê²Œì„ ìŠ¤ë ˆë“œ ì—¬ë¶€ í™•ì¸
bool bIsGameThread = IsInGameThread();
bool bIsRenderThread = IsInRenderingThread();
bool bIsRHIThread = IsInRHIThread();

// Task Graph ì›Œì»¤ ìŠ¤ë ˆë“œ ì—¬ë¶€
bool bIsWorkerThread = LowLevelTasks::FScheduler::Get().IsWorkerThread();
```

### ì½˜ì†” ëª…ë ¹ì–´

```bash
# Task Graph í†µê³„
stat taskgraph

# ìŠ¤ë ˆë“œ í”„ë¡œíŒŒì¼ë§
stat threading

# CPU í”„ë¡œíŒŒì¼ë§
stat cpu

# Unreal Insights ì¶”ì 
-trace=cpu,task,loadtime
```

### Unreal Insights

```cpp
// ì»¤ìŠ¤í…€ ì´ë²¤íŠ¸ ì¶”ì 
TRACE_CPUPROFILER_EVENT_SCOPE(MyParallelWork);

ParallelFor(Items.Num(), [](int32 Index)
{
    TRACE_CPUPROFILER_EVENT_SCOPE(ProcessItem);
    ProcessItem(Index);
});

// Insightsì—ì„œ:
// - ìŠ¤ë ˆë“œë³„ íƒ€ì„ë¼ì¸
// - ì‘ì—… ì‹¤í–‰ ì‹œê°„
// - ì˜ì¡´ì„± ì²´ì¸
```

---

## ğŸ”— ì°¸ê³ ìë£Œ

- [Multithreading in Unreal Engine](https://docs.unrealengine.com/multithreading-in-unreal-engine/)
- [Task Graph System](https://docs.unrealengine.com/task-graph-system-in-unreal-engine/)
- [Async Tasks](https://docs.unrealengine.com/async-tasks-in-unreal-engine/)
- [Runnable.h Source](Engine/Source/Runtime/Core/Public/HAL/Runnable.h)
- [TaskGraphInterfaces.h Source](Engine/Source/Runtime/Core/Public/Async/TaskGraphInterfaces.h)
- [ParallelFor.h Source](Engine/Source/Runtime/Core/Public/Async/ParallelFor.h)

**ì—°ê´€ ë¬¸ì„œ:**
- [Core/EngineInitialization.md](./EngineInitialization.md) - ìŠ¤ë ˆë“œ ì´ˆê¸°í™”
- [Core/Memory.md](./Memory.md) - ë©”ëª¨ë¦¬ í• ë‹¹ì (ìŠ¤ë ˆë“œ ì•ˆì „)

---

> ğŸ“… ìƒì„±: 2025-10-21 â€” ë©€í‹°ìŠ¤ë ˆë”© ì‹œìŠ¤í…œ ë¬¸ì„œí™” (UE 5.7 ê²€ì¦ ì™„ë£Œ)
