---
title: "Lumen Architecture Deep Dive"
date: "2025-11-23"
status: "stable"
project: "UnrealEngine"
lang: "ko"
category: "unreal-summary"
track: "Lumen"
tags: ["unreal", "Lumen"]
---
# Lumen Architecture Deep Dive

## ğŸ§­ 1. ì„¤ê³„ ì² í•™ (Design Philosophy)

### 1.1 Lumenì˜ íƒ„ìƒ ë°°ê²½

Lumenì€ **í•˜ë“œì›¨ì–´ ë ˆì´ íŠ¸ë ˆì´ì‹±(DXR)ì˜ ê·¼ë³¸ì ì¸ í•œê³„**ë¥¼ ê·¹ë³µí•˜ê¸° ìœ„í•´ ì„¤ê³„ëœ ì†Œí”„íŠ¸ì›¨ì–´ ê¸°ë°˜ ê¸€ë¡œë²Œ ì¼ë£¨ë¯¸ë„¤ì´ì…˜ ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

#### DXRì˜ í•œê³„ì 

| í•œê³„ ì˜ì—­ | ë¬¸ì œì  | ì‹¤ì‹œê°„ ê²Œì„ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ |
|----------|--------|-------------------------|
| **BVH ì—…ë°ì´íŠ¸ ì†ë„** | ë™ì  ë©”ì‹œ ë³€í˜• ì‹œ BVH ì¬êµ¬ì¶• ë¹„ìš©ì´ ë§¤ìš° ë†’ìŒ | ì• ë‹ˆë©”ì´ì…˜, íŒŒê´´, ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì„±ëŠ¥ ì €í•˜ |
| **ì¤‘ì²© ì§€ì˜¤ë©”íŠ¸ë¦¬ ì²˜ë¦¬** | ê²¹ì¹˜ëŠ” ë©”ì‹œì—ì„œ BVH íš¨ìœ¨ ê¸‰ê²©íˆ ì €í•˜ | í´ë¦¬ì§€(foliage), ë°€ì§‘ëœ í™˜ê²½ì—ì„œ ì„±ëŠ¥ ê¸‰ë½ |
| **íŒŒì´í”„ë¼ì¸ ì œì–´ ë¶€ì¡±** | í•˜ë“œì›¨ì–´ êµ¬í˜„ì— ì˜ì¡´, ìµœì í™” ì—¬ì§€ ì œí•œ | í’ˆì§ˆ-ì„±ëŠ¥ íŠ¸ë ˆì´ë“œì˜¤í”„ ì¡°ì • ë¶ˆê°€ |
| **í•˜ë“œì›¨ì–´ ì¢…ì†ì„±** | RTX ì¹´ë“œ ì „ìš© (NVIDIA 2000 ì‹œë¦¬ì¦ˆ ì´ìƒ) | ì½˜ì†” ë° ì¼ë°˜ GPU ì§€ì› ë¶ˆê°€ |

#### Lumenì˜ í•µì‹¬ ì„¤ê³„ ëª©í‘œ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Lumen ì„¤ê³„ 3ëŒ€ ì›ì¹™                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  1. ì™„ì „í•œ íŒŒì´í”„ë¼ì¸ ì œì–´ (Full Pipeline Control)                       â”‚
â”‚     â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚     ì†Œí”„íŠ¸ì›¨ì–´ êµ¬í˜„ â†’ ê° ë‹¨ê³„ë³„ ìµœì í™” ê°€ëŠ¥                               â”‚
â”‚     â€¢ ê°€ì† êµ¬ì¡° ì„ íƒê¶Œ (HZB, MDF, GDF)                                   â”‚
â”‚     â€¢ ìƒ˜í”Œë§ ì „ëµ ì œì–´ (temporal accumulation, importance sampling)     â”‚
â”‚     â€¢ í’ˆì§ˆ-ì„±ëŠ¥ ë°¸ëŸ°ìŠ¤ ì¡°ì • ê°€ëŠ¥ (ì½˜ì†” ë³€ìˆ˜ë¥¼ í†µí•œ ì‹¤ì‹œê°„ íŠœë‹)           â”‚
â”‚                                                                         â”‚
â”‚  2. ê´‘ë²”ìœ„í•œ í•˜ë“œì›¨ì–´ ì§€ì› (Wide Hardware Compatibility)                 â”‚
â”‚     â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚     RTX ë¶ˆí•„ìš” â†’ ëª¨ë“  í˜„ì„¸ëŒ€ GPUì—ì„œ ë™ì‘                                â”‚
â”‚     â€¢ ì½˜ì†” (PlayStation 5, Xbox Series X/S) ì™„ì „ ì§€ì›                  â”‚
â”‚     â€¢ ì €ì‚¬ì–‘ PC (GTX 1000 ì‹œë¦¬ì¦ˆ ì´ìƒ)                                   â”‚
â”‚     â€¢ í•˜ë“œì›¨ì–´ RT ìˆìœ¼ë©´ ì„ íƒì  í™œìš© (HWRT ì˜µì…˜)                         â”‚
â”‚                                                                         â”‚
â”‚  3. ì‹¤ì‹œê°„ ì„±ëŠ¥ ìš°ì„  (Real-Time Performance First)                       â”‚
â”‚     â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚     ì •í™•ë„ë³´ë‹¤ ì†ë„ ìš°ì„  â†’ ê²Œì„ì— ì í•©í•œ íŠ¸ë ˆì´ë“œì˜¤í”„                     â”‚
â”‚     â€¢ 60fps íƒ€ê²Ÿ ìœ ì§€ (ì½˜ì†” ê¸°ì¤€ 1440p)                                  â”‚
â”‚     â€¢ ë™ì  í’ˆì§ˆ ìŠ¤ì¼€ì¼ë§ (ë¶€í•˜ì— ë”°ë¼ ìë™ ì¡°ì •)                          â”‚
â”‚     â€¢ ì‹œê°„ì  ì•ˆì •ì„± (ghosting ìµœì†Œí™”)                                    â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 í•µì‹¬ ì„¤ê³„ ì² í•™: ì •í™•ë„ vs ì†ë„ íŠ¸ë ˆì´ë“œì˜¤í”„

Lumenì˜ ëª¨ë“  ì„¤ê³„ ê²°ì •ì€ **"ë¬¼ë¦¬ì  ì •í™•ë„ë¥¼ í¬ìƒí•˜ì—¬ ì‹¤ì‹œê°„ ì„±ëŠ¥ì„ í™•ë³´"** ì›ì¹™ì— ê¸°ë°˜í•©ë‹ˆë‹¤.

#### ì² í•™ì  íŠ¸ë ˆì´ë“œì˜¤í”„ ì „ëµ

```
ë¬¼ë¦¬ ê¸°ë°˜ ë Œë”ë§ ë°©ì •ì‹ (Kajiya, 1986):

Lâ‚€(x, Ï‰â‚€) = Lâ‚‘(x, Ï‰â‚€) + âˆ«_Î© fáµ£(x, Ï‰áµ¢, Ï‰â‚€) Láµ¢(x, Ï‰áµ¢) (Ï‰áµ¢Â·n) dÏ‰áµ¢
            â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             ìì²´ ë°œê´‘            ë°˜ì‚¬ê´‘ ì ë¶„ (ë¬´í•œ ìƒ˜í”Œ í•„ìš”)


Lumenì˜ ê·¼ì‚¬ ì „ëµ:

1. ì ë¶„ â†’ ëª¬í…Œì¹´ë¥¼ë¡œ ìƒ˜í”Œë§ (32 rays/probe, 4 frame accumulation)
2. ì „ì—­ â†’ ë‹¤ì¸µ ê·¼ì‚¬ (HZB â†’ MDF â†’ GDF)
3. ì—°ì† â†’ ì´ì‚°í™” (probes, clipmaps, surface cache)
```

**êµ¬ì²´ì  íŠ¸ë ˆì´ë“œì˜¤í”„ ì‚¬ë¡€:**

| ë¬¼ë¦¬ì ìœ¼ë¡œ ì •í™•í•œ ë°©ë²• | Lumenì˜ ê·¼ì‚¬ | ì„±ëŠ¥ í–¥ìƒ | ì‹œê°ì  ì°¨ì´ |
|---------------------|-------------|----------|------------|
| ë¬´í•œ ë ˆì´ ìƒ˜í”Œë§ | 32 rays/probe, 4 í”„ë ˆì„ ëˆ„ì  | ~1000ë°° | ê³ ì£¼íŒŒ ë””í…Œì¼ ì†ì‹¤ (ë…¸ì´ì¦ˆ) |
| ì „ì—­ Distance Field | 40m MDF + GDF ë¶„ë¦¬ | ~5ë°° | ì›ê±°ë¦¬ ì •í™•ë„ ê°ì†Œ |
| í”½ì…€ë‹¹ GI ê³„ì‚° | 1/16 í•´ìƒë„ probe + ë³´ê°„ | ~16ë°° | ë¯¸ì„¸í•œ ê³µê°„ í”ë“¤ë¦¼ |
| Per-pixel material | Surface Cache (4K atlas) | ~10ë°° | ì¼ë¶€ ê³ ì£¼íŒŒ ì¬ì§ˆ ì •ë³´ ì†ì‹¤ |

### 1.3 ì•„í‚¤í…ì²˜ ì„¤ê³„ ì›ì¹™

#### ê³„ì¸µì  ê·¼ì‚¬ (Hierarchical Approximation)

Lumenì€ **ê±°ë¦¬ì™€ ì¤‘ìš”ë„ì— ë”°ë¼ ë‹¤ë¥¸ ì •í™•ë„ì˜ ë°ì´í„° êµ¬ì¡°**ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤:

```
     ì •í™•ë„ â†‘
        â”‚
   HZB  â”‚  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  (Screen Space, ~ìˆ˜ ë¯¸í„°)
        â”‚  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   ê°€ì¥ ì •í™•, ê°€ì¥ ë¹„ìŒˆ
        â”‚
   MDF  â”‚  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ        (Mesh Distance Field, ~40m)
        â”‚  â–ˆâ–ˆâ–ˆâ–ˆ          ì¤‘ê°„ ì •í™•ë„, ì¤‘ê°„ ë¹„ìš©
        â”‚
   GDF  â”‚  â–ˆâ–ˆ            (Global Distance Field, ~ìˆ˜ ë°±m)
        â”‚  â–ˆ             ë‚®ì€ ì •í™•ë„, ì €ë¹„ìš©
        â”‚
Skylightâ”‚  â–“             (ë¬´í•œ ê±°ë¦¬)
        â”‚                ë‹¨ì¼ íë¸Œë§µ, ë§¤ìš° ì €ë ´
        â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ ê±°ë¦¬
                                              (ì¹´ë©”ë¼ë¡œë¶€í„°)
```

**ì„¤ê³„ ì´ì :**
- ê°€ê¹Œìš´ ë¬¼ì²´: ë†’ì€ ë””í…Œì¼ (í”Œë ˆì´ì–´ê°€ ì¸ì§€ ê°€ëŠ¥)
- ë¨¼ ë¬¼ì²´: ë‚®ì€ ë””í…Œì¼ (ì–´ì°¨í”¼ ë³´ì´ì§€ ì•ŠìŒ)
- **ìë™ LOD**: ê±°ë¦¬ì— ë”°ë¼ ìì—°ìŠ¤ëŸ½ê²Œ í’ˆì§ˆ ê°ì†Œ

#### ì‹œê³µê°„ ì¬ì‚¬ìš© (Spatiotemporal Reuse)

Lumenì€ **í”„ë ˆì„ ê°„ ì •ë³´ ëˆ„ì **ìœ¼ë¡œ ìƒ˜í”Œ ìˆ˜ë¥¼ ì¤„ì…ë‹ˆë‹¤:

```
í”„ë ˆì„ 0: â—‹ â—‹ â—‹ â—‹  (4ê°œ ray)   â”
í”„ë ˆì„ 1:  â—‹ â—‹ â—‹ â—‹  (4ê°œ ray)   â”‚
í”„ë ˆì„ 2: â—‹ â—‹ â—‹ â—‹  (4ê°œ ray)   â”œâ”€ 4 í”„ë ˆì„ ëˆ„ì  = 16 ìƒ˜í”Œ íš¨ê³¼
í”„ë ˆì„ 3:  â—‹ â—‹ â—‹ â—‹  (4ê°œ ray)   â”‚
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”˜
          ì‹œê°„ì  ëˆ„ì  (Temporal Accumulation)

          +

ê³µê°„ì  ì¬ì‚¬ìš© (Spatial Reuse):
í”„ë¡œë¸Œ 1 â”€â”¬â”€ ë³´ê°„ â”€â†’ ìµœì¢… í”½ì…€
í”„ë¡œë¸Œ 2 â”€â”¤         (16x16 í”½ì…€ì´ 1ê°œ í”„ë¡œë¸Œ ê³µìœ )
í”„ë¡œë¸Œ 3 â”€â”¤
í”„ë¡œë¸Œ 4 â”€â”˜
```

**ì£¼ì˜ì‚¬í•­:**
- ì‹œê°„ì  ëˆ„ì  â†’ Ghosting ìœ„í—˜ (ë¹ ë¥¸ ì¹´ë©”ë¼ ì´ë™ ì‹œ)
- ê³µê°„ì  ë³´ê°„ â†’ Light leaking ê°€ëŠ¥ (ì–‡ì€ ë²½)

### 1.4 Naniteì™€ì˜ ì‹œë„ˆì§€

Lumenì€ **Naniteì˜ ê°€ìƒí™”ëœ ì§€ì˜¤ë©”íŠ¸ë¦¬ ì‹œìŠ¤í…œ**ê³¼ ê¸´ë°€íˆ í†µí•©ë˜ì–´ ìˆìŠµë‹ˆë‹¤:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Nanite + Lumen í†µí•© ì•„í‚¤í…ì²˜                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  Nanite (Virtualized Geometry)                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â€¢ ìˆ˜ì‹­ì–µ í´ë¦¬ê³¤ ìŠ¤íŠ¸ë¦¬ë°                                           â”‚ â”‚
â”‚  â”‚  â€¢ ìë™ LOD ì „í™˜ (pixel-perfect detail)                            â”‚ â”‚
â”‚  â”‚  â€¢ ë³‘ë ¬ ë˜ìŠ¤í„°í™” (Compute Shader)                                  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                  â”‚                                                      â”‚
â”‚                  â–¼ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë°ì´í„° ê³µìœ                                 â”‚
â”‚                  â”‚                                                      â”‚
â”‚  Lumen (Software Ray Tracing)                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  â€¢ Mesh Distance Field ìƒì„± (Nanite ë©”ì‹œë¡œë¶€í„°)                    â”‚ â”‚
â”‚  â”‚  â€¢ Mesh Cards ìƒì„± (6ë°©í–¥ ì •ì‚¬ì˜)                                  â”‚ â”‚
â”‚  â”‚  â€¢ Surface Cache ì—…ë°ì´íŠ¸ (ë¨¸í‹°ë¦¬ì–¼ ìƒ˜í”Œë§)                        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                         â”‚
â”‚  â˜… í•µì‹¬ ì‹œë„ˆì§€:                                                         â”‚
â”‚     Naniteê°€ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë³µì¡ë„ í•´ê²° â†’ Lumenì´ ë¼ì´íŒ… ë³µì¡ë„ í•´ê²°       â”‚
â”‚     ë‘˜ ë‹¤ ì†Œí”„íŠ¸ì›¨ì–´ ê¸°ë°˜ â†’ í•˜ë“œì›¨ì–´ ë…ë¦½ì„± ìœ ì§€                        â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§± 2. ì „ì²´ ì•„í‚¤í…ì²˜ ê°œìš” (Architecture Overview)

### 2.1 Lumen íŒŒì´í”„ë¼ì¸ ì „ì²´ íë¦„

Lumenì˜ GI ê³„ì‚°ì€ **4ë‹¨ê³„ íŒŒì´í”„ë¼ì¸**ìœ¼ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Lumen GI íŒŒì´í”„ë¼ì¸                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   ì…ë ¥                      ì²˜ë¦¬ ë‹¨ê³„                         ì¶œë ¥
   â”€â”€â”€â”€                      â”€â”€â”€â”€â”€â”€                           â”€â”€â”€â”€

 G-Buffer        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 (Geometry)  â”€â”€â†’ â”‚  1ï¸âƒ£  Acceleration Structure Build  â”‚
 Nanite Mesh     â”‚      ê°€ì† êµ¬ì¡° ì¤€ë¹„                  â”‚
 Transforms      â”‚  â€¢ HZB (Screen Space)               â”‚
                 â”‚  â€¢ MDF (Mesh Distance Field)        â”‚
                 â”‚  â€¢ GDF (Global Distance Field)      â”‚ â”€â”€ Distance Fields
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    Hierarchical Data
                                   â†“
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚  2ï¸âƒ£  Material Sampling              â”‚
                 â”‚      ì”¬ ë¨¸í‹°ë¦¬ì–¼ ì •ë³´ ìº¡ì²˜            â”‚
                 â”‚  â€¢ Surface Cache (4K atlas)         â”‚
                 â”‚  â€¢ Mesh Cards (6-sided projection)  â”‚
                 â”‚  â€¢ Nanite í†µí•©                       â”‚ â”€â”€ Surface Cache
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    Material Data
                                   â†“
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  Light Sources  â”‚  3ï¸âƒ£  Light Accumulation             â”‚
  (Direct)   â”€â”€â†’ â”‚      ë¼ì´íŒ… ëˆ„ì                      â”‚
                 â”‚  â€¢ Direct Lighting (shadow maps)    â”‚
                 â”‚  â€¢ Indirect Lighting (probes)       â”‚
                 â”‚  â€¢ Volumetric Clipmaps (GI volume) â”‚ â”€â”€ Radiance Probes
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    3D GI Data
                                   â†“
  G-Buffer       â”‚  4ï¸âƒ£  Final Gather                   â”‚
  (Normals,  â”€â”€â†’ â”‚      ìµœì¢… ì…°ì´ë”©                     â”‚
   Roughness)    â”‚  â€¢ SSRC (Screen Space Radiance)     â”‚
                 â”‚  â€¢ WSRC (World Space Radiance)      â”‚
                 â”‚  â€¢ Temporal Filter                  â”‚ â”€â”€ Final Image
                 â”‚  â€¢ Spatial Filter                   â”‚    with GI
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ê° ë‹¨ê³„ë³„ í•µì‹¬ ì±…ì„

#### 1ï¸âƒ£ Acceleration Structure (ê°€ì† êµ¬ì¡°)

**ì±…ì„:** ë ˆì´ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì”¬ê³¼ êµì°¨ ê²€ì‚¬

```cpp
// ê°€ìƒ ì½”ë“œ - ë ˆì´ íŠ¸ë ˆì´ì‹± ì¿¼ë¦¬
bool TraceRay(Ray ray, out HitResult hit)
{
    // 1. Screen Space (ê°€ì¥ ê°€ê¹Œì›€, ê°€ì¥ ì •í™•)
    if (TraceScreenSpace(ray, hit))
        return true;  // HZB íˆíŠ¸ (~1ms)

    // 2. Mesh Distance Field (ì¤‘ê±°ë¦¬)
    if (TraceMeshDistanceField(ray, hit))
        return true;  // Sphere tracing (~5ms)

    // 3. Global Distance Field (ì›ê±°ë¦¬)
    if (TraceGlobalDistanceField(ray, hit))
        return true;  // Coarse sphere tracing (~2ms)

    // 4. Skylight (ë¬´í•œ ê±°ë¦¬)
    hit.Radiance = SampleSkylight(ray.Direction);
    return false;  // (~0.1ms)
}
```

**ì„±ëŠ¥ íŠ¹ì„±:**
- HZB: ê°€ì¥ ë¹ ë¦„ (í™”ë©´ ë‚´ í”½ì…€ë§Œ ê³ ë ¤)
- MDF: ì¤‘ê°„ (40m ë²”ìœ„, sphere tracing)
- GDF: ë¹ ë¦„ (ë‚®ì€ í•´ìƒë„, í° ìŠ¤í…)
- Skylight: ë§¤ìš° ë¹ ë¦„ (ë‹¨ì¼ í…ìŠ¤ì²˜ ìƒ˜í”Œë§)

#### 2ï¸âƒ£ Material Sampling (ë¨¸í‹°ë¦¬ì–¼ ìƒ˜í”Œë§)

**ì±…ì„:** ë ˆì´ê°€ íˆíŠ¸í•œ í‘œë©´ì˜ ë¨¸í‹°ë¦¬ì–¼ ì •ë³´ ì œê³µ

```
ì”¬ ì§€ì˜¤ë©”íŠ¸ë¦¬ â”€â”¬â”€â†’ Mesh Cards (6ë°©í–¥ orthogonal projections)
              â”‚    â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
              â”‚    â”‚ +X  â”‚ -X  â”‚ +Y  â”‚ -Y  â”‚ +Z  â”‚ -Z  â”‚
              â”‚    â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
              â”‚         ê° ì¹´ë“œ â†’ Surface Cacheì— ë Œë”ë§
              â”‚
              â””â”€â†’ Surface Cache (4K x 4K atlas)
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚ [Mesh A ì¹´ë“œë“¤]  [Mesh B ì¹´ë“œë“¤]  â”‚
                   â”‚ â”Œâ”€â”€â”¬â”€â”€â”          â”Œâ”€â”€â”¬â”€â”€â”¬â”€â”€â”      â”‚
                   â”‚ â”‚+Xâ”‚-Xâ”‚          â”‚+Yâ”‚-Yâ”‚+Zâ”‚      â”‚
                   â”‚ â””â”€â”€â”´â”€â”€â”˜          â””â”€â”€â”´â”€â”€â”´â”€â”€â”˜      â”‚
                   â”‚        Albedo, Normal, Emissive  â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ë ˆì´ íˆíŠ¸ ìœ„ì¹˜ â†’ UV ê³„ì‚° â†’ Surface Cache ìƒ˜í”Œë§ â†’ Material Properties
```

**í•µì‹¬ ìµœì í™”:**
- 4K í…ìŠ¤ì²˜ 1ì¥ìœ¼ë¡œ ì „ì²´ ì”¬ ì»¤ë²„ (ë©”ëª¨ë¦¬ íš¨ìœ¨)
- Mesh Cardsë¡œ ë³µì¡í•œ ì§€ì˜¤ë©”íŠ¸ë¦¬ ë‹¨ìˆœí™”
- ì—…ë°ì´íŠ¸ëŠ” ë³€ê²½ëœ ë©”ì‹œë§Œ (ì¦ë¶„ ì—…ë°ì´íŠ¸)

#### 3ï¸âƒ£ Light Accumulation (ë¼ì´íŒ… ëˆ„ì )

**ì±…ì„:** ì§ì ‘ê´‘ + ê°„ì ‘ê´‘ ê³„ì‚° ë° ì €ì¥

```
ì§ì ‘ê´‘ (Direct Lighting):
   Light Source â†’ Shadow Map â†’ Surface Cache ì—…ë°ì´íŠ¸

ê°„ì ‘ê´‘ (Indirect Lighting):
   1. Radiance Probes (êµ¬í˜• ë°°ì¹˜)
      â”œâ”€ í”„ë¡œë¸Œ ìœ„ì¹˜: World space grid (adaptive placement)
      â”œâ”€ ìƒ˜í”Œë§: 32 rays/probe
      â””â”€ ì €ì¥: Spherical harmonics (SH) ë˜ëŠ” octahedral map

   2. Volumetric Clipmaps (5-layer nested grids)
      â”œâ”€ Layer 0: ì„¸ë°€ (voxel size = 0.5m)
      â”œâ”€ Layer 1: ì¤‘ê°„ (voxel size = 1m)
      â”œâ”€ Layer 2: ì¤‘ê°„ (voxel size = 2m)
      â”œâ”€ Layer 3: ê±°ì¹¨ (voxel size = 4m)
      â””â”€ Layer 4: ë§¤ìš° ê±°ì¹¨ (voxel size = 8m)

      ê° voxel ì €ì¥: Radiance (RGB) + Direction
```

**ë°ì´í„° êµ¬ì¡°:**

```
Radiance Probe (í”„ë¡œë¸Œ 1ê°œ):
{
    float3 Position;           // World ì¢Œí‘œ
    float3 Radiance[32];       // 32 ë°©í–¥ radiance
    float Weight[32];          // ìƒ˜í”Œ ê°€ì¤‘ì¹˜
    uint32 LastUpdateFrame;    // ì‹œê°„ì  ì¼ê´€ì„± ì¶”ì 
}

Volumetric Clipmap Layer (ë ˆì´ì–´ 1ê°œ):
{
    float3 Center;             // ì¹´ë©”ë¼ ì¤‘ì‹¬
    float VoxelSize;           // ë³µì…€ í¬ê¸°
    Texture3D<float4> Data;    // RGB=radiance, A=opacity
    uint32 Resolution;         // ë³´í†µ 64Â³ ë˜ëŠ” 128Â³
}
```

#### 4ï¸âƒ£ Final Gather (ìµœì¢… ìˆ˜ì§‘)

**ì±…ì„:** í”½ì…€ë³„ë¡œ GI ì¿¼ë¦¬ ë° í•„í„°ë§

```
í™”ë©´ í”½ì…€ (1920x1080) â†’ í”„ë¡œë¸Œ ë°°ì¹˜ (120x68, 1/16 í•´ìƒë„)

ê° í”„ë¡œë¸Œ:
  â”œâ”€ SSRC (Screen Space Radiance Cache)
  â”‚   â”œâ”€ 32 rays ë°œì‚¬ (importance sampled)
  â”‚   â”œâ”€ ê°€ì† êµ¬ì¡° ì¿¼ë¦¬ (HZBâ†’MDFâ†’GDF)
  â”‚   â”œâ”€ ë¨¸í‹°ë¦¬ì–¼ ìƒ˜í”Œë§ (Surface Cache)
  â”‚   â””â”€ Radiance ëˆ„ì  (BRDF weighted)
  â”‚
  â””â”€ WSRC (World Space Radiance Cache)
      â”œâ”€ Volumetric Clipmap ì¿¼ë¦¬
      â”œâ”€ Radiance Probe ë³´ê°„
      â””â”€ ê²°ê³¼ ìºì‹± (spatial coherence)

í”„ë¡œë¸Œ ê²°ê³¼ â†’ 16x16 í”½ì…€ ë¸”ë¡ì— ë³´ê°„ â†’ Temporal Filter â†’ Spatial Filter
```

**í•„í„°ë§ ì „ëµ:**

```
ì‹œê°„ì  í•„í„° (Temporal Filter):
  Current = lerp(Previous, New, Î±)
  Î± = 0.05 ~ 0.2 (4~20 í”„ë ˆì„ ëˆ„ì )

  ë¬¸ì œ: ë¹ ë¥¸ ì¹´ë©”ë¼ ì´ë™ ì‹œ ghosting
  í•´ê²°: ëª¨ì…˜ ë²¡í„° ê¸°ë°˜ disocclusion detection

ê³µê°„ì  í•„í„° (Spatial Filter):
  Bilateral filter (edge-aware blur)
  - ê°€ì¤‘ì¹˜: distance + normal similarity + depth similarity
  - ë°˜ê²½: 2~4 í”½ì…€

  ë¬¸ì œ: Light leaking (ì–‡ì€ ë²½)
  í•´ê²°: Depth-aware filtering
```

### 2.3 ì£¼ìš” ë°ì´í„° êµ¬ì¡° í¬ê¸°

| ë°ì´í„° êµ¬ì¡° | í•´ìƒë„/í¬ê¸° | ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ (ëŒ€ëµ) | ì—…ë°ì´íŠ¸ ë¹ˆë„ |
|-----------|-----------|-------------------|-------------|
| **HZB (Hierarchical Z-Buffer)** | 1920x1080 â†’ 1x1 (mip chain) | ~8 MB | ë§¤ í”„ë ˆì„ |
| **MDF (Mesh Distance Field)** | ë©”ì‹œë‹¹ 64Â³ ~ 128Â³ | ë©”ì‹œë‹¹ ~1-8 MB | íŠ¸ëœìŠ¤í¼ ë³€ê²½ ì‹œ |
| **GDF (Global Distance Field)** | 256Â³ ~ 512Â³ (5 clipmap layers) | ~50-200 MB | ë§¤ í”„ë ˆì„ (ì¦ë¶„) |
| **Surface Cache** | 4096 x 4096 (Albedo + Normal + Emissive) | ~200 MB | ë³€ê²½ëœ ì¹´ë“œë§Œ |
| **Radiance Probes** | ìˆ˜ì²œ ~ ìˆ˜ë§Œ ê°œ (adaptive) | ~10-50 MB | 4-8 í”„ë ˆì„ë§ˆë‹¤ ìˆœí™˜ |
| **Volumetric Clipmaps** | 5 layers Ã— 64Â³ (or 128Â³) | ~10-80 MB | ë§¤ í”„ë ˆì„ (ì¦ë¶„) |
| **SSRC (Screen Space Radiance Cache)** | 1/16 screen resolution | ~5-20 MB | ë§¤ í”„ë ˆì„ |

**ì´ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰:** ~300-600 MB (1080p ê¸°ì¤€)

---

## ğŸ” 3. Acceleration Structures (ê°€ì† êµ¬ì¡°)

### 3.1 ê°œìš”: ê³„ì¸µì  ê±°ë¦¬ í•„ë“œ ì „ëµ

Lumenì˜ ë ˆì´ íŠ¸ë ˆì´ì‹±ì€ **ê±°ë¦¬ ê¸°ë°˜ 3ë‹¨ê³„ í´ë°± ì „ëµ**ì„ ì‚¬ìš©í•©ë‹ˆë‹¤:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ê±°ë¦¬ë³„ ê°€ì† êµ¬ì¡° ì„ íƒ ë‹¤ì´ì–´ê·¸ë¨                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    ì¹´ë©”ë¼
      ğŸ“·
      â”‚
      â”‚ Ray
      â†“
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Screen Space â”‚  â† HZB (Hierarchical Z-Buffer)
  â”‚   (0-5m)      â”‚    â€¢ í™”ë©´ ë‚´ í”½ì…€ë§Œ ê³ ë ¤
  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â€¢ ê°€ì¥ ë¹ ë¦„, ê°€ì¥ ì •í™•
      â”‚                â€¢ 1ms ~ 2ms
      â”‚ Miss
      â†“
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Mesh Distance â”‚  â† MDF (Mesh Distance Field)
  â”‚ Field (0-40m) â”‚    â€¢ ë©”ì‹œ ë‹¨ìœ„ SDF
  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â€¢ Sphere tracing (10-30 steps)
      â”‚                â€¢ 5ms ~ 10ms
      â”‚ Miss
      â†“
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Global        â”‚  â† GDF (Global Distance Field)
  â”‚ Distance      â”‚    â€¢ ì „ì—­ ë³¼ë¥¨ SDF
  â”‚ Field (40m+)  â”‚    â€¢ Coarse sphere tracing
  â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â€¢ 2ms ~ 5ms
      â”‚ Miss
      â†“
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Skylight    â”‚  â† Cubemap Sampling
  â”‚   (infinite)  â”‚    â€¢ í™˜ê²½ë§µ ìƒ˜í”Œë§
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â€¢ 0.1ms ~ 0.5ms
```

### 3.2 HZB (Hierarchical Z-Buffer)

**ğŸ“‚ ìœ„ì¹˜:** `Engine/Source/Runtime/Renderer/Private/ScreenSpaceRayTracing.cpp`

#### ì—­í• 

í™”ë©´ ê³µê°„(Screen Space)ì—ì„œ ê°€ì‹œì ì¸ í‘œë©´ì„ ë¹ ë¥´ê²Œ ê²€ìƒ‰í•˜ëŠ” **Mipmap ê¸°ë°˜ ê¹Šì´ ë²„í¼**ì…ë‹ˆë‹¤.

#### êµ¬ì¡°

```
ì›ë³¸ Depth Buffer (1920 x 1080):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–“â–“â–“â–“      â”‚  Mip 0 (Full Resolution)
â”‚ â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–“â–“â–‘â–‘â–‘â–‘      â”‚  ê° í”½ì…€ = depth value
â”‚ â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“ Max Filter (2x2)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â–“â–“â–“â–‘â–‘â–‘â–ˆâ–ˆâ–“â–“â–“â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–“â–“                  â”‚  Mip 1 (960 x 540)
â”‚ â–“â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–“â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–“â–‘                  â”‚  ê° í”½ì…€ = max(2x2 block)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“ Max Filter (2x2)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â–“â–“â–‘â–ˆâ–ˆâ–“â–‘â–‘â–ˆâ–ˆ                            â”‚  Mip 2 (480 x 270)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“ ...
â”Œâ”€â”€â”€â”€â”€â”
â”‚ â–“   â”‚  Mip 10 (1 x 1) - ì „ì²´ ì”¬ì˜ ìµœëŒ€ ê¹Šì´
â””â”€â”€â”€â”€â”€â”˜
```

**í•µì‹¬ ì•„ì´ë””ì–´:** Conservative Max Filter
â†’ ê° Mip ë ˆë²¨ì€ í•˜ìœ„ 4í”½ì…€ ì¤‘ **ê°€ì¥ ë¨¼ ê¹Šì´**ë¥¼ ì €ì¥
â†’ ë ˆì´ê°€ mip í”½ì…€ì„ ê±´ë„ˆë›°ë ¤ë©´ **ë ˆì´ì˜ ìµœì†Œ ê¹Šì´ > mip í”½ì…€ì˜ ìµœëŒ€ ê¹Šì´**ì—¬ì•¼ í•¨

#### Screen Space Ray Marching ì•Œê³ ë¦¬ì¦˜

```cpp
// ë‹¨ìˆœí™”ëœ HZB Ray Marching
bool TraceScreenSpaceRay(
    float3 RayOrigin,      // World space
    float3 RayDirection,   // World space
    out float3 HitUVz      // Output: Screen UV + depth
)
{
    // 1. World space â†’ Screen space ë³€í™˜
    float4 RayStartClip = mul(float4(RayOrigin, 1.0), ViewProjectionMatrix);
    float4 RayEndClip   = mul(float4(RayOrigin + RayDirection * MaxDistance, 1.0), ViewProjectionMatrix);

    float3 RayStartScreen = RayStartClip.xyz / RayStartClip.w;  // NDC
    float3 RayEndScreen   = RayEndClip.xyz / RayEndClip.w;

    // 2. Screen spaceì—ì„œ DDA (Digital Differential Analyzer) marching
    float3 RayStepScreen = RayEndScreen - RayStartScreen;
    float StepCount = max(abs(RayStepScreen.x), abs(RayStepScreen.y)) * ScreenWidth;
    float3 RayStep = RayStepScreen / StepCount;

    float3 CurrentPos = RayStartScreen;

    for (int i = 0; i < MaxSteps; i++)
    {
        // 3. Hierarchical depth comparison
        int MipLevel = ComputeMipLevel(RayStep.xy);  // ìŠ¤í… í¬ê¸°ì— ë”°ë¼ mip ì„ íƒ
        float SceneDepth = HZBTexture.SampleLevel(Sampler, CurrentPos.xy, MipLevel).r;

        // 4. Intersection test
        if (CurrentPos.z > SceneDepth)  // ë ˆì´ê°€ í‘œë©´ ë’¤ì— ìˆìŒ
        {
            // Refinement: Binary search (ì„ íƒì )
            float3 HitPos = RefineHit(CurrentPos - RayStep, CurrentPos, HZBTexture);
            HitUVz = HitPos;
            return true;
        }

        CurrentPos += RayStep;

        // 5. Screen boundary check
        if (any(CurrentPos.xy < 0.0) || any(CurrentPos.xy > 1.0))
            return false;  // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°
    }

    return false;  // Miss
}

// Mip level ê³„ì‚° (ìŠ¤í… í¬ê¸°ê°€ í´ìˆ˜ë¡ ë†’ì€ mip)
int ComputeMipLevel(float2 ScreenSpaceStepSize)
{
    float PixelStride = length(ScreenSpaceStepSize * ScreenResolution);
    return clamp(log2(PixelStride), 0, MaxMipLevel);
}
```

#### ì„±ëŠ¥ íŠ¹ì„±

**âœ… ì¥ì :**
- ë§¤ìš° ë¹ ë¦„: GPU í…ìŠ¤ì²˜ ìƒ˜í”Œë§ í™œìš©
- ë†’ì€ ì •í™•ë„: í”½ì…€ ë‹¨ìœ„ ì •ë°€ë„
- ì¶”ê°€ ë©”ëª¨ë¦¬ ì‘ìŒ: Depth buffer ì¬ì‚¬ìš©
- Glossy reflectionì— ì´ìƒì  (í™”ë©´ ë‚´ ë°˜ì‚¬)

**âŒ ë‹¨ì :**
- **í™”ë©´ ë°– = ì¶”ì  ë¶ˆê°€:** ì¹´ë©”ë¼ ë’¤, í”„ëŸ¬ìŠ¤í…€ ë°– miss
- **ë‘ê»˜ ì—†ìŒ:** Thin surfacesì—ì„œ false miss
- **Occlusion ì œí•œ:** ì• ë¬¼ì²´ì— ê°€ë ¤ì§„ ë’¤ ë¬¼ì²´ëŠ” ë³´ì´ì§€ ì•ŠìŒ

#### ì‹¤ì „ ìµœì í™” íŒ

```cpp
// âŒ ë‚˜ìœ ì˜ˆ: ëª¨ë“  ë ˆì´ë¥¼ ìµœëŒ€ ìŠ¤í…ê¹Œì§€ ì¶”ì 
for (int i = 0; i < 128; i++)  // ê³ ì • 128 ìŠ¤í…
{
    // ...
}

// âœ… ì¢‹ì€ ì˜ˆ: Adaptive step + Early exit
int MaxSteps = bHighQuality ? 64 : 32;  // í’ˆì§ˆì— ë”°ë¼ ì¡°ì •
float CurrentStepSize = InitialStepSize;

for (int i = 0; i < MaxSteps; i++)
{
    // Adaptive step size (ë©€ìˆ˜ë¡ í° ìŠ¤í…)
    CurrentStepSize *= 1.05;

    if (Intersected)
    {
        // Binary search refinement (3-5 iterations)
        HitPos = BinarySearchRefinement(HitPos, 5);
        break;  // Early exit
    }
}
```

**ì½˜ì†” ë³€ìˆ˜:**
```
r.Lumen.ScreenProbeGather.ScreenTraces 1       ; HZB ì¶”ì  í™œì„±í™”
r.Lumen.ScreenProbeGather.ScreenTracesMaxIterations 32  ; ìµœëŒ€ ìŠ¤í…
r.Lumen.ScreenProbeGather.ScreenTracesThickness 5.0     ; í‘œë©´ ë‘ê»˜ (cm)
```

### 3.3 MDF (Mesh Distance Field)

**ğŸ“‚ ìœ„ì¹˜:** `Engine/Source/Runtime/Engine/Private/DistanceFieldAtlas.cpp`

#### ì—­í• 

ê° ë©”ì‹œë¥¼ **Signed Distance Field (SDF)**ë¡œ í‘œí˜„í•˜ì—¬ ì¤‘ê±°ë¦¬(~40m) ë ˆì´ íŠ¸ë ˆì´ì‹±ì„ ê°€ì†í™”í•©ë‹ˆë‹¤.

#### Signed Distance Field (SDF) ì´ë¡ 

```
3D ê³µê°„ì˜ ê° ì  pì— ëŒ€í•´:
  SDF(p) = "pì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ í‘œë©´ê¹Œì§€ì˜ ê±°ë¦¬"

  â€¢ SDF(p) > 0  â†’  í‘œë©´ ë°– (ì–‘ìˆ˜ = ë¹ˆ ê³µê°„)
  â€¢ SDF(p) = 0  â†’  ì •í™•íˆ í‘œë©´ ìœ„
  â€¢ SDF(p) < 0  â†’  í‘œë©´ ì•ˆ (ìŒìˆ˜ = ê³ ì²´ ë‚´ë¶€)

ì˜ˆì‹œ: êµ¬ (Sphere)
  SDF(p) = length(p - center) - radius

ì˜ˆì‹œ: ë°•ìŠ¤ (Box)
  SDF(p) = length(max(abs(p - center) - halfSize, 0))
```

#### MDF ìƒì„± ê³¼ì •

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MDF ìƒì„± íŒŒì´í”„ë¼ì¸                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  1. ë©”ì‹œ ì¤€ë¹„ (Editor Time)                                              â”‚
â”‚     â”œâ”€ Static Mesh ì„í¬íŠ¸                                               â”‚
â”‚     â”œâ”€ "Generate Distance Field" ì²´í¬ (Static Mesh Editor)             â”‚
â”‚     â””â”€ Build ì‹œ .uassetì— ì„ë² ë“œ                                        â”‚
â”‚                                                                         â”‚
â”‚  2. ë³¼ë¥¨ ë³µì…€í™” (Voxelization)                                          â”‚
â”‚     â”œâ”€ Mesh bounding box ê³„ì‚°                                           â”‚
â”‚     â”œâ”€ 64Â³ ~ 128Â³ ë³µì…€ ê·¸ë¦¬ë“œ ìƒì„±                                      â”‚
â”‚     â””â”€ ê° ë³µì…€: ê°€ì¥ ê°€ê¹Œìš´ ì‚¼ê°í˜•ê¹Œì§€ ê±°ë¦¬ ê³„ì‚°                         â”‚
â”‚                                                                         â”‚
â”‚  3. Jump Flooding Algorithm (GPU-accelerated)                          â”‚
â”‚     â”œâ”€ Pass 1: 32 í”½ì…€ ì í”„                                             â”‚
â”‚     â”œâ”€ Pass 2: 16 í”½ì…€ ì í”„                                             â”‚
â”‚     â”œâ”€ Pass 3:  8 í”½ì…€ ì í”„                                             â”‚
â”‚     â”œâ”€ ...                                                              â”‚
â”‚     â””â”€ Pass N:  1 í”½ì…€ ì í”„ â†’ ì •í™•í•œ SDF ìˆ˜ë ´                           â”‚
â”‚                                                                         â”‚
â”‚  4. ì••ì¶• ë° ì €ì¥                                                         â”‚
â”‚     â”œâ”€ 3D Texture (R16_FLOAT or R8_UNORM)                              â”‚
â”‚     â”œâ”€ Mip chain ìƒì„± (LOD)                                             â”‚
â”‚     â””â”€ Distance Field Atlasì— íŒ¨í‚¹                                      â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ìƒì„± ë¹„ìš©:**
- Small mesh (~1000 tris, 64Â³): ~10ms (Editor)
- Large mesh (~100K tris, 128Â³): ~100-500ms (Editor)
- Runtimeì—ëŠ” ìƒì„± ì•ˆ í•¨ (ë¯¸ë¦¬ ë¹Œë“œë¨)

#### Sphere Tracing ì•Œê³ ë¦¬ì¦˜

SDFì˜ í•µì‹¬ ì¥ì : **ì•ˆì „í•œ ìŠ¤í‚µ ê±°ë¦¬**ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤.

```cpp
// Sphere Tracing (Ray Marching in SDF)
bool SphereTra ceMeshDistanceField(
    float3 RayOrigin,
    float3 RayDirection,
    out float3 HitPosition
)
{
    float Distance = 0.0;

    for (int Step = 0; Step < MaxSteps; Step++)
    {
        float3 CurrentPos = RayOrigin + RayDirection * Distance;

        // 1. SDF ìƒ˜í”Œë§ (3D texture lookup)
        float SDF = SampleMeshDistanceField(CurrentPos);

        // 2. Hit test
        if (SDF < HitThreshold)  // ë³´í†µ 0.1 ~ 1.0 (Unreal units)
        {
            HitPosition = CurrentPos;
            return true;
        }

        // 3. Safe step (SDF ê°’ë§Œí¼ ì•ˆì „í•˜ê²Œ ì „ì§„)
        Distance += SDF;

        // 4. Max distance check
        if (Distance > MaxTraceDistance)
            return false;  // Miss
    }

    return false;  // Max steps exceeded
}

// MDF ìƒ˜í”Œë§ (ì›”ë“œ ì¢Œí‘œ â†’ ë¡œì»¬ â†’ UVW)
float SampleMeshDistanceField(float3 WorldPosition)
{
    // Transform world â†’ local
    float3 LocalPos = mul(float4(WorldPosition, 1.0), WorldToLocal).xyz;

    // Local â†’ UVW (0-1 range)
    float3 UVW = (LocalPos - BoundsMin) / (BoundsMax - BoundsMin);

    // Boundary check
    if (any(UVW < 0.0) || any(UVW > 1.0))
        return MaxDistance;  // Outside bounding box

    // Trilinear sampling
    return DistanceFieldTexture.SampleLevel(Sampler, UVW, MipLevel).r;
}
```

**Sphere Tracing ì‹œê°í™”:**

```
Ray: â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’

ìœ„ì¹˜ 0:  SDF = 5.0  â†’  5 ìœ ë‹› ì „ì§„
  â—‹
  â”‚â•²
  â”‚ â•²
  â”‚  â•²      5.0 radius sphere (ì•ˆì „ ì˜ì—­)
  â”‚   â•²
  â”‚    â—‹

ìœ„ì¹˜ 1:  SDF = 3.0  â†’  3 ìœ ë‹› ì „ì§„
     â—‹
     â”‚â•²
     â”‚ â•²  3.0 radius
     â”‚  â—‹

ìœ„ì¹˜ 2:  SDF = 1.0  â†’  1 ìœ ë‹› ì „ì§„
        â—‹
        â”‚â•²
        â”‚ â—‹  1.0 radius

ìœ„ì¹˜ 3:  SDF = 0.05 < threshold  â†’  HIT!
           â–ˆ  (í‘œë©´)
```

#### MDF ì„±ëŠ¥ íŠ¹ì„±

**âœ… ì¥ì :**
- ì¤‘ê±°ë¦¬ì— íš¨ìœ¨ì  (0-40m)
- ë™ì  ë©”ì‹œ ì§€ì› (íŠ¸ëœìŠ¤í¼ ë³€ê²½ë§Œ ì—…ë°ì´íŠ¸)
- ë¶€ë“œëŸ¬ìš´ í‘œë©´ ê·¼ì‚¬ (Soft shadows, AO ê°€ëŠ¥)

**âŒ ë‹¨ì :**
- ë©”ëª¨ë¦¬ ì‚¬ìš©: ë©”ì‹œë‹¹ 1-8 MB
- ì–‡ì€ í‘œë©´ ë¶€ì •í™•: SDFê°€ ë‘ê»˜ ë¬´ì‹œ
- ê³ ì£¼íŒŒ ë””í…Œì¼ ì†ì‹¤: ë³µì…€ í•´ìƒë„ ì œí•œ

#### ìµœì í™” ì „ëµ

```cpp
// âœ… ì¢‹ì€ ì˜ˆ: Adaptive step size + Mip LOD
float StepSize = SDF * 0.9;  // ì•½ê°„ ë³´ìˆ˜ì ìœ¼ë¡œ (ì•ˆì „)
int MipLevel = ComputeMipFromDistance(Distance);  // ë©€ìˆ˜ë¡ ë‚®ì€ í•´ìƒë„

// âœ… ì¢‹ì€ ì˜ˆ: Early rejection
if (Distance > MaxTraceDistance * 0.5 && SDF > LargeThreshold)
    return false;  // ì ˆë°˜ ì§€ë‚˜ë„ ë©€ë©´ ì¡°ê¸° ì¢…ë£Œ

// âŒ ë‚˜ìœ ì˜ˆ: Fixed step
Distance += FixedStep;  // SDFë¥¼ ë¬´ì‹œí•˜ë©´ ë¶ˆí•„ìš”í•œ ìƒ˜í”Œë§ ì¦ê°€
```

**ì½˜ì†” ë³€ìˆ˜:**
```
r.DistanceFields.MaxPerMeshResolution 128      ; ë©”ì‹œë‹¹ ìµœëŒ€ í•´ìƒë„
r.DistanceFields.DefaultVoxelDensity 0.1       ; ë³µì…€ ë°€ë„ (ë‚®ì„ìˆ˜ë¡ ê³ í•´ìƒë„)
r.Lumen.TraceMeshSDFs 1                         ; MDF ì¶”ì  í™œì„±í™”
r.Lumen.TraceMeshSDFs.MaxIterations 30         ; ìµœëŒ€ sphere tracing ìŠ¤í…
```

### 3.4 GDF (Global Distance Field)

**ğŸ“‚ ìœ„ì¹˜:** `Engine/Source/Runtime/Renderer/Private/DistanceFieldLightingShared.cpp`

#### ì—­í• 

ì „ì²´ ì”¬ì„ ë‹¨ì¼ **ë³¼ë¥¨ í…ìŠ¤ì²˜**ë¡œ í†µí•©í•˜ì—¬ ì›ê±°ë¦¬(40m+) ë ˆì´ íŠ¸ë ˆì´ì‹±ì„ ê°€ì†í™”í•©ë‹ˆë‹¤.

#### Clipmap êµ¬ì¡°

GDFëŠ” **5ê°œ ë ˆì´ì–´ì˜ nested clipmaps**ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Global Distance Field Clipmaps                       â”‚
â”‚                    (ì¹´ë©”ë¼ ì¤‘ì‹¬, ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Layer 0 (ê°€ì¥ ì„¸ë°€)                        Voxel Size: 50 cm
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               Coverage: Â±16m
  â”‚     128Â³ voxels         â”‚
  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
  â”‚  â”‚   Layer 1       â”‚    â”‚               Voxel Size: 100 cm
  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚    â”‚               Coverage: Â±32m
  â”‚  â”‚  â”‚ Layer 2 â”‚    â”‚    â”‚
  â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”  â”‚    â”‚    â”‚               Voxel Size: 200 cm
  â”‚  â”‚  â”‚  â”‚ 3 â”‚  â”‚    â”‚    â”‚               Coverage: Â±64m
  â”‚  â”‚  â”‚  â””â”€â”€â”€â”˜  â”‚    â”‚    â”‚
  â”‚  â”‚  â”‚ Layer 4 â”‚    â”‚    â”‚               Voxel Size: 800 cm
  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚    â”‚               Coverage: Â±256m
  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                     ğŸ“· ì¹´ë©”ë¼ (ì¤‘ì‹¬)
```

**í•µì‹¬ ì•„ì´ë””ì–´:**
- ì¹´ë©”ë¼ì— ê°€ê¹Œìš´ ì˜ì—­: ë†’ì€ í•´ìƒë„ (Layer 0)
- ì¹´ë©”ë¼ì—ì„œ ë¨¼ ì˜ì—­: ë‚®ì€ í•´ìƒë„ (Layer 4)
- **í† ë¡œì´ë‹¬ ì—…ë°ì´íŠ¸ (Toroidal Update):** ì¹´ë©”ë¼ ì´ë™ ì‹œ ê²½ê³„ ë³µì…€ë§Œ ì—…ë°ì´íŠ¸

#### GDF ì—…ë°ì´íŠ¸ ê³¼ì •

```cpp
// ë‹¨ìˆœí™”ëœ GDF ì—…ë°ì´íŠ¸ ë¡œì§
void UpdateGlobalDistanceField()
{
    float3 CameraPos = GetCameraPosition();

    for (int Layer = 0; Layer < 5; Layer++)
    {
        float VoxelSize = BaseVoxelSize * pow(2.0, Layer);
        float3 ClipCenter = CameraPos;

        // 1. ë³€ê²½ëœ ì˜ì—­ ê°ì§€ (ì¹´ë©”ë¼ ì´ë™)
        float3 Offset = ClipCenter - PreviousClipCenter[Layer];
        int3 VoxelOffset = int3(Offset / VoxelSize);

        if (any(VoxelOffset != 0))
        {
            // 2. í† ë¡œì´ë‹¬ ì—…ë°ì´íŠ¸ (ê²½ê³„ ìŠ¬ë¼ì´ìŠ¤ë§Œ)
            UpdateClipmapBoundary(Layer, VoxelOffset);
        }

        // 3. ë™ì  ë©”ì‹œ ë³€ê²½ ê°ì§€
        for (Mesh in DynamicMeshes)
        {
            if (Mesh.TransformChanged || Mesh.VisibilityChanged)
            {
                // ì˜í–¥ë°›ëŠ” ë³µì…€ ì˜ì—­ ì¬ê³„ì‚°
                UpdateAffectedVoxels(Layer, Mesh);
            }
        }
    }
}

// ë³µì…€ ê°’ ê³„ì‚° (ëª¨ë“  MDF í†µí•©)
float ComputeGDFVoxel(float3 WorldPosition)
{
    float MinDistance = MaxDistance;

    // ëª¨ë“  ë©”ì‹œì˜ MDF ì¿¼ë¦¬
    for (Mesh in SceneMeshes)
    {
        float MeshSDF = SampleMeshDistanceField(Mesh, WorldPosition);
        MinDistance = min(MinDistance, MeshSDF);
    }

    return MinDistance;
}
```

#### Toroidal Update (í† ë¡œì´ë‹¬ ì—…ë°ì´íŠ¸)

ì¹´ë©”ë¼ê°€ ì´ë™í•˜ë©´ **ì „ì²´ clipmapì„ ë‹¤ì‹œ ê³„ì‚°í•˜ì§€ ì•Šê³ **, ê²½ê³„ë§Œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤:

```
ì¹´ë©”ë¼ê°€ ì˜¤ë¥¸ìª½ìœ¼ë¡œ 2 voxel ì´ë™:

ì´ì „ í”„ë ˆì„:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ A B C D E F G H â”‚  clipmap (8x8 ì˜ˆì‹œ)
â”‚ I J K L M N O P â”‚
â”‚ Q R S T U V W X â”‚
â”‚ ...             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†“ ì¹´ë©”ë¼ ì´ë™ â†’

í˜„ì¬ í”„ë ˆì„:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ C D E F G H[1][2]â”‚  [1][2] = ìƒˆë¡œ ê³„ì‚°ëœ ì—´
â”‚ K L M N O P[3][4]â”‚  A, B, I, J, Q, R = ë²„ë¦¼
â”‚ S T U V W X[5][6]â”‚  ë‚˜ë¨¸ì§€ = ì¬ì‚¬ìš©
â”‚ ...             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ë¹„ìš©: ì „ì²´ ì¬ê³„ì‚° (64 voxels) â†’ ê²½ê³„ë§Œ (16 voxels)
ì ˆê°: 75% ì—°ì‚° ê°ì†Œ
```

#### Layer ì„ íƒ ì „ëµ

```cpp
// ë ˆì´ íŠ¸ë ˆì´ì‹± ì‹œ ì ì ˆí•œ clipmap layer ì„ íƒ
int SelectClipmapLayer(float DistanceFromCamera)
{
    // Layer 0: 0-16m
    if (DistanceFromCamera < 16.0)
        return 0;
    // Layer 1: 16-32m
    else if (DistanceFromCamera < 32.0)
        return 1;
    // Layer 2: 32-64m
    else if (DistanceFromCamera < 64.0)
        return 2;
    // Layer 3: 64-128m
    else if (DistanceFromCamera < 128.0)
        return 3;
    // Layer 4: 128m+
    else
        return 4;
}

// GDF ìƒ˜í”Œë§ (ìë™ layer ì „í™˜)
float SampleGlobalDistanceField(float3 WorldPosition)
{
    float3 CameraPos = GetCameraPosition();
    float Distance = length(WorldPosition - CameraPos);

    int Layer = SelectClipmapLayer(Distance);

    // World position â†’ Clipmap UVW
    float VoxelSize = BaseVoxelSize * pow(2.0, Layer);
    float3 LocalPos = (WorldPosition - ClipmapCenter[Layer]);
    float3 UVW = (LocalPos / (VoxelSize * Resolution)) + 0.5;  // -0.5~0.5 â†’ 0~1

    return GlobalDistanceFieldTexture[Layer].SampleLevel(Sampler, UVW, 0).r;
}
```

#### ì„±ëŠ¥ íŠ¹ì„±

**âœ… ì¥ì :**
- ì›ê±°ë¦¬ ë§¤ìš° ë¹ ë¦„ (coarse voxels)
- ì „ì²´ ì”¬ í†µí•© (ë‹¨ì¼ ì¿¼ë¦¬)
- ì ì§„ì  ì—…ë°ì´íŠ¸ (í† ë¡œì´ë‹¬)

**âŒ ë‹¨ì :**
- ë©”ëª¨ë¦¬ ì‚¬ìš©: ~50-200 MB
- ë‚®ì€ ì •í™•ë„: ì›ê±°ë¦¬ì¼ìˆ˜ë¡ ë””í…Œì¼ ì†ì‹¤
- ì—…ë°ì´íŠ¸ ë¹„ìš©: ë§ì€ ë™ì  ë©”ì‹œ ì‹œ ë¶€í•˜

#### ìµœì í™” íŒ

```cpp
// âœ… ì¢‹ì€ ì˜ˆ: ê±°ë¦¬ì— ë”°ë¥¸ adaptive sampling
int MipLevel = Distance > 100.0 ? 1 : 0;  // ì›ê±°ë¦¬ëŠ” low mip
float SDF = GlobalDistanceFieldTexture[Layer].SampleLevel(Sampler, UVW, MipLevel).r;

// âœ… ì¢‹ì€ ì˜ˆ: Early exit (í•˜ëŠ˜ ë°©í–¥)
if (RayDirection.z > 0.9)  // ê±°ì˜ ìˆ˜ì§ ìœ„
    return SampleSkylight(RayDirection);  // GDF ê±´ë„ˆë›°ê¸°

// âŒ ë‚˜ìœ ì˜ˆ: í•­ìƒ Layer 0 ì‚¬ìš©
float SDF = GlobalDistanceFieldTexture[0].Sample(...);  // ì›ê±°ë¦¬ë„ ê³ í•´ìƒë„ â†’ ë‚­ë¹„
```

**ì½˜ì†” ë³€ìˆ˜:**
```
r.AOGlobalDistanceField 1                              ; GDF í™œì„±í™”
r.AOGlobalDistanceField.NumClipmaps 5                  ; Clipmap ë ˆì´ì–´ ìˆ˜
r.AOGlobalDistanceField.ClipmapResolution 128          ; ê° clipmap í•´ìƒë„
r.Lumen.TraceGlobalSDF 1                                ; Lumen GDF ì¶”ì  í™œì„±í™”
```

### 3.5 Skylight (í™˜ê²½ ì¡°ëª…)

**ğŸ“‚ ìœ„ì¹˜:** `Engine/Source/Runtime/Renderer/Private/ReflectionEnvironment.cpp`

#### ì—­í• 

ë¬´í•œ ê±°ë¦¬(í•˜ëŠ˜, ì§€í‰ì„ )ì˜ í™˜ê²½ê´‘ì„ **íë¸Œë§µ**ìœ¼ë¡œ ì œê³µí•©ë‹ˆë‹¤.

#### êµ¬ì¡°

```
Skylight Cubemap (ë³´í†µ 256x256 or 512x512 per face):
       +Y (Top)
         â”‚
   -X â”€â”€â”€â”¼â”€â”€â”€ +X
         â”‚
       -Y (Bottom)

Importance Samplingìš© Mip Chain:
   Mip 0: 512x512 (ì›ë³¸)
   Mip 1: 256x256
   Mip 2: 128x128
   ...
   Mip 9: 1x1 (í‰ê·  ë°ê¸°)
```

#### ìƒ˜í”Œë§ ì „ëµ

```cpp
// í™˜ê²½ê´‘ ìƒ˜í”Œë§
float3 SampleSkylight(float3 Direction)
{
    // 1. Cube direction â†’ UV ë³€í™˜
    float2 UV = DirectionToCubemapUV(Direction);

    // 2. Roughnessì— ë”°ë¥¸ Mip level
    float MipLevel = Roughness * MaxMipLevel;  // Glossy = Mip 0, Rough = Mip 9

    // 3. Cubemap sampling
    float3 Radiance = SkylightCubemap.SampleLevel(Sampler, Direction, MipLevel).rgb;

    // 4. Intensity scaling
    return Radiance * SkylightIntensity;
}
```

#### Importance Sampling (ì¤‘ìš”ë„ ìƒ˜í”Œë§)

Lumenì€ í™˜ê²½ê´‘ì´ ë°ì€ ë°©í–¥ì„ ìš°ì„ ì ìœ¼ë¡œ ìƒ˜í”Œë§í•©ë‹ˆë‹¤:

```cpp
// PDF ê¸°ë°˜ importance sampling
float3 SampleSkylightDirection(float2 Random, out float PDF)
{
    // 1. Mip chainì—ì„œ ë°ê¸° ë¶„í¬ ìƒ˜í”Œë§
    float3 Direction = SampleDistribution(SkylightCDF, Random);

    // 2. PDF ê³„ì‚° (í™•ë¥  ë°€ë„ í•¨ìˆ˜)
    float Luminance = Luminance(SkylightCubemap.Sample(Direction).rgb);
    PDF = Luminance / TotalLuminance;

    return Direction;
}
```

**íš¨ê³¼:**
- ë°ì€ íƒœì–‘ ë°©í–¥: ë§ì€ ìƒ˜í”Œ
- ì–´ë‘ìš´ í•˜ëŠ˜ ë°©í–¥: ì ì€ ìƒ˜í”Œ
- â†’ ë…¸ì´ì¦ˆ ê°ì†Œ, ìˆ˜ë ´ ì†ë„ í–¥ìƒ

#### ì„±ëŠ¥ íŠ¹ì„±

**âœ… ì¥ì :**
- ë§¤ìš° ë¹ ë¦„ (~0.1ms)
- ë©”ëª¨ë¦¬ ì‘ìŒ (~2-8 MB)
- Prefiltered mipsë¡œ Glossy/Rough ì§€ì›

**âŒ ë‹¨ì :**
- ì •ì  í™˜ê²½ë§Œ (ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ë¹„ìš© ë†’ìŒ)
- ê±°ë¦¬ ì •ë³´ ì—†ìŒ (ëª¨ë“  ë°©í–¥ ë¬´í•œ ê±°ë¦¬)

**ì½˜ì†” ë³€ìˆ˜:**
```
r.SkyLight.RealTimeReflectionCapture 1      ; ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ (ë¹„ìŒˆ)
r.SkyLight.IntensityScale 1.0               ; ë°ê¸° ë°°ìˆ˜
```

---

## ğŸ¨ 4. Material Sampling (ë¨¸í‹°ë¦¬ì–¼ ìƒ˜í”Œë§)

### 4.1 ê°œìš”: Surface Cache ì•„í‚¤í…ì²˜

ë ˆì´ê°€ í‘œë©´ê³¼ êµì°¨í•  ë•Œ, í•´ë‹¹ ìœ„ì¹˜ì˜ **ë¨¸í‹°ë¦¬ì–¼ ì •ë³´**(Albedo, Normal, Emissive)ê°€ í•„ìš”í•©ë‹ˆë‹¤.
Lumenì€ ì´ë¥¼ **Surface Cache**ì— ë¯¸ë¦¬ ë Œë”ë§í•˜ì—¬ ì‹¤ì‹œê°„ ì¿¼ë¦¬ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Surface Cache íŒŒì´í”„ë¼ì¸                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   ì”¬ ì§€ì˜¤ë©”íŠ¸ë¦¬                  Mesh Cards                Surface Cache
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€â”€â”€â”                      6ë°©í–¥ íˆ¬ì˜:              4K x 4K Atlas:
  â”‚ Mesh â”‚                    +X, -X, +Y, -Y, +Z, -Z   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ (3D) â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ [Card][Card]... â”‚
  â””â”€â”€â”€â”€â”€â”€â”˜                    ê° ë°©í–¥ = 1ê°œ ì¹´ë“œ         â”‚ [Card][Card]... â”‚
                                                        â”‚   Albedo (RGB)  â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”             â”‚   Normal (RGB)  â”‚
  â”‚ Mesh â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚+X â”‚-X â”‚...â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚   Emissive (RGB)â”‚
  â”‚ (3D) â”‚                    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â””â”€â”€â”€â”€â”€â”€â”˜
                                                        GPU Texture (Cached)
  ... (ìˆ˜ë°±~ìˆ˜ì²œ ë©”ì‹œ)                                  ë§¤ í”„ë ˆì„ ì¿¼ë¦¬
```

### 4.2 Mesh Cards (ë©”ì‹œ ì¹´ë“œ)

#### ê°œë…

ê° ë©”ì‹œë¥¼ **6ê°œì˜ ì •ì‚¬ì˜(orthogonal projection)**ìœ¼ë¡œ ë‹¨ìˆœí™”í•©ë‹ˆë‹¤:

```
3D Mesh:
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”
    â•±â”‚      â•±â”‚
   â•± â”‚     â•± â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚
  â”‚  â”‚    â”‚  â”‚
  â”‚  â””â”€â”€â”€â”€â”‚â”€â”€â”˜
  â”‚ â•±     â”‚ â•±
  â”‚â•±      â”‚â•±
  â””â”€â”€â”€â”€â”€â”€â”€â”˜

6-Sided Mesh Cards:
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚ +X  â”‚ -X  â”‚ +Y  â”‚ -Y  â”‚ +Z  â”‚ -Z  â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
 (ê° ì¹´ë“œ = 2D í…ìŠ¤ì²˜ ì˜ì—­)
```

#### ì¹´ë“œ ìƒì„± ê³¼ì •

```cpp
// ë‹¨ìˆœí™”ëœ Mesh Card ìƒì„±
void GenerateMeshCards(StaticMesh Mesh)
{
    Bounds AABB = Mesh.GetBounds();

    // 6ë°©í–¥ íˆ¬ì˜ ì¹´ë©”ë¼ ì„¤ì •
    for (int Direction = 0; Direction < 6; Direction++)
    {
        // 1. ì¹´ë“œ ë°©í–¥ ê²°ì •
        float3 ViewDirection = GetCardinalDirection(Direction);  // +X, -X, ...
        float3 UpVector = GetCardinalUp(Direction);

        // 2. Orthographic projection matrix
        Matrix Projection = OrthographicMatrix(AABB, ViewDirection, UpVector);

        // 3. Surface Cacheì— ë Œë”ë§
        RenderToSurfaceCache(Mesh, Projection, Direction);
    }
}

// ì¹´ë“œ í• ë‹¹ (Atlas packing)
Rect2D AllocateSurfaceCacheRect(int2 Resolution)
{
    // Bin-packing algorithm (Guillotine, Max Rects, etc.)
    return SurfaceCacheAllocator.Allocate(Resolution);
}
```

#### ì¹´ë“œ í•´ìƒë„ ê²°ì •

```
ì¹´ë“œ í•´ìƒë„ = ë©”ì‹œ í¬ê¸° / Texel Density

ì˜ˆì‹œ:
  ë©”ì‹œ í¬ê¸°: 400cm x 300cm
  Texel Density: 2 texels/cm (ì½˜ì†” ë³€ìˆ˜ë¡œ ì¡°ì •)
  â†’ ì¹´ë“œ í•´ìƒë„: 800 x 600 pixels

Surface Cacheì— í• ë‹¹:
  4096 x 4096 atlas Ã· (800 x 600) = ì•½ 34ê°œ ì¹´ë“œ ìˆ˜ìš© ê°€ëŠ¥
```

**íŠ¸ë ˆì´ë“œì˜¤í”„:**
- ë†’ì€ Texel Density â†’ ê³ í’ˆì§ˆ, ë©”ëª¨ë¦¬/ì„±ëŠ¥ ë¹„ìš© ì¦ê°€
- ë‚®ì€ Texel Density â†’ ì €í’ˆì§ˆ, ë©”ëª¨ë¦¬/ì„±ëŠ¥ ì ˆì•½

### 4.3 Surface Cache ë Œë”ë§

#### Atlas êµ¬ì¡°

```
Surface Cache Atlas (4096 x 4096, 3ì¥):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Albedo (RGBA8)                         â”‚
â”‚ â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”               â”‚
â”‚ â”‚Cardâ”‚Cardâ”‚Cardâ”‚ â”‚Cardâ”‚  ...          â”‚
â”‚ â”‚ 1  â”‚ 2  â”‚ 3  â”‚ â”‚ 4  â”‚               â”‚
â”‚ â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”˜               â”‚
â”‚  ...                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Normal (RGB10A2 or RGBA8)              â”‚
â”‚  (Octahedral encoding)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Emissive (RGBA16F)                     â”‚
â”‚  (HDR for bright emissives)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ë Œë”ë§ íŒ¨ìŠ¤

```cpp
// Surface Cache ì—…ë°ì´íŠ¸ (ë³€ê²½ëœ ì¹´ë“œë§Œ)
void UpdateSurfaceCache(TArray<MeshCard> DirtyCards)
{
    // 1. Render targets ì¤€ë¹„
    SetRenderTargets(AlbedoRT, NormalRT, EmissiveRT);

    for (MeshCard Card in DirtyCards)
    {
        // 2. Viewport ì„¤ì • (Atlas ë‚´ ì¹´ë“œ ì˜ì—­)
        SetViewport(Card.AtlasRect);

        // 3. Orthographic ì¹´ë©”ë¼
        SetViewMatrix(Card.ViewMatrix);
        SetProjectionMatrix(Card.ProjectionMatrix);

        // 4. ë©”ì‹œ ë Œë”ë§ (simplified material)
        DrawMesh(Card.Mesh, SimplifiedMaterialShader);
    }
}

// Simplified Material Shader (G-Buffer ëŒ€ì‹  ì§ì ‘ ì¶œë ¥)
void SurfaceCachePS(
    in VertexOutput Input,
    out float4 OutAlbedo : SV_Target0,
    out float4 OutNormal : SV_Target1,
    out float4 OutEmissive : SV_Target2
)
{
    // Material evaluation
    FMaterialPixelParameters Params = GetMaterialPixelParameters(Input);

    OutAlbedo = float4(GetMaterialBaseColor(Params), GetMaterialOpacity(Params));
    OutNormal = EncodeNormal(GetMaterialNormal(Params));  // Octahedral
    OutEmissive = float4(GetMaterialEmissive(Params), 0);
}
```

#### ì—…ë°ì´íŠ¸ ì „ëµ

Surface CacheëŠ” **ë³€ê²½ ê°ì§€ ê¸°ë°˜ ì¦ë¶„ ì—…ë°ì´íŠ¸**ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤:

```cpp
// ì—…ë°ì´íŠ¸ ì¡°ê±´
bool ShouldUpdateCard(MeshCard Card)
{
    return Card.Mesh.TransformChanged() ||
           Card.Mesh.MaterialChanged() ||
           Card.FirstTimeVisible() ||
           Card.LightingChanged();  // Direct lighting ë³€ê²½
}

// ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì—…ë°ì´íŠ¸ (í”„ë ˆì„ë‹¹ ì˜ˆì‚°)
void UpdateSurfaceCacheWithBudget(float MaxUpdateTimeMs)
{
    TArray<MeshCard> DirtyCards = GetDirtyCards();

    // ìš°ì„ ìˆœìœ„ ì •ë ¬ (ì¹´ë©”ë¼ì— ê°€ê¹Œìš´ ê²ƒ ìš°ì„ )
    DirtyCards.Sort([](MeshCard A, MeshCard B) {
        return A.DistanceToCamera < B.DistanceToCamera;
    });

    float ElapsedTime = 0.0;
    for (MeshCard Card in DirtyCards)
    {
        if (ElapsedTime > MaxUpdateTimeMs)
            break;  // ì˜ˆì‚° ì´ˆê³¼

        UpdateCard(Card);
        ElapsedTime += Card.UpdateCost;
    }
}
```

**ì½˜ì†” ë³€ìˆ˜:**
```
r.Lumen.SurfaceCache.AtlasSize 4096                    ; Atlas í•´ìƒë„
r.Lumen.SurfaceCache.TexelDensity 2.0                  ; Texels per cm
r.Lumen.SurfaceCache.UpdateFrameBudgetMs 2.0           ; í”„ë ˆì„ë‹¹ ì—…ë°ì´íŠ¸ ì˜ˆì‚°
```

### 4.4 Surface Cache ìƒ˜í”Œë§

#### ë ˆì´ íˆíŠ¸ â†’ UV ë³€í™˜

```cpp
// ë ˆì´ê°€ í‘œë©´ê³¼ êµì°¨í–ˆì„ ë•Œ Surface Cache ìƒ˜í”Œë§
float3 SampleSurfaceCacheAtHit(float3 HitWorldPosition, float3 HitNormal)
{
    // 1. íˆíŠ¸ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ì í•©í•œ Mesh Card ì°¾ê¸°
    MeshCard Card = FindBestCard(HitWorldPosition, HitNormal);

    // 2. World position â†’ Card local UV
    float2 CardUV = WorldToCardUV(HitWorldPosition, Card);

    // 3. Card UV â†’ Atlas UV
    float2 AtlasUV = CardUVToAtlasUV(CardUV, Card.AtlasRect);

    // 4. Surface Cache ìƒ˜í”Œë§
    float3 Albedo = SurfaceCacheAlbedo.SampleLevel(Sampler, AtlasUV, 0).rgb;
    float3 Normal = DecodeNormal(SurfaceCacheNormal.SampleLevel(Sampler, AtlasUV, 0).rgb);
    float3 Emissive = SurfaceCacheEmissive.SampleLevel(Sampler, AtlasUV, 0).rgb;

    return Albedo;  // ë˜ëŠ” ë¼ì´íŒ… ê³„ì‚°ì— ì‚¬ìš©
}

// ìµœì  ì¹´ë“œ ì„ íƒ (ë²•ì„ ê³¼ ê°€ì¥ ì¼ì¹˜í•˜ëŠ” ì¹´ë“œ)
MeshCard FindBestCard(float3 WorldPos, float3 Normal)
{
    float BestDot = -1.0;
    MeshCard BestCard = null;

    for (MeshCard Card in GetCardsAtPosition(WorldPos))
    {
        float Dot = dot(Normal, Card.Direction);
        if (Dot > BestDot)
        {
            BestDot = Dot;
            BestCard = Card;
        }
    }

    return BestCard;
}
```

### 4.5 Nanite í†µí•©

Lumenì€ **Naniteì˜ ê°€ìƒí™”ëœ ì§€ì˜¤ë©”íŠ¸ë¦¬**ì™€ ê¸´ë°€íˆ í†µí•©ë©ë‹ˆë‹¤:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Nanite + Lumen Surface Cache í†µí•©                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  Nanite Rendering Pass:                                                â”‚
â”‚  â”œâ”€ Visibility Buffer (pixel â†’ triangle ID)                            â”‚
â”‚  â”œâ”€ Material Pass (deferred texturing)                                 â”‚
â”‚  â””â”€ Export Geometry (for Lumen)                                        â”‚
â”‚      â”‚                                                                  â”‚
â”‚      â”œâ”€â†’ Mesh Distance Field (ê°€ì† êµ¬ì¡°)                               â”‚
â”‚      â”œâ”€â†’ Mesh Cards (6-sided projection)                               â”‚
â”‚      â””â”€â†’ Surface Cache (ë¨¸í‹°ë¦¬ì–¼ ë°ì´í„°)                               â”‚
â”‚                                                                         â”‚
â”‚  â˜… ìµœì í™”:                                                              â”‚
â”‚     Naniteì˜ LOD ì‹œìŠ¤í…œ â†’ Surface Cache í•´ìƒë„ ìë™ ì¡°ì •               â”‚
â”‚     ë©€ë¦¬ ìˆëŠ” ë©”ì‹œ = ë‚®ì€ í•´ìƒë„ ì¹´ë“œ                                   â”‚
â”‚     ê°€ê¹Œìš´ ë©”ì‹œ = ë†’ì€ í•´ìƒë„ ì¹´ë“œ                                      â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Nanite ì´ì :**
- ìˆ˜ì‹­ì–µ í´ë¦¬ê³¤ë„ ì¼ì •í•œ Surface Cache ë¹„ìš©
- ìë™ LOD â†’ ì¹´ë“œ í•´ìƒë„ ìë™ ìŠ¤ì¼€ì¼ë§
- ìŠ¤íŠ¸ë¦¬ë° â†’ ë³´ì´ì§€ ì•ŠëŠ” ë©”ì‹œëŠ” Surface Cache ë¯¸í• ë‹¹

**ì½˜ì†” ë³€ìˆ˜:**
```
r.Nanite.SupportLumenScene 1                ; Nanite â†’ Lumen ë°ì´í„° export
r.Lumen.SurfaceCache.NaniteMultiBounce 1    ; Nanite ë©”ì‹œ ë‹¤ì¤‘ ë°˜ì‚¬ ì§€ì›
```

---

## ğŸ’¡ 5. Light Accumulation (ë¼ì´íŒ… ëˆ„ì )

### 5.1 ê°œìš”: ì§ì ‘ê´‘ + ê°„ì ‘ê´‘

Lumenì˜ ë¼ì´íŒ…ì€ **2ë‹¨ê³„ ëˆ„ì **ìœ¼ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Light Accumulation íŒŒì´í”„ë¼ì¸                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   Light Sources                Surface Cache               GI Data
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”€â”€â”€â”€â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Direct   â”‚  Shadow Maps
  â”‚ Lights   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  [Surface Cache]  â”€â”€â”€â”€â”€â”€â”€â”€â†’  [Emissive]
  â”‚ (Sun,    â”‚                  ì§ì ‘ê´‘ ë² ì´í‚¹                ì§ì ‘ê´‘ ì €ì¥
  â”‚  Point,  â”‚
  â”‚  Spot)   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                                      â†“

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                [Surface Cache]
  â”‚ Indirect â”‚  Radiance      + Emissive
  â”‚ Bounce   â”‚  Probes        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  [Volumetric]
  â”‚ (GI)     â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   ë ˆì´ íŠ¸ë ˆì´ì‹±          [Clipmaps]
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                32 rays/probe         ê°„ì ‘ê´‘ ì €ì¥


ìµœì¢… ì¶œë ¥: Surface Cache (ì§ì ‘ê´‘) + Volumetric Clipmaps (ê°„ì ‘ê´‘)
```

### 5.2 Direct Lighting (ì§ì ‘ê´‘)

#### Shadow Map ê¸°ë°˜ ì§ì ‘ê´‘

```cpp
// Surface Cacheì— ì§ì ‘ê´‘ ë² ì´í‚¹
void BakeDirectLightingToSurfaceCache(Light light)
{
    // 1. Shadow map ë Œë”ë§
    ShadowMapRT = RenderShadowMap(Light);

    // 2. Surface Cacheì˜ ê° ì¹´ë“œ ìˆœíšŒ
    for (MeshCard Card in AllCards)
    {
        for (Texel in Card)
        {
            float3 WorldPos = CardTexelToWorld(Card, Texel);
            float3 Normal = SurfaceCacheNormal.Load(Texel);

            // 3. Shadow test
            float Shadow = SampleShadowMap(Light, WorldPos);

            // 4. Direct lighting ê³„ì‚°
            float3 LightDir = normalize(Light.Position - WorldPos);
            float NoL = saturate(dot(Normal, LightDir));
            float3 Irradiance = Light.Color * Light.Intensity * NoL * Shadow;

            // 5. Emissiveì— ì¶”ê°€ (ê°„ì ‘ê´‘ ì†ŒìŠ¤ë¡œ ì‚¬ìš©)
            SurfaceCacheEmissive[Texel] += Irradiance * SurfaceCacheAlbedo[Texel];
        }
    }
}
```

**ìµœì í™”:**
- **Virtual Shadow Maps (VSM):** Naniteì™€ í†µí•©ëœ ê³ í•´ìƒë„ ì„€ë„ìš°
- **Incremental update:** ë¼ì´íŠ¸ ì´ë™/ë³€ê²½ ì‹œì—ë§Œ ì—…ë°ì´íŠ¸
- **Cascaded shadow maps:** íƒœì–‘ê´‘ì— ëŒ€í•´ ê±°ë¦¬ë³„ í•´ìƒë„ ì¡°ì •

### 5.3 Indirect Lighting: Radiance Probes

#### Probe ë°°ì¹˜ ì „ëµ

```
Adaptive Probe Placement (ì›”ë“œ ê³µê°„):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                         â”‚
â”‚    ë‚®ì€ ë°€ë„ (ë¹ˆ ê³µê°„)          ë†’ì€ ë°€ë„ (ë³µì¡í•œ êµ¬ì¡°)                  â”‚
â”‚                                                                         â”‚
â”‚         â—‹           â—‹              â—‹  â—‹                                 â”‚
â”‚                                   â—‹ â—‹ â—‹   (ì‹¤ë‚´)                        â”‚
â”‚              â—‹                    â—‹  â—‹                                  â”‚
â”‚                         â—‹          â”€â”¬â”€                                  â”‚
â”‚    â—‹              â—‹                 â”‚  ê±´ë¬¼                             â”‚
â”‚                                     â”‚                                   â”‚
â”‚         â—‹                  â—‹       â”€â”´â”€                                  â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

í”„ë¡œë¸Œ ë°€ë„ = f(ì§€ì˜¤ë©”íŠ¸ë¦¬ ë³µì¡ë„, ë¼ì´íŒ… ë³€í™”ìœ¨)
```

#### Probe ì—…ë°ì´íŠ¸ (ìˆœí™˜ ë°©ì‹)

```cpp
// í”„ë ˆì„ë‹¹ ì¼ë¶€ í”„ë¡œë¸Œë§Œ ì—…ë°ì´íŠ¸ (ì˜ˆì‚° ê´€ë¦¬)
void UpdateRadianceProbes(float FrameBudgetMs)
{
    int ProbesPerFrame = MaxProbes / TemporalSpreadFrames;  // ì˜ˆ: 10000 / 8 = 1250

    for (int i = 0; i < ProbesPerFrame; i++)
    {
        int ProbeIndex = (FrameNumber * ProbesPerFrame + i) % MaxProbes;
        RadianceProbe Probe = Probes[ProbeIndex];

        // Probe ì—…ë°ì´íŠ¸
        UpdateProbe(Probe);
    }
}

// ë‹¨ì¼ Probe ì—…ë°ì´íŠ¸
void UpdateProbe(RadianceProbe Probe)
{
    float3 Radiance[32];  // 32 ë°©í–¥

    for (int RayIndex = 0; RayIndex < 32; RayIndex++)
    {
        // 1. Ray direction (Spherical Fibonacci)
        float3 RayDir = SphericalFibonacci(RayIndex, 32);

        // 2. Ray tracing (HZB â†’ MDF â†’ GDF)
        HitResult Hit;
        if (TraceRay(Probe.Position, RayDir, Hit))
        {
            // 3. Surface Cache ìƒ˜í”Œë§
            float3 Albedo = SampleSurfaceCache(Hit.Position);
            float3 Emissive = SampleSurfaceCacheEmissive(Hit.Position);

            // 4. ì¬ê·€ GI (1-bounce approximation)
            float3 IndirectLight = SampleVolumetricClipmap(Hit.Position, Hit.Normal);

            Radiance[RayIndex] = Emissive + Albedo * IndirectLight;
        }
        else
        {
            // Sky miss
            Radiance[RayIndex] = SampleSkylight(RayDir);
        }
    }

    // 5. Temporal accumulation
    Probe.Radiance = lerp(Probe.Radiance, Radiance, 0.1);  // 10 í”„ë ˆì„ ëˆ„ì 
}
```

#### Spherical Fibonacci (ê· ë“± ë¶„í¬)

Probeì˜ 32ê°œ rayëŠ” **êµ¬ë©´ì— ê· ë“±í•˜ê²Œ ë¶„í¬**ë˜ì–´ì•¼ í•©ë‹ˆë‹¤:

```
Spherical Fibonacci Lattice:
        â—  (North Pole)
      â— â— â—
    â— â— â— â— â—
  â— â— â— â— â— â— â—
    â— â— â— â— â—
      â— â— â—
        â—  (South Pole)

ê° ì  ê°„ ê±°ë¦¬ê°€ ìµœëŒ€í•œ ê· ë“±
â†’ ëª¨ë“  ë°©í–¥ì„ ëŒ€í‘œí•˜ëŠ” ìƒ˜í”Œë§
```

```cpp
float3 SphericalFibonacci(int Index, int NumSamples)
{
    float GoldenRatio = (1.0 + sqrt(5.0)) / 2.0;
    float Theta = 2.0 * PI * Index / GoldenRatio;
    float Phi = acos(1.0 - 2.0 * (Index + 0.5) / NumSamples);

    return float3(
        cos(Theta) * sin(Phi),
        sin(Theta) * sin(Phi),
        cos(Phi)
    );
}
```

### 5.4 Volumetric Clipmaps (ë³¼ë¥¨ GI)

#### êµ¬ì¡°

```
5-Layer Nested Clipmaps (ì¹´ë©”ë¼ ì¤‘ì‹¬):

Layer 0 (finest):     128Â³ voxels, 50cm/voxel  â†’  Â±32m coverage
Layer 1:              128Â³ voxels, 100cm/voxel â†’  Â±64m coverage
Layer 2:              128Â³ voxels, 200cm/voxel â†’  Â±128m coverage
Layer 3:              128Â³ voxels, 400cm/voxel â†’  Â±256m coverage
Layer 4 (coarsest):   128Â³ voxels, 800cm/voxel â†’  Â±512m coverage
```

ê° ë³µì…€ ì €ì¥:
```cpp
struct VolumetricVoxel
{
    float3 Radiance;      // RGB (incoming light)
    float3 Direction;     // Dominant light direction (SH or octahedral)
    float Opacity;        // Occlusion factor
};
```

#### Voxel ì—…ë°ì´íŠ¸

```cpp
// Volumetric Clipmap ì—…ë°ì´íŠ¸ (í† ë¡œì´ë‹¬)
void UpdateVolumetricClipmaps()
{
    for (int Layer = 0; Layer < 5; Layer++)
    {
        float VoxelSize = BaseVoxelSize * pow(2.0, Layer);

        // ë³€ê²½ëœ voxel ì˜ì—­ë§Œ ì—…ë°ì´íŠ¸
        for (Voxel in UpdatedVoxels[Layer])
        {
            float3 VoxelCenter = GetVoxelWorldPosition(Voxel, Layer);

            // Radiance Probe ë³´ê°„ìœ¼ë¡œ voxel ê°’ ê³„ì‚°
            float3 Radiance = InterpolateRadianceProbes(VoxelCenter);

            VolumetricClipmap[Layer][Voxel] = Radiance;
        }
    }
}

// Radiance Probe ë³´ê°„ (Trilinear)
float3 InterpolateRadianceProbes(float3 WorldPosition)
{
    // ì£¼ë³€ 8ê°œ í”„ë¡œë¸Œ ì°¾ê¸°
    RadianceProbe Probes[8] = FindNearbyProbes(WorldPosition);

    // Trilinear interpolation
    float3 Weights = ComputeTrilinearWeights(WorldPosition, Probes);

    float3 Radiance = 0;
    for (int i = 0; i < 8; i++)
        Radiance += Probes[i].SampleDirection(Normal) * Weights[i];

    return Radiance;
}
```

#### Clipmap ìƒ˜í”Œë§

```cpp
// Final Gatherì—ì„œ GI ì¿¼ë¦¬
float3 SampleVolumetricGI(float3 WorldPosition, float3 Normal)
{
    // 1. ì ì ˆí•œ clipmap layer ì„ íƒ
    float DistanceFromCamera = length(WorldPosition - CameraPosition);
    int Layer = SelectClipmapLayer(DistanceFromCamera);

    // 2. World position â†’ Clipmap UVW
    float VoxelSize = BaseVoxelSize * pow(2.0, Layer);
    float3 UVW = (WorldPosition - ClipmapCenter[Layer]) / (VoxelSize * Resolution) + 0.5;

    // 3. Trilinear sampling
    float4 VoxelData = VolumetricClipmap[Layer].SampleLevel(Sampler, UVW, 0);

    // 4. Directional radiance (ë²•ì„  ê¸°ë°˜)
    float3 Radiance = VoxelData.rgb;
    float3 Direction = DecodeDirection(VoxelData.a);
    float NdotL = saturate(dot(Normal, Direction));

    return Radiance * NdotL;
}
```

### 5.5 ì„±ëŠ¥ ìµœì í™” ì „ëµ

#### Temporal Spreading (ì‹œê°„ì  ë¶„ì‚°)

```
í”„ë ˆì„ë³„ ì—…ë°ì´íŠ¸ ë¶„ì‚°:
Frame 0: Probes[0:1249]       ì—…ë°ì´íŠ¸
Frame 1: Probes[1250:2499]    ì—…ë°ì´íŠ¸
Frame 2: Probes[2500:3749]    ì—…ë°ì´íŠ¸
...
Frame 7: Probes[8750:9999]    ì—…ë°ì´íŠ¸
Frame 8: Probes[0:1249]       ì—…ë°ì´íŠ¸ (cycle)

â†’ ê° í”„ë¡œë¸ŒëŠ” 8 í”„ë ˆì„ë§ˆë‹¤ ì—…ë°ì´íŠ¸
â†’ ì‹œê°„ì  ì¼ê´€ì„± ìœ ì§€ + í”„ë ˆì„ ë¶€í•˜ ë¶„ì‚°
```

#### Importance-Based Updates

```cpp
// ì¤‘ìš”ë„ ê¸°ë°˜ ìš°ì„ ìˆœìœ„
float ComputeProbeImportance(RadianceProbe Probe)
{
    float Distance = length(Probe.Position - CameraPosition);
    float Visibility = IsProbeVisible(Probe);
    float LightingChange = Probe.RadianceChangeRate;

    return Visibility * (1.0 / (Distance + 1.0)) * LightingChange;
}

// ìš°ì„ ìˆœìœ„ ì •ë ¬ í›„ ìƒìœ„ Nê°œë§Œ ì—…ë°ì´íŠ¸
Probes.Sort(ComputeProbeImportance);
UpdateTopNProbes(Probes, FrameBudget);
```

**ì½˜ì†” ë³€ìˆ˜:**
```
r.Lumen.RadianceCache.NumProbes 10000                ; ìµœëŒ€ í”„ë¡œë¸Œ ìˆ˜
r.Lumen.RadianceCache.RaysPerProbe 32                ; í”„ë¡œë¸Œë‹¹ ray ìˆ˜
r.Lumen.RadianceCache.TemporalFilter 0.1             ; ì‹œê°„ì  í•„í„° ê°•ë„
r.Lumen.VolumetricClipmaps.NumLayers 5               ; Clipmap ë ˆì´ì–´ ìˆ˜
r.Lumen.VolumetricClipmaps.Resolution 128            ; ê° ë ˆì´ì–´ í•´ìƒë„
```

---

## ğŸ¯ 6. Final Gather (ìµœì¢… ìˆ˜ì§‘)

### 6.1 ê°œìš”: SSRC + WSRC

Final GatherëŠ” **í™”ë©´ í”½ì…€ë³„ë¡œ ìµœì¢… GI ê°’ì„ ê³„ì‚°**í•˜ëŠ” ë‹¨ê³„ì…ë‹ˆë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Final Gather íŒŒì´í”„ë¼ì¸                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   í™”ë©´ í”½ì…€ (1920x1080)
        â”‚
        â†“ 1/16 downsampling

   Probe Grid (120x68)  â† 16x16 í”½ì…€ë‹¹ 1ê°œ probe
        â”‚
        â”œâ”€â†’ SSRC (Screen Space Radiance Cache)
        â”‚    â”œâ”€ 32 rays/probe
        â”‚    â”œâ”€ Importance sampling (BRDF weighted)
        â”‚    â”œâ”€ HZB â†’ MDF â†’ GDF tracing
        â”‚    â””â”€ Surface Cache + Volumetric GI
        â”‚
        â””â”€â†’ WSRC (World Space Radiance Cache)
             â”œâ”€ Volumetric Clipmap ì¿¼ë¦¬
             â”œâ”€ Radiance Probe ë³´ê°„
             â””â”€ Spatial coherence í™œìš©

        â†“ Bilateral upsampling (68â†’1080)

   Final GI (1920x1080)
        â”‚
        â”œâ”€â†’ Temporal Filter (4-8 frames)
        â””â”€â†’ Spatial Filter (edge-aware blur)

   Final Image with GI
```

### 6.2 SSRC (Screen Space Radiance Cache)

#### Probe ë°°ì¹˜

```
í™”ë©´ í•´ìƒë„: 1920 x 1080
Probe í•´ìƒë„: 120 x 68  (1/16)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”  â”‚
â”‚ â”‚ â— â”‚   â”‚   â”‚ â— â”‚   â”‚   â”‚ â— â”‚   â”‚   â”‚  â”‚  â— = Probe
â”‚ â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤  â”‚
â”‚ â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚  â”‚  ê° 16x16 í”½ì…€ ë¸”ë¡ì—
â”‚ â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤  â”‚  1ê°œ probe ë°°ì¹˜
â”‚ â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â”‚  â”‚
â”‚ â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤  â”‚
â”‚ â”‚ â— â”‚   â”‚   â”‚ â— â”‚   â”‚   â”‚ â— â”‚   â”‚   â”‚  â”‚
â”‚ â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ê° Probe: 32 rays â†’ 32 radiance samples
ì´ ë¹„ìš©: 120Ã—68Ã—32 = 261,120 rays/frame
```

#### SSRC ê³„ì‚°

```cpp
// Screen Space Radiance Cache ê³„ì‚°
void ComputeSSRC()
{
    int2 ProbeResolution = ScreenResolution / 16;  // 1/16 í•´ìƒë„

    for (int2 ProbeCoord : ProbeResolution)
    {
        // 1. Probeì˜ world position ì¬êµ¬ì„±
        float2 ScreenUV = (ProbeCoord + 0.5) / ProbeResolution;
        float Depth = SceneDepth.Sample(ScreenUV);
        float3 WorldPos = ReconstructWorldPosition(ScreenUV, Depth);
        float3 Normal = GBufferNormal.Sample(ScreenUV);

        // 2. Importance sampling (BRDF ê¸°ë°˜)
        float3 Radiance[32];
        for (int RayIndex = 0; RayIndex < 32; RayIndex++)
        {
            // Cosine-weighted hemisphere sampling
            float3 RayDir = ImportanceSampleGGX(RayIndex, Normal, Roughness);

            // 3. Ray tracing
            HitResult Hit;
            if (TraceRay(WorldPos, RayDir, Hit))
            {
                // Surface Cache radiance
                float3 Albedo = SampleSurfaceCache(Hit.Position);
                float3 Emissive = SampleSurfaceCacheEmissive(Hit.Position);

                // Recursive GI (1-bounce)
                float3 IndirectGI = SampleVolumetricGI(Hit.Position, Hit.Normal);

                Radiance[RayIndex] = Emissive + Albedo * IndirectGI;
            }
            else
            {
                // Skylight
                Radiance[RayIndex] = SampleSkylight(RayDir);
            }
        }

        // 4. Radiance ëˆ„ì  (Octahedral packing)
        SSRCTexture[ProbeCoord] = PackRadiance(Radiance);
    }
}
```

#### Octahedral Packing (8x8 texels per probe)

32ê°œ ë°©í–¥ì˜ radianceë¥¼ **8x8 í…ìŠ¤ì²˜ ë¸”ë¡**ì— ì €ì¥:

```
SSRC Texture (960 x 544):  // 120 probes Ã— 8 texels = 960
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚ â”‚8x8   â”‚8x8   â”‚8x8   â”‚8x8   â”‚...   â”‚    â”‚  ê° 8x8 = 1ê°œ probe
â”‚ â”‚Probe â”‚Probe â”‚Probe â”‚Probe â”‚      â”‚    â”‚
â”‚ â”‚  0   â”‚  1   â”‚  2   â”‚  3   â”‚      â”‚    â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤    â”‚
â”‚ â”‚8x8   â”‚8x8   â”‚...                 â”‚    â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Octahedral mapping: 3D direction â†’ 2D texel
```

```cpp
// Octahedral mapping (direction â†’ UV)
float2 DirectionToOctahedralUV(float3 Direction)
{
    float3 Oct = Direction / (abs(Direction.x) + abs(Direction.y) + abs(Direction.z));
    float2 UV = Oct.z >= 0.0
        ? Oct.xy
        : (1.0 - abs(Oct.yx)) * sign(Oct.xy);  // Fold negative hemisphere

    return UV * 0.5 + 0.5;  // -1~1 â†’ 0~1
}
```

### 6.3 WSRC (World Space Radiance Cache)

WSRCëŠ” **ì›”ë“œ ê³µê°„ì˜ GI ìºì‹œ**ë¡œ, í™”ë©´ ë°– ì˜ì—­ë„ ì»¤ë²„í•©ë‹ˆë‹¤:

```cpp
// World Space Radiance Cache ì¿¼ë¦¬
float3 QueryWSRC(float3 WorldPosition, float3 Normal)
{
    // 1. Volumetric Clipmap ìƒ˜í”Œë§
    float3 VolumetricGI = SampleVolumetricGI(WorldPosition, Normal);

    // 2. Radiance Probe ë³´ê°„ (ì¶”ê°€ ë””í…Œì¼)
    float3 ProbeGI = InterpolateRadianceProbes(WorldPosition, Normal);

    // 3. Blend (ê±°ë¦¬ì— ë”°ë¼)
    float Distance = length(WorldPosition - CameraPosition);
    float BlendFactor = saturate(Distance / 40.0);  // 40m ì´ìƒì€ volumetric ìš°ì„ 

    return lerp(ProbeGI, VolumetricGI, BlendFactor);
}
```

**SSRC vs WSRC:**

| íŠ¹ì„± | SSRC | WSRC |
|------|------|------|
| **ì»¤ë²„ë¦¬ì§€** | í™”ë©´ ë‚´ë§Œ | ì „ì²´ ì›”ë“œ |
| **í•´ìƒë„** | ë†’ìŒ (1/16 screen) | ë‚®ìŒ (voxel ê¸°ë°˜) |
| **ì—…ë°ì´íŠ¸** | ë§¤ í”„ë ˆì„ | ì ì§„ì  (temporal spread) |
| **ìš©ë„** | í™”ë©´ ë‚´ ê³ í’ˆì§ˆ GI | í™”ë©´ ë°– fallback |

### 6.4 Bilateral Upsampling

1/16 í•´ìƒë„ probe â†’ Full í•´ìƒë„ í”½ì…€:

```cpp
// Bilateral upsampling (edge-aware)
float3 UpsampleSSRC(float2 PixelUV)
{
    // 1. ì£¼ë³€ 4ê°œ probe ì°¾ê¸°
    float2 ProbeUV = PixelUV * ProbeResolution;
    int2 ProbeCoord = floor(ProbeUV);
    float2 Frac = frac(ProbeUV);

    // 2. Bilinear weights
    float4 Weights = float4(
        (1 - Frac.x) * (1 - Frac.y),
        Frac.x * (1 - Frac.y),
        (1 - Frac.x) * Frac.y,
        Frac.x * Frac.y
    );

    // 3. Depth/Normal similarity (edge-aware)
    float PixelDepth = SceneDepth.Sample(PixelUV);
    float3 PixelNormal = GBufferNormal.Sample(PixelUV);

    float4 DepthWeights;
    float4 NormalWeights;
    for (int i = 0; i < 4; i++)
    {
        int2 Offset = int2(i % 2, i / 2);
        float ProbeDepth = ProbeDepthBuffer[ProbeCoord + Offset];
        float3 ProbeNormal = ProbeNormalBuffer[ProbeCoord + Offset];

        DepthWeights[i] = exp(-abs(PixelDepth - ProbeDepth) / DepthSigma);
        NormalWeights[i] = pow(saturate(dot(PixelNormal, ProbeNormal)), NormalPower);
    }

    // 4. Combined weights
    Weights *= DepthWeights * NormalWeights;
    Weights /= dot(Weights, 1.0);  // Normalize

    // 5. Weighted sum
    float3 Radiance = 0;
    for (int i = 0; i < 4; i++)
    {
        int2 Offset = int2(i % 2, i / 2);
        float3 ProbeRadiance = SampleSSRC(ProbeCoord + Offset, PixelNormal);
        Radiance += ProbeRadiance * Weights[i];
    }

    return Radiance;
}
```

**íš¨ê³¼:**
- Edge preservation: ê¹Šì´/ë²•ì„  ë¶ˆì—°ì†ì—ì„œ blur ë°©ì§€
- Light leaking ê°ì†Œ: ë²½ ê±´ë„ˆ GI ìœ ì¶œ ë°©ì§€

### 6.5 Temporal Filtering

```cpp
// ì‹œê°„ì  í•„í„° (ghosting ë°©ì§€)
float3 TemporalFilterGI(float2 ScreenUV, float3 CurrentGI)
{
    // 1. Motion vectorë¡œ ì´ì „ í”„ë ˆì„ ìœ„ì¹˜ ì°¾ê¸°
    float2 MotionVector = GetMotionVector(ScreenUV);
    float2 PrevUV = ScreenUV - MotionVector;

    // 2. Disocclusion detection
    float CurrentDepth = SceneDepth.Sample(ScreenUV);
    float PrevDepth = PrevSceneDepth.Sample(PrevUV);
    bool Disoccluded = abs(CurrentDepth - PrevDepth) > DisocclusionThreshold;

    // 3. Temporal blend
    float3 PrevGI = PrevGIBuffer.Sample(PrevUV);
    float BlendFactor = Disoccluded ? 0.5 : 0.05;  // Disocclusion ì‹œ ë¹ ë¥¸ ìˆ˜ë ´

    float3 FilteredGI = lerp(PrevGI, CurrentGI, BlendFactor);

    // 4. ì €ì¥ (ë‹¤ìŒ í”„ë ˆì„ìš©)
    PrevGIBuffer[ScreenUV] = FilteredGI;

    return FilteredGI;
}
```

**Blend Factor ì¡°ì •:**
- 0.05 (ì¼ë°˜): 20í”„ë ˆì„ ëˆ„ì  â†’ ë¶€ë“œëŸ¬ì›€
- 0.5 (Disocclusion): 2í”„ë ˆì„ ëˆ„ì  â†’ ë¹ ë¥¸ ì ì‘

### 6.6 Spatial Filtering

```cpp
// ê³µê°„ì  í•„í„° (ë…¸ì´ì¦ˆ ê°ì†Œ)
float3 SpatialFilterGI(float2 ScreenUV, float3 CenterGI)
{
    float3 Filtered = 0;
    float WeightSum = 0;

    float PixelDepth = SceneDepth.Sample(ScreenUV);
    float3 PixelNormal = GBufferNormal.Sample(ScreenUV);

    // 3x3 ë˜ëŠ” 5x5 kernel
    for (int y = -FilterRadius; y <= FilterRadius; y++)
    {
        for (int x = -FilterRadius; x <= FilterRadius; x++)
        {
            float2 Offset = float2(x, y) * PixelSize;
            float2 SampleUV = ScreenUV + Offset;

            float3 SampleGI = GIBuffer.Sample(SampleUV);
            float SampleDepth = SceneDepth.Sample(SampleUV);
            float3 SampleNormal = GBufferNormal.Sample(SampleUV);

            // Bilateral weights
            float DepthWeight = exp(-abs(PixelDepth - SampleDepth) / DepthSigma);
            float NormalWeight = pow(saturate(dot(PixelNormal, SampleNormal)), 8.0);
            float SpatialWeight = exp(-length(float2(x, y)) / SpatialSigma);

            float Weight = DepthWeight * NormalWeight * SpatialWeight;

            Filtered += SampleGI * Weight;
            WeightSum += Weight;
        }
    }

    return Filtered / WeightSum;
}
```

**í•„í„° ë°˜ê²½:**
- Radius 1 (3x3): ë¹ ë¦„, ì•½í•œ í•„í„°ë§
- Radius 2 (5x5): ì¤‘ê°„, ê¶Œì¥
- Radius 3 (7x7): ëŠë¦¼, ê°•í•œ í•„í„°ë§ (ghosting ì‹œ)

**ì½˜ì†” ë³€ìˆ˜:**
```
r.Lumen.ScreenProbeGather.NumProbes 120 68           ; SSRC probe í•´ìƒë„
r.Lumen.ScreenProbeGather.TracingOctahedronResolution 8  ; Octahedral resolution
r.Lumen.ScreenProbeGather.TemporalFilter 0.05        ; ì‹œê°„ì  í•„í„° ê°•ë„
r.Lumen.ScreenProbeGather.SpatialFilterRadius 2      ; ê³µê°„ì  í•„í„° ë°˜ê²½
```

---

## âš™ï¸ 7. ì„±ëŠ¥ ìµœì í™” ë° í’ˆì§ˆ ì¡°ì •

### 7.1 ì½˜ì†” ë³€ìˆ˜ ê°€ì´ë“œ

#### í’ˆì§ˆ í”„ë¦¬ì…‹

```
// Ultra Quality (4K, RTX 4090)
r.Lumen.ScreenProbeGather.TracingOctahedronResolution 16
r.Lumen.ScreenProbeGather.RadianceCache.NumProbes 16384
r.Lumen.TraceMeshSDFs.MaxIterations 50
r.Lumen.Reflections.ScreenTraces 1
r.Lumen.Reflections.MaxRoughnessToTrace 0.6

// High Quality (1440p, RTX 3080)
r.Lumen.ScreenProbeGather.TracingOctahedronResolution 12
r.Lumen.ScreenProbeGather.RadianceCache.NumProbes 10000
r.Lumen.TraceMeshSDFs.MaxIterations 30
r.Lumen.Reflections.ScreenTraces 1
r.Lumen.Reflections.MaxRoughnessToTrace 0.5

// Medium Quality (1080p, RTX 3060)
r.Lumen.ScreenProbeGather.TracingOctahedronResolution 8  (ê¸°ë³¸ê°’)
r.Lumen.ScreenProbeGather.RadianceCache.NumProbes 4096
r.Lumen.TraceMeshSDFs.MaxIterations 20
r.Lumen.Reflections.ScreenTraces 0
r.Lumen.Reflections.MaxRoughnessToTrace 0.4

// Low Quality (1080p, GTX 1660)
r.Lumen.ScreenProbeGather.TracingOctahedronResolution 4
r.Lumen.ScreenProbeGather.RadianceCache.NumProbes 2048
r.Lumen.TraceMeshSDFs.MaxIterations 10
r.Lumen.Reflections 0  (ë°˜ì‚¬ ë¹„í™œì„±í™”)
```

#### í•µì‹¬ ë³€ìˆ˜ ì„¤ëª…

| ë³€ìˆ˜ | ê¸°ë³¸ê°’ | ì„¤ëª… | ì„±ëŠ¥ ì˜í–¥ |
|------|--------|------|----------|
| `r.Lumen.ScreenProbeGather.TracingOctahedronResolution` | 8 | Probeë‹¹ ray ìˆ˜ (8x8=64 rays) | ë§¤ìš° ë†’ìŒ (ì œê³±) |
| `r.Lumen.ScreenProbeGather.RadianceCache.NumProbes` | 4096 | ìµœëŒ€ radiance probe ìˆ˜ | ë†’ìŒ |
| `r.Lumen.TraceMeshSDFs.MaxIterations` | 30 | MDF sphere tracing ìµœëŒ€ ìŠ¤í… | ì¤‘ê°„ |
| `r.Lumen.TraceGlobalSDF.MaxIterations` | 20 | GDF sphere tracing ìµœëŒ€ ìŠ¤í… | ë‚®ìŒ |
| `r.Lumen.SurfaceCache.AtlasSize` | 4096 | Surface cache í•´ìƒë„ | ë©”ëª¨ë¦¬ |
| `r.Lumen.Reflections.MaxRoughnessToTrace` | 0.5 | ë°˜ì‚¬ ì¶”ì  ìµœëŒ€ ê±°ì¹ ê¸° | ë†’ìŒ |

### 7.2 ì¼ë°˜ì ì¸ ë¬¸ì œì™€ í•´ê²°

#### Light Leaking (ë¹› ìœ ì¶œ)

**ë¬¸ì œ:**
ì–‡ì€ ë²½ì„ í†µê³¼í•˜ì—¬ ë¹›ì´ ìƒˆì–´ë‚˜ì˜´

```
     [ì‹¤ë‚´]  â”‚  [ì‹¤ì™¸]
     ì–´ë‘ì›€  â”‚â–ˆ ë°ìŒ
            â”‚â–ˆ
     â—„â”€â”€â”€â”€â”€â”¼â–ˆâ”€â”€â”€  ë¹›ì´ ë²½ í†µê³¼ (ëˆ„ì¶œ)
            â”‚â–ˆ
```

**ì›ì¸:**
- Spatial filteringì´ ë²½ ê²½ê³„ë¥¼ ë„˜ì–´ blur
- Distance Field í•´ìƒë„ ë¶€ì¡± (ì–‡ì€ ë²½ = 0ìœ¼ë¡œ ê·¼ì‚¬)
- Probe ë°°ì¹˜ê°€ ë²½ ê²½ê³„ì— ê±¸ì¹¨

**í•´ê²°:**
```
// 1. Surface Cache ë‘ê»˜ ì„¤ì •
r.Lumen.SurfaceCache.Thickness 10.0  (ê¸°ë³¸ê°’ 5.0ì—ì„œ ì¦ê°€)

// 2. Spatial filter ê°ì†Œ
r.Lumen.ScreenProbeGather.SpatialFilterRadius 1  (ê¸°ë³¸ê°’ 2)

// 3. Distance Field í•´ìƒë„ ì¦ê°€
r.DistanceFields.MaxPerMeshResolution 128  (ê¸°ë³¸ê°’ 64)

// 4. Bilateral filter ê°•í™”
r.Lumen.ScreenProbeGather.BilateralFilterDepthWeightScale 10000.0  (ê¸°ë³¸ê°’ 1000.0)
```

#### Ghosting (ì”ìƒ)

**ë¬¸ì œ:**
ë¹ ë¥¸ ì¹´ë©”ë¼ ì´ë™ ì‹œ ì´ì „ í”„ë ˆì„ GIê°€ ë‚¨ìŒ

**ì›ì¸:**
- Temporal accumulation (0.05 = 20í”„ë ˆì„ ëˆ„ì )
- Disocclusion detection ì‹¤íŒ¨

**í•´ê²°:**
```
// 1. Temporal filter ì•½í™”
r.Lumen.ScreenProbeGather.TemporalFilter 0.2  (ê¸°ë³¸ê°’ 0.05, ë” ë¹ ë¥¸ ì ì‘)

// 2. Disocclusion threshold ì¡°ì •
r.Lumen.ScreenProbeGather.DisocclusionDepthRatio 0.01  (ê¸°ë³¸ê°’ 0.02, ë” ë¯¼ê°)

// 3. VR/ë¹ ë¥¸ ê²Œì„: Temporal ë¹„í™œì„±í™” ê³ ë ¤
r.Lumen.ScreenProbeGather.TemporalFilter 1.0  (ëˆ„ì  ì—†ìŒ, ë‹¨ì¼ í”„ë ˆì„)
```

#### ë…¸ì´ì¦ˆ (Flickering)

**ë¬¸ì œ:**
GIê°€ í”„ë ˆì„ë§ˆë‹¤ ê¹œë¹¡ì„ (íŠ¹íˆ ì–´ë‘ìš´ ì˜ì—­)

**ì›ì¸:**
- Ray ìˆ˜ ë¶€ì¡± (Monte Carlo ë…¸ì´ì¦ˆ)
- Temporal filter ë„ˆë¬´ ì•½í•¨

**í•´ê²°:**
```
// 1. Ray ìˆ˜ ì¦ê°€
r.Lumen.ScreenProbeGather.TracingOctahedronResolution 12  (8â†’12, 64â†’144 rays)

// 2. Temporal filter ê°•í™”
r.Lumen.ScreenProbeGather.TemporalFilter 0.02  (0.05â†’0.02, 50í”„ë ˆì„ ëˆ„ì )

// 3. Spatial filter ë°˜ê²½ ì¦ê°€
r.Lumen.ScreenProbeGather.SpatialFilterRadius 3  (2â†’3, 7x7 kernel)
```

#### ì„±ëŠ¥ ì €í•˜ (Low FPS)

**ë¬¸ì œ:**
Lumen í™œì„±í™” ì‹œ í”„ë ˆì„ë ˆì´íŠ¸ ê¸‰ë½

**ì›ì¸:**
- ë„ˆë¬´ ë§ì€ ray ìƒ˜í”Œë§
- ë³µì¡í•œ ì”¬ (ë§ì€ ë™ì  ë©”ì‹œ)

**í•´ê²°:**
```
// 1. Ray ìˆ˜ ê°ì†Œ (ê°€ì¥ íš¨ê³¼ì )
r.Lumen.ScreenProbeGather.TracingOctahedronResolution 4  (8â†’4, 64â†’16 rays)

// 2. Probe ìˆ˜ ê°ì†Œ
r.Lumen.ScreenProbeGather.RadianceCache.NumProbes 2048  (4096â†’2048)

// 3. MDF ì¶”ì  ìŠ¤í… ê°ì†Œ
r.Lumen.TraceMeshSDFs.MaxIterations 15  (30â†’15)

// 4. ë°˜ì‚¬ ë¹„í™œì„±í™” (í° ì ˆê°)
r.Lumen.Reflections 0

// 5. Radiance cache ì—…ë°ì´íŠ¸ ë¹ˆë„ ê°ì†Œ
r.Lumen.RadianceCache.TemporalSpreadFrames 16  (8â†’16, 16í”„ë ˆì„ì— ê±¸ì³ ë¶„ì‚°)
```

### 7.3 ë””ë²„ê·¸ ì‹œê°í™”

```
// ê°€ì† êµ¬ì¡° ì‹œê°í™”
r.Lumen.Visualize.Mode 1        ; HZB
r.Lumen.Visualize.Mode 2        ; Mesh Distance Fields
r.Lumen.Visualize.Mode 3        ; Global Distance Field

// Surface Cache ì‹œê°í™”
r.Lumen.Visualize.SurfaceCache 1

// Radiance Cache ì‹œê°í™”
r.Lumen.Visualize.RadianceCache 1

// Final Gather ë””ë²„ê·¸
r.Lumen.ScreenProbeGather.Visualize 1  ; Probe ìœ„ì¹˜ ë° radiance

// ì„±ëŠ¥ í†µê³„
stat Lumen                      ; Lumen ì „ì²´ í†µê³„
stat GPU                        ; GPU íƒ€ì´ë°
r.Lumen.ScreenProbeGather.ShowStats 1  ; ìƒì„¸ í†µê³„
```

### 7.4 í”„ë¡œíŒŒì¼ë§ ê°€ì´ë“œ

```
Unreal Insightsë¡œ Lumen ë³‘ëª© ì§€ì  íŒŒì•…:

1. Lumen Scene Update (0.5-2ms)
   - Surface Cache ì—…ë°ì´íŠ¸
   - Distance Field ì—…ë°ì´íŠ¸

2. Radiance Cache (2-5ms)
   - Probe ì—…ë°ì´íŠ¸
   - Volumetric clipmap ì—…ë°ì´íŠ¸

3. Final Gather (5-15ms)  â† ì£¼ìš” ë³‘ëª©
   - Screen probe tracing (ê°€ì¥ ë¹„ìŒˆ)
   - Bilateral upsampling
   - Temporal/Spatial filtering

4. Reflections (2-8ms)
   - Glossy reflections
   - Roughness-based filtering

ìµœì í™” ìš°ì„ ìˆœìœ„:
  Final Gather > Reflections > Radiance Cache > Scene Update
```

---

## ğŸ“Š 8. ë²¤ì¹˜ë§ˆí¬ ë° ë¹„êµ

### 8.1 Lumen vs ê¸°ì¡´ GI ê¸°ìˆ 

| ê¸°ìˆ  | í’ˆì§ˆ | ì„±ëŠ¥ (1080p) | ë™ì  ë¼ì´íŒ… | í•˜ë“œì›¨ì–´ ìš”êµ¬ |
|------|------|--------------|------------|-------------|
| **Baked Lightmaps** | ë†’ìŒ (ì •ì ) | ë¬´ë£Œ (0ms) | âŒ ì—†ìŒ | ëª¨ë“  GPU |
| **SSAO/SSGI** | ë‚®ìŒ (screen space) | ë¹ ë¦„ (2-3ms) | âš ï¸ ì œí•œì  | ëª¨ë“  GPU |
| **Irradiance Volumes (VL)** | ì¤‘ê°„ | ì¤‘ê°„ (5-10ms) | âœ… ì™„ì „ | ëª¨ë“  GPU |
| **Hardware RT (DXR)** | ë§¤ìš° ë†’ìŒ | ë§¤ìš° ëŠë¦¼ (20-50ms) | âœ… ì™„ì „ | RTX 2000+ |
| **Lumen** | ë†’ìŒ | ë¹ ë¦„ (8-15ms) | âœ… ì™„ì „ | GTX 1000+ |

### 8.2 ë…¼ë¬¸ ì‹¤í—˜ ê²°ê³¼ (UE 5.0.3)

Anna Skorobogatova ë…¼ë¬¸ì—ì„œ ì¸¡ì •í•œ ì„±ëŠ¥:

**í…ŒìŠ¤íŠ¸ ì”¬:** Lyra Starter Game (Epicì˜ ìƒ˜í”Œ í”„ë¡œì íŠ¸)
**í•˜ë“œì›¨ì–´:** RTX 3070 (ë…¼ë¬¸ ê¸°ì¤€ ì¶”ì •)
**í•´ìƒë„:** 1920x1080

| ì„¤ì • | í‰ê·  FPS | 1% Low FPS | Lumen ë¹„ìš© | ë¹„ê³  |
|------|----------|------------|------------|------|
| Lumen OFF | 120 FPS | 90 FPS | 0ms | Baked lighting |
| Lumen Low | 90 FPS | 70 FPS | ~5ms | ë‚®ì€ ray ìˆ˜ |
| Lumen Medium | 70 FPS | 55 FPS | ~10ms | ê¸°ë³¸ ì„¤ì • |
| Lumen High | 50 FPS | 38 FPS | ~15ms | ë†’ì€ ray ìˆ˜ |
| Lumen + Reflections | 45 FPS | 32 FPS | ~18ms | ë°˜ì‚¬ í¬í•¨ |

### 8.3 ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰

```
Lumen ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ (1080p, Medium ì„¤ì •):

Distance Fields:
  - Mesh Distance Fields (100 meshes): ~150 MB
  - Global Distance Field (5 clipmaps): ~80 MB

Surface Cache:
  - Albedo Atlas (4K): ~64 MB
  - Normal Atlas (4K): ~64 MB
  - Emissive Atlas (4K): ~64 MB

GI Data:
  - Radiance Probes (4096 probes): ~15 MB
  - Volumetric Clipmaps (5 layers): ~40 MB
  - SSRC (960x544x3): ~10 MB

ê¸°íƒ€:
  - HZB (mip chain): ~8 MB
  - Temporal buffers: ~20 MB

ì´í•©: ~515 MB

4K í•´ìƒë„ ì‹œ: ~800 MB (SSRC ë° temporal buffer ì¦ê°€)
```

---

## ğŸ”— 9. ì°¸ê³  ìë£Œ

### 9.1 1ì°¨ ìë£Œ (ë…¼ë¬¸ ê¸°ë°˜)

- **Anna Skorobogatova (2022):** "Real-Time Global Illumination in Unreal Engine 5"
  Masaryk University, Fall 2022
  â†’ Lumen ì•„í‚¤í…ì²˜ì˜ ê°€ì¥ ìƒì„¸í•œ í•™ìˆ ì  ë¶„ì„

### 9.2 Epic ê³µì‹ ë¬¸ì„œ

- **Unreal Engine Documentation:** [Lumen Global Illumination](https://docs.unrealengine.com/5.0/en-US/lumen-global-illumination-and-reflections-in-unreal-engine/)
- **Unreal Engine Documentation:** [Distance Fields](https://docs.unrealengine.com/5.0/en-US/mesh-distance-fields-in-unreal-engine/)
- **Unreal Engine Documentation:** [Nanite Virtualized Geometry](https://docs.unrealengine.com/5.0/en-US/nanite-virtualized-geometry-in-unreal-engine/)

### 9.3 GDC ë° SIGGRAPH ë°œí‘œ

- **Brian Karis (Epic Games, GDC 2022):** "Lumen: Real-Time Global Illumination in Unreal Engine 5"
  â†’ Lumenì˜ ê³µì‹ ê¸°ìˆ  ë°œí‘œ
- **Daniel Wright (Epic Games, SIGGRAPH 2015):** "Dynamic Occlusion with Signed Distance Fields"
  â†’ Distance Field ê¸°ìˆ ì˜ ê¸°ì´ˆ

### 9.4 í•™ìˆ  ë°°ê²½

- **James Kajiya (1986):** "The Rendering Equation"
  SIGGRAPH 1986
  â†’ ë¬¼ë¦¬ ê¸°ë°˜ ë Œë”ë§ì˜ ì´ë¡ ì  ê¸°ë°˜

- **Turner Whitted (1979):** "An Improved Illumination Model for Shaded Display"
  Communications of the ACM
  â†’ ë ˆì´ íŠ¸ë ˆì´ì‹±ì˜ ì‹œì´ˆ

### 9.5 ì†ŒìŠ¤ ì½”ë“œ ì°¸ì¡°

```
Engine/Source/Runtime/Renderer/Private/
â”œâ”€â”€ Lumen/
â”‚   â”œâ”€â”€ LumenSceneRendering.cpp          ; Scene update
â”‚   â”œâ”€â”€ LumenRadianceCache.cpp           ; Radiance probes
â”‚   â”œâ”€â”€ LumenScreenProbeGather.cpp       ; Final gather (SSRC)
â”‚   â”œâ”€â”€ LumenReflections.cpp             ; Reflections
â”‚   â””â”€â”€ LumenSurfaceCache.cpp            ; Surface cache
â”œâ”€â”€ DistanceFieldAtlas.cpp                ; MDF generation
â”œâ”€â”€ DistanceFieldLightingShared.cpp       ; GDF management
â””â”€â”€ ScreenSpaceRayTracing.cpp            ; HZB tracing
```

---

## ğŸ“ 10. ë³€ê²½ ì´ë ¥

> **v1.0 â€” 2025-11-23:** Lumen Architecture Deep Dive ì´ˆì•ˆ ì‘ì„±
> ê¸°ë°˜: Anna Skorobogatova ë…¼ë¬¸ (UE 5.0.3)
> ë‹¤ìŒ ì‘ì—…: UE 5.7 ì†ŒìŠ¤ ê²€ì¦ í•„ìš”

---

## ğŸ’¡ 11. ë§ˆë¬´ë¦¬ ìš”ì•½

### Lumenì˜ í•µì‹¬ ì„¤ê³„ ì›ì¹™

1. **ì†Œí”„íŠ¸ì›¨ì–´ ë ˆì´ íŠ¸ë ˆì´ì‹±:** DXR í•˜ë“œì›¨ì–´ ì˜ì¡´ì„± ì œê±°
2. **ê³„ì¸µì  ê·¼ì‚¬:** ê±°ë¦¬ì— ë”°ë¼ í’ˆì§ˆ-ì„±ëŠ¥ íŠ¸ë ˆì´ë“œì˜¤í”„
3. **ì‹œê³µê°„ ì¬ì‚¬ìš©:** Temporal accumulation + Spatial coherence
4. **Nanite ì‹œë„ˆì§€:** ê°€ìƒí™”ëœ ì§€ì˜¤ë©”íŠ¸ë¦¬ + ê°€ìƒí™”ëœ ë¼ì´íŒ…

### ê°œë°œìë¥¼ ìœ„í•œ í•µì‹¬ í¬ì¸íŠ¸

```
âœ… í•´ì•¼ í•  ê²ƒ:
  - Distance Field í™œì„±í™” (Generate Distance Field)
  - Surface Cache ë‘ê»˜ ì¡°ì • (ì–‡ì€ ë²½ ì²˜ë¦¬)
  - ì½˜ì†” ë³€ìˆ˜ë¡œ í’ˆì§ˆ-ì„±ëŠ¥ ë°¸ëŸ°ì‹±
  - Temporal filter ì¡°ì • (ì¹´ë©”ë¼ ì†ë„ì— ë”°ë¼)

âŒ í”¼í•´ì•¼ í•  ê²ƒ:
  - ë§¤ìš° ì–‡ì€ ì§€ì˜¤ë©”íŠ¸ë¦¬ (<5cm)
  - ê³¼ë„í•œ ë™ì  ë©”ì‹œ (ìˆ˜ì²œ ê°œ ë™ì‹œ ì´ë™)
  - ì‹¤ì‹œê°„ Surface Cache ì „ì²´ ì¬ë¹Œë“œ
  - Temporal filter ì™„ì „ ë¹„í™œì„±í™” (ë…¸ì´ì¦ˆ í­ë°œ)
```

### ì„±ëŠ¥ ëª©í‘œ (1080p ê¸°ì¤€)

| íƒ€ê²Ÿ í•˜ë“œì›¨ì–´ | í”„ë ˆì„ë ˆì´íŠ¸ | ê¶Œì¥ ì„¤ì • | Lumen ë¹„ìš© |
|--------------|-------------|----------|------------|
| **RTX 4090** | 144 FPS | Ultra | ~8ms |
| **RTX 3080** | 90 FPS | High | ~10ms |
| **RTX 3060** | 60 FPS | Medium | ~12ms |
| **GTX 1660** | 60 FPS | Low | ~15ms |

### ì°¨ì„¸ëŒ€ ë°©í–¥

- **UE 5.4+:** Hardware RT ì˜µì…˜ (HWRT mode)
- **UE 5.5+:** Multi-bounce GI ê°œì„ 
- **UE 5.7:** Lumen in forward rendering (í˜„ì¬ëŠ” deferredë§Œ)

---

**ì´ ë¬¸ì„œëŠ” Lumenì˜ ì„¤ê³„ ì² í•™, ì•„í‚¤í…ì²˜, êµ¬í˜„ ì„¸ë¶€ì‚¬í•­ì„ í¬ê´„í•©ë‹ˆë‹¤.**
**UE 5.7 ì†ŒìŠ¤ ê²€ì¦ í›„ ì¶”ê°€ ì—…ë°ì´íŠ¸ ì˜ˆì •ì…ë‹ˆë‹¤.**